# [ABC403](https://atcoder.jp/contests/abc403) Review
- Rated参加
- DをスキップしたままEのデバッグに膨大な時間を費やすというヒヤヒヤする展開
  - なんとかEが解けたのでよかったものの……
- てか今回D以降が難しくね？

## D - Forbidden Difference
- 時間切れ
- うっすらDPなんだろうなぁと思いつつ具体的な手段が思いつかないのでとりあえずスキップ
  - Eを解いた後に戻るも時間がないのでとりあえず貪欲法でやってみたがやっぱり`WA`
- （公式解説） $x \bmod D$ で分ければ3項間漸化式なる……確かに言わたらそうなんだけれども

## E - Forbidden Prefix
- AC（63分＋2WA）
- 複数の文字列に対してprefixを調べる……これこの間やったぞ！Trie木だ！
  - やっててよかったABC353……助かったぜ
  - しかし慣れていないので無限に時間を食ってしまった
- 2つのTrie木`tx, ty`を用意してクエリごとに以下を行う
  - $X$ に $S$ を追加する場合
    - `tx`に $S$ を追加する
    - `ty`から $S$ を削除する
  - $Y$ に $S$ を追加する場合
    - $S$ の任意のprefixが`tx`に含まれているなら何もしない
    - そうでない場合、`ty`に $S$ を追加する
  - いずれの場合も`ty`のサイズを出力する
- ↑の操作を実現するためにTrie木に以下のメソッドを実装した
  - `bool contains_prefix_of(const string &s)`：引数`s`の任意のprefixがTrie木に含まれているかどうか
    - 単に`s`の文字順に木を辿っていき、受理する文字列がある頂点が存在すれば`true`
  - `void remove_start_with(const string &s)`：引数`s`をprefixとする文字列をTrie木から削除する
    - `s`の文字順に木を辿っていき、最後にたどり着いた頂点（以降`v`とする）を使用している文字列の個数`num_removed_str`を記録する
    - もう一度`s`の文字順に木を辿り、すべての頂点においてそれを使用している文字列の数から`num_removed_str`を引く
    - `v`の隣接リストおよび受理する文字列を初期化する
    - `v`の直前の頂点から`v`への辺を削除する
    - 対応する頂点が完全に消えるわけではないが、少なくとも受理する頂点と使用中の文字列の個数が合えばいいのでこのくらい雑でいいっしょ！の精神
- `void remove_start_with(const string &s)`のバグ潰しに時間がかかる
  - まずバグが発生するテストケースを作るのに手間取った
    - しばらく後にようやく`v`の直前の頂点から`v`への辺が削除できていないことに気づいた
- （公式解説）やっぱりTrie木に削除を組み込むのは狂気の沙汰っぽいねぇ……
