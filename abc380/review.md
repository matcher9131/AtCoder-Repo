# [ABC380](https://atcoder.jp/contests/abc381) Review
- バーチャル参加
- DまでをもっとスピードアップしないとEが解けん…

## D - Strange Mirroring
- AC(1WA)
- 出来上がる文字列を $|S|$ 文字ごとに区切ると、当然その内容は $S$ か $T$ かのいずれか
  - よって $K_i$ を $|S|$ で割った商を $q_i$ 、余りを $r_i$ とおくと、求める文字は $S$ または $T$ の $r_i$ 番目である
  - あとは $q_i$ 番目(0-indexed)のブロックが $S$ なのか $T$ なのかを判定すればOK
    - $f(x)$ を $x$ 番目のブロックが $S$ であるかどうかの真偽値を返す関数と定義すると、 $f(x) = \overline{f(x \bmod g(x))}$
      - ただし、 $g(x)$ は $x$ 以上で最小の2の累乗数
      - これを $K_i$ ごとに計算しても再帰部分は高々64回の呼び出しなので間に合う
- なぜか $q_i \leq 64$ と勘違いして1敗

## E - 1D Bucket Tool
- 時間切れ
- 色を塗ったあとに隣接マスが同じ色なら連結する…Union-findやんけ！となるも
  - 指定されたマスの左右が同じ色になっているかどうかで判定してしまい1敗
    - 正しくは指定されたマスを含む連結成分の左端の左隣および右端の右隣を見る必要がある
- 単に連結部分とその色を管理する`ordered_map`があればOK
  - 色を塗ったあとに左隣の連結部分、右隣の連結部分のそれぞれの色を確認して、同じなら1つの連結成分にまとめる
    - なお端の処理が面倒なのであらかじめ存在しない色で塗られた番兵を用意しておく
  - 各色のセル数は色を塗るときにしか変化しないので、別途に管理すれば $O(1)$ で取得できる
- しかし連結部分の左端セルを管理してそこに`lower_bound`を掛けてしまい失敗
  - これだと一つ右隣の区間を取得してしまう
  - 連結部分の右端セルを管理して`lower_bound`を掛ければOK

## F - Exchange Game
- 終了後に公式解説をヒントにして提出
- 局面（手番含む）数を見積もり、時間的・空間的余裕が十分にあるならメモ化再帰
```
// プレイヤーA勝ち, プレイヤーB勝ち, 未探索の3つの値を取る
def memo[手番を含むありうる局面数]

// 引数はまとめて1つにしてもよいかもしれない
function wins(局面, プレイヤー)
  if memo[手番を含む局面] is not 未探索
    return memo[手番を含む局面]
  for each 局面でできるすべての行動
    if wins(新しい局面, 相手プレイヤー) is false
      memo[手番を含む新しい局面] = true
      return true
  memo[手番を含む局面] = false
  return false
```