# AtCoder Problems Recommend Reivew
AtCoder Problems Recommendでおすすめされる問題をひたすら解いてひたすらレビューする

## ABC174 E - Logs
- 最小化問題すなわち二分探索法
  - 最小値を直接求めるのは難しいが、ある値にすることができるかどうかの判定が容易い場合の鉄板パターン
- めぐる式二分探索法でやってみた

## ABC251 E - Takahashi and Animals
- 行動 $1$ をするDPと行動 $1$ をしないDPに場合分けして考える
- DPそのものを場合分けして2回やる発想はなかった
  - 一応2次元DPまではわかっており、その点は◎
  - DPなんだろうなぁと思いつつ、行動 $1$ をするかどうかで行動 $N$ をするのかどうかが変わるしどうすればええねん…で止まってしまった

## ABC096 D - Five, Five Everywhere
- 素数判定問題
- 当然 ${}_{55}C_5 \simeq 3.5 \times 10^6$ パターンに対して合成数かどうかなんて判定してたら余裕で`TLE`なわけで
  - なのでどの5つを選んでも合成数になるようにしなければならない
    - 5つ足して合成数なら5の倍数を目指すのが最も楽

## ABC264 E - Blackout 2
- 1つずつグラフの辺を削除しながらクエリに答える系の問題
- 逆順にすればUnion-findで辺を追加しながらいけるんじゃね？とすぐにわかったのは◎
  - 発電所と繋ぐ場合は必ず親を発電所にすることで各都市が発電所につながっているか簡単に調べられることにも気づいた
- しかし辺を追加するたびにいちいち全都市に対して発電所が親かどうかを確認してしまい $O(NQ) = O(10^{11})$ で無事`TLE`
  - 正しくは、発電所につながっていないグループのサイズがそのまま新しく電気が通る都市の数になることを利用する。この場合 $O(N + Q)$ のはず…
- Union-findは割とカスタマイズできる（connectの親の選び方、戻り値）ことを覚えておく

## ABC164 D - Multiple of 2019
- ${}_{N}C_2$通りすべてを調べるともちろん`TLE`
- 2019の倍数かどうかを調べる問題なので、余りの遷移をみたい
  - 遷移を1つだけ保持するのではなく、余りごとに個数を記録すべし
- 当然ながら $i < j$ に対し $S_{[i, N]} \equiv S_{[j, N]}$ ならば $S_{[i, j - 1]} \equiv 0 \pmod 2019$ という数学的考察も大事

## AGC003 B - Simplified mahjong
- **麻雀と聞いて（ｶﾞﾀｯ**
  - 麻雀関連はいろいろコードを書いたことがあったので、考察が楽に捗った
- それでもまさか単に下から貪欲に刻子→順子の順に取るだけだとは思わず、疑心暗鬼で提出したらあっさり`AC`で拍子抜け
  - やっぱり**今の水色は難しすぎる**って！

## ABC198 D - Send More Money
- $10! = 3.6 \times 10^6$ なので全パターン試してもよさそう
- というわけで`next_permutation()`でゴリゴリ回す
  - 文字列の置き換えも含めて $O(N^2 \times N!)$ …のはず（ただし $N = \max \{ |S_1|, |S_2|, |S_3| \}$）

## ABC062 C - Chocolate Bar
- まず、 $H$ か $W$ が3の倍数のときは~~アホになります~~3等分ができる
- そうでなくてもとりあえず縦2回 or 横2回で切れば $S_{\max} - S_{\min} = \min \{ H, W \}$ とできる
- あとは縦→横 or 横→縦の順番で切るパターンを考える
  - いずれの場合も2回目の切断はできる2つのピースの面積を最小にするべきなので、中央（奇数ならほぼ中央）で切る
  - 1回目の切る場所は全探索しても $O(H + W)$ なので問題なし

## ABC089 D - Practical Skill Test
- **計算量は毎回きちんと見積もること**
  - そりゃ全てのクエリで毎回探索してたら $O(HWQ)$ で`TLE`だわな…
- $D$ が共通であることにピンとくることができる体になりたい
  - そして差を求める系の問題には累積和が特効薬

## ABC256 E - Takahashi's Anguish
- 全てのノードにおいて出次数が1なので、1つの連結成分に対し必ずちょうど1個のサイクルが生じる
  - サイクルではない部分に関しては、入次数が0の人からグラフをたどるように渡していけば全員に不満が生じない
  - サイクル部分に関しては、グラフをたどるように渡していけば最後に渡される人にのみ不満が生じる
- よってサイクルごとに最小辺を見つけ、その不満度を合計すれば解になる
- 具体的にはUnion-find木を構築し、根ごとにDFSを回してサイクルを取得、その最小辺のコストを合計した
  - が、提出後にUnion-find木の構築中にサイクルを検出できることに気づく
    - しかも今回は全てのノードの出次数が1なので、サイクル復元も単にforループを1回回すだけで済む…
      - 要するにDFSが大げさすぎる
        - ま、まぁ`AC`したからよしとしましょう（震え声）

## ABC200 D - Happy Birthday! 2
- 以下 $A_i$ は $A_i \bmod 200$ に置き換える
- とりあえず思いついたのはDP
  - `dp[i][k]`: $A$ の先頭 $i$ 個からいくつか選んだ和の200で割った余りが $k$ になるパターンの総数
- DP復元は初挑戦だったが…
  - デバッグの嵐
    - わからなすぎて禁断のテストケース覗き見を敢行
      - $A_i = 0$ のとき、 $A_i$ を選んでも選ばなくても $k$ の遷移元が同じなので区別がつかず、 $B$ と $C$ で同じ選択をしてしまっていた
        - 復元のときに $A_i = 0$ について別個に処理することで対処
      - **普通にオーバーフロー**
        - DPの値は2以上ならば差はないので、既に2以上のときは（経路復元用のほうも含めて）更新しないようにした
- （公式解説）ここで鳩の巣原理はカッコよすぎる

## ABC308 F - Vouchers
- 間違った貪欲法をしてしまい行方不明に
  - なぜか $P_i \geq L_j$ となる最小の $j$ （ただし、同じ $L_j$ のクーポンが複数ある場合は $D_j$ が最も大きいもの）のクーポンを選んで使っていた
- もちろん正しくは $P_i \geq L_j$ となるクーポン $j$ のうち、最も $D_j$ が大きいものを選択する必要がある
  - ただし実装を間違うと余裕で`TLE`なのでさらなる考察が要る
    - $A_i$ と $L_j$ をそれぞれ昇順に並べた場合、$i$ が増えるとともに使えるクーポン $j$ が $0$ から順番に増えていく
      - 順番に増えるというのがポイントで、使えるクーポンを探索する必要がない（どこまで使えるのかを記録するだけでOK）
    - 一方で使うクーポンはその時点で最も $D$ が大きいものになる
    - ここでクーポンのデータを2重で持つと計算量を減らせる
      - まずはクーポン全体をソートされた配列で持つ
      - 次にその時点で使えるクーポンを管理する`priority_queue`を作る
        - これによりその時点で $D$ が最大になるクーポンが $O(1)$ で選べるばかりか、使ったクーポンを削除するのも $O(1)$ でいいことずくめ
- 「全体から検索」が計算量的にきつそうなら「全体→今候補になるもの→検索」というクッションを作る！

## ABC300 E - Dice Product 3
- $\bmod \ 998244353$ での割り算を計算する術がない！
  - もちろんAtCoder Libraryを使ってもよかったのだが、後学のために自作した
    - ガバいテストケースも作ってちゃんとテストを通したのでヨシ！~~（現場猫案件ではないことを祈る）~~
    - 忘れたころにやってくるフェルマーの小定理さん：「整数 $a$ 、素数 $p$ に対し $a^{p - 1} \equiv 1 \pmod p$」
- 計算は例によってDP
  - $dp_{i,j,k}$ を $x = 2^i3^j5^k$ になる確率と定義
    - このとき $dp_{i,j,k} = \frac{1}{6}dp_{i,j,k} + \frac{1}{6}dp_{i-1,j,k} + \frac{1}{6}dp_{i,j-1,k} + \frac{1}{6}dp_{i-2,j,k} + \frac{1}{6}dp_{i,j,k-1} + \frac{1}{6}dp_{i-1,j-1,k}$
      - ただし $i = 1,2$ or $j = 1$ or $k = 1$ のときは添え字が0以下になる項は $0$ として扱う
    - 変形して $dp_{i,j,k} = \frac{1}{5}dp_{i-1,j,k} + \frac{1}{5}dp_{i,j-1,k} + \frac{1}{5}dp_{i-2,j,k} + \frac{1}{5}dp_{i,j,k-1} + \frac{1}{5}dp_{i-1,j-1,k}$
    - 計算量は $O((\log N)^3)$ なので問題なし
    - DPの更新順も特に気を使う必要がなく楽に実装
- サイコロの積に関する問題は大学入試数学でも割と見るため、すぐに $2^i3^j5^k$ がキーになると気づけた
- なお確率が $0$ となる条件をしくじって`WA`を喰らった模様
  - 相変わらず詰めが甘い…

## ARC052 B - 円錐
- **問題文が分かりづれぇ！**
  - 「いずれか」ではなく「すべての」とかにすべきだと思う
  - ~~というかこいつが水色なのはこの問題文のせいなのでは…？~~
- 円錐の底面 $x$ 座標と高さが整数であるから、$V_x$ を各円錐の区間 $[x, x+1]$ の部分における体積の合計と置いて計算ができる
  - 計算量は $O(NH_i) = O(10^6)$ なので十分に余裕がある
- あとは各クエリについて $\sum_{x = A_i}^{B_i - 1} V_x$ を求めるだけ
  - 本当は累積和を使うべきだけど、そのまま愚直に計算しても9msで通った

## ABC196 D - Hanjo
- 探索順でしくって`WA`
- 下手にDP探索とかやるからこうなる
  - 単なるDFSで良かった件について
- まぁビット列での管理はすぐに思いついたのでそこはよしとしましょう…
- $HW \leq 16$ という超親切設計なので計算量では悩まなくてよし

## ABC014 C - AtColor
- ABCのC問題で（試験管とはいえ）水色だと！？
- しばらく考えて座標圧縮を試みるも1つのテストケースがギリギリ通らず`TLE`
  - 座標圧縮後に愚直にカウントしてしまったのが原因
- 区間 $[L_i, R_i]$ がたくさん与えられるとき、 整数 $x$ を含む区間の個数を高速に調べるには以下の方法を取ればよい
  - 配列 $A$ を全て0で初期化する
  - 全ての区間に対して $A_{L_i}$ に $1$ を加え、 $A_{R_i + 1}$ から $1$ を引く
  - $A$ の累積和 $S$ を作れば、 $S_x$ が $x$ を含む区間の個数になる。
- むしろ↑のアプローチをとれば座標圧縮はいらなかったっぽい
- 前にやったはずなんだけど忘れてますねぇ…

## 天下一プログラマーコンテスト2013予選B B - 天下一後入れ先出しデータ構造
- もちろん`stack`を使えばよいのだが $N$ や $L$ が大きくそのままでは`TLE`と予想できる
- データ入力の仕様からして同じ数字が何個も並ぶので、`pair`で数字と個数を管理
  - `Pop`がやや複雑になるのと、`Size`に答えるために別にサイズのデータを持つ必要があることに注意すればそれほど難しくはない

## ABC103 D - Islands War
- **区間スケジューリング問題**
- 要望を $b_i$ が小さい順にソートして考える
  - 順に要望を見ていき、満たされていない要望 $i$ に対して橋 $[b_i - 1, b_i]$ をなくしていく
    - 橋 $[b_i - 1, b_i]$ を選ぶのは、最も右の橋をなくすことで同じ $b_i$ の要望の全てに答えることができるから

## ABC183 E - Queen on Grid
- 愚直にDPしてしまい`TLE`
  - 水色がそんな単純なわけがない
- なので累積和を使うが、3方向からの移動を全て累積和にする必要がある
  - 壁について
    - 右方向の移動の場合、壁より右の全てのマスは、壁より左のあらゆるマスから遷移できない
    - すなわち $(x, y)$ が壁の場合、$(x + 1, y)$ の右方向からの累積和は $0$ になる
    - 勿論ほかの方向でも同様

## ABC021 C - 正直者の高橋くん
- グラフの最短経路を求めるアルゴリズムはいくつかあるが、今回はDijkstra法をちょちょいといじる
  - 最短経路のまとめは[最短経路問題の解法まとめ](https://qiita.com/taka256/items/a023a11efe17ab097433)がわかりやすい。感謝。
- 最短経路長を更新するついでに経路数を数える
  - 町 $a$ から町 $i (1 \leq i \leq N)$ への最短経路長を $D_i$、町 $a$ から町 $i$ への最短経路数を $C_i$ とすると
    - 町 $i$ と町 $j$ をつなぐ道路によって $D_j$ が更新される場合、$C_j \gets C_i$ とする（最短経路が完全に更新される）
    - 町 $i$ と町 $j$ をつなぐ道路が存在して $D_j = D_i + 1$ が成り立つ場合、$C_j \gets C_j + C_i$ とする（最短経路と同じ長さの経路が他にもある）

## ABC191 E- Come Back Quickly
- 多重辺について、同じ向きで所要時間のより大きい道は明らかに不要
- それぞれの町間の最小所要時間（行けない場合は`INF`）を求められればあとは $O(N^2)$ でいけそう
- 制限3秒ならWarshall-Floyd法で行けるかと思ったが見事に`TLE`
  - 隣接行列を使ったのもダメだったか
- **辺の数が少なければ全頂点についてDijkstra法でも充分早い**
  - Dijkstra法を使う場合は自己ループ辺は邪魔なので別に管理しておく
  - 各頂点に対してDijkstra法を用いて、各頂点間の最小距離 $d_{i, j}$ を全て求める
  - 各 $i$ に対して $d_{i,j} + d_{j ,i}$ の最小値を求め、あらかじめ除けておいた自己ループと比べて小さいほうを出力する

