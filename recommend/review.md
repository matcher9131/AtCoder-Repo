# AtCoder Problems Recommend Reivew
AtCoder Problems Recommendでおすすめされる問題をひたすら解いてひたすらレビューする

## ABC174 E. Logs
- 最小化問題すなわち二分探索法
  - 最小値を直接求めるのは難しいが、ある値にすることができるかどうかの判定が容易い場合の鉄板パターン
- めぐる式二分探索法でやってみた

## ABC251 E. Takahashi and Animals
- 行動 $1$ をするDPと行動 $1$ をしないDPに場合分けして考える
- DPそのものを場合分けして2回やる発想はなかった
  - 一応2次元DPまではわかっており、その点は◎
  - DPなんだろうなぁと思いつつ、行動 $1$ をするかどうかで行動 $N$ をするのかどうかが変わるしどうすればええねん…で止まってしまった

## ABC096 D. Five, Five Everywhere
- 素数判定問題
- 当然 ${}_{55}C_5 \simeq 3.5 \times 10^6$ パターンに対して合成数かどうかなんて判定してたら余裕で`TLE`なわけで
  - なのでどの5つを選んでも合成数になるようにしなければならない
    - 5つ足して合成数なら5の倍数を目指すのが最も楽

## ABC264 E. Blackout 2
- 1つずつグラフの辺を削除しながらクエリに答える系の問題
- 逆順にすればUnion-findで辺を追加しながらいけるんじゃね？とすぐにわかったのは◎
  - 発電所と繋ぐ場合は必ず親を発電所にすることで各都市が発電所につながっているか簡単に調べられることにも気づいた
- しかし辺を追加するたびにいちいち全都市に対して発電所が親かどうかを確認してしまい $O(NQ) = O(10^{11})$ で無事`TLE`
  - 正しくは、発電所につながっていないグループのサイズがそのまま新しく電気が通る都市の数になることを利用する。この場合 $O(N + Q)$ のはず…
- Union-findは割とカスタマイズできる（connectの親の選び方、戻り値）ことを覚えておく

## ABC164 D. Multiple of 2019
- ${}_{N}C_2$通りすべてを調べるともちろん`TLE`
- 2019の倍数かどうかを調べる問題なので、余りの遷移をみたい
  - 遷移を1つだけ保持するのではなく、余りごとに個数を記録すべし
- 当然ながら $i < j$ に対し $S_{[i, N]} \equiv S_{[j, N]}$ ならば $S_{[i, j - 1]} \equiv 0$ という数学的考察も大事（2019を法とする）

## AGC003 B. Simplified mahjong
- **麻雀と聞いて（ｶﾞﾀｯ**
  - 麻雀関連はいろいろコードを書いたことがあったので、考察が楽に捗った
- まさか単に下から貪欲に刻子→順子の順に取るだけだとは思わず、疑心暗鬼で提出したらあっさり`AC`で拍子抜け
  - やっぱり**今の水色は難しすぎる**って！

## ABC198 D. Send More Money
- $10! = 3.6 \times 10^6$ なので全パターン試してもよさそう
- というわけで`next_permutation()`でゴリゴリ回す
  - 文字列の置き換えも含めて $O(N^2 \times N!)$ …のはず（ただし $N = \max \{ |S_1|, |S_2|, |S_3| \}$）

## ABC062 C. Chocolate Bar
- まず、 $H$ か $W$ が3の倍数のときは~~アホになります~~3等分ができる
- そうでなくてもとりあえず縦2回 or 横2回で切れば $S_{\max} - S_{\min} = \min \{ H, W \}$ とできる
- あとは縦→横 or 横→縦の順番で切るパターンを考える
  - いずれの場合も2回目の切断はできる2つのピースの面積を最小にするべきなので、中央（奇数ならほぼ中央）で切る
  - 1回目の切る場所は全探索しても $O(H + W)$ なので問題なし

## ABC089 D. Practical Skill Test
- **計算量は毎回きちんと見積もること**
  - そりゃ全てのクエリで毎回探索してたら $O(HWQ)$ で`TLE`だわな…
- $D$ が共通であることにピンとくることができる体になりたい
  - そして差を求める系の問題には累積和が特効薬

## ABC256 E. Takahashi's Anguish
- 全てのノードにおいて出次数が1なので、1つの連結成分に対し必ずちょうど1個のサイクルが生じる
  - サイクルではない部分に関しては、入次数が0の人からグラフをたどるように渡していけば全員に不満が生じない
  - サイクル部分に関しては、グラフをたどるように渡していけば最後に渡される人にのみ不満が生じる
- よってサイクルごとに最小辺を見つけ、その不満度を合計すれば解になる
- 具体的にはUnion-find木を構築し、根ごとにDFSを回してサイクルを取得、その最小辺のコストを合計した
  - が、提出後にUnion-find木の構築中にサイクルを検出できることに気づく
    - しかも今回は全てのノードの出次数が1なので、サイクル復元も単にforループを1回回すだけで済む…
      - 要するにDFSが大げさすぎる
        - ま、まぁ`AC`したからよしとしましょう（震え声）

## ABC200 D. Happy Birthday! 2
- 以下 $A_i$ は $A_i \bmod 200$ に置き換える
- とりあえず思いついたのはDP
  - `dp[i][k]`: $A$ の先頭 $i$ 個からいくつか選んだ和の200で割った余りが $k$ になるパターンの総数
- DP復元は初挑戦だったが…
  - デバッグの嵐
    - わからなすぎて禁断のテストケース覗き見を敢行
      - $A_i = 0$ のとき、 $A_i$ を選んでも選ばなくても $k$ の遷移元が同じなので区別がつかず、 $B$ と $C$ で同じ選択をしてしまっていた
        - 復元のときに $A_i = 0$ について別個に処理することで対処
      - **普通にオーバーフロー**
        - DPの値は2以上ならば差はないので、既に2以上のときは（経路復元用のほうも含めて）更新しないようにした
- （公式解説）ここで鳩の巣原理はカッコよすぎる

## ABC308 F. Vouchers
- 間違った貪欲法をしてしまい行方不明に
  - なぜか $P_i \geq L_j$ となる最小の $j$ （ただし、同じ $L_j$ のクーポンが複数ある場合は $D_j$ が最も大きいもの）のクーポンを選んで使っていた
- もちろん正しくは $P_i \geq L_j$ となるクーポン $j$ のうち、最も $D_j$ が大きいものを選択する必要がある
  - ただし実装を間違うと余裕で`TLE`なのでさらなる考察が要る
    - $A_i$ と $L_j$ をそれぞれ昇順に並べた場合、$i$ が増えるとともに使えるクーポン $j$ が $0$ から順番に増えていく
      - 順番に増えるというのがポイントで、使えるクーポンを探索する必要がない（どこまで使えるのかを記録するだけでOK）
    - 一方で使うクーポンはその時点で最も $D$ が大きいものになる
    - ここでクーポンのデータを2重で持つと計算量を減らせる
      - まずはクーポン全体をソートされた配列で持つ
      - 次にその時点で使えるクーポンを管理する`priority_queue`を作る
        - これによりその時点で $D$ が最大になるクーポンが $O(1)$ で選べるばかりか、使ったクーポンを削除するのも $O(1)$ でいいことずくめ
- 「クーポン全体→使うクーポンを検索」が無理そうなら「クーポン全体→使えるクーポン一覧→使うクーポンを検索」というクッションを作る！


## ABC300 E. Dice Product 3
- $\bmod \ 998244353$ での割り算を計算する術がない！
  - もちろんAtCoder Libraryを使ってもよかったのだが、後学のために自作した
    - ガバいテストケースも作ってちゃんとテストを通したのでヨシ！~~（現場猫案件ではないことを祈る）~~
    - 忘れたころにやってくるフェルマーの小定理さん：「整数 $a$ 、素数 $p$ に対し $a^{p - 1} \equiv 1 \pmod p$」
- 計算は例によってDP
  - $dp_{i,j,k}$ を $x = 2^i3^j5^k$ になる確率（もちろん $\bmod \ 998244353$ ）と定義
    - このとき $dp_{i,j,k} = \frac{1}{6}dp_{i,j,k} + \frac{1}{6}dp_{i-1,j,k} + \frac{1}{6}dp_{i,j-1,k} + \frac{1}{6}dp_{i-2,j,k} + \frac{1}{6}dp_{i,j,k-1} + \frac{1}{6}dp_{i-1,j-1,k}$
      - ただし $i = 1,2$ or $j = 1$ or $k = 1$ のときは添え字が0以下になる項は $0$ として扱う
    - 変形して $dp_{i,j,k} = \frac{1}{5}dp_{i-1,j,k} + \frac{1}{5}dp_{i,j-1,k} + \frac{1}{5}dp_{i-2,j,k} + \frac{1}{5}dp_{i,j,k-1} + \frac{1}{5}dp_{i-1,j-1,k}$
    - 計算量は $O((\log N)^3)$ なので問題なし、DPの更新順も特に気を使う必要がなく楽に実装
- サイコロの積に関する問題は大学入試数学でも割と見るため、すぐに $2^i3^j5^k$ がキーになると気づけた
- なお確率が $0$ となる条件をしくって`WA`を喰らった模様
  - 相変わらず詰めが甘い…

## ARC052 B. 円錐
- **問題文が分かりづれぇ！**
  - 「いずれか」ではなく「すべての」とかにすべきだと思う
  - ~~というかこいつが水色なのはこの問題文のせいなのでは…？~~
- 円錐の底面 $x$ 座標と高さが整数であるから、$V_x$ を各円錐の区間 $[x, x+1]$ の部分における体積の合計と置いて計算ができる
  - 計算量は $O(NH_i) = O(10^6)$ なので十分に余裕がある
- あとは各クエリについて $\sum_{x = A_i}^{B_i - 1} V_x$ を求めるだけ
  - 本当は累積和を使うべきだけど、そのまま愚直に計算しても9msで通った
