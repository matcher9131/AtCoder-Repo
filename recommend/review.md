# AtCoder Problems Recommendation Reivew
AtCoder Problems Recommendationでおすすめされる問題をひたすら解いてひたすらレビューする

※ 添え字は特に記述のない限り1-indexedとする

## ABC174 E - Logs
- 最小化問題すなわち二分探索法
  - 最小値を直接求めるのは難しいが、ある値にすることができるかどうかの判定が容易い場合の鉄板パターン
- めぐる式二分探索法でやってみた

## ABC251 E - Takahashi and Animals
- 行動 $1$ をするDPと行動 $1$ をしないDPに場合分けして考える
- DPそのものを場合分けして2回やる発想はなかった
  - 一応2次元DPまではわかっており、その点は◎
  - DPなんだろうなぁと思いつつ、行動 $1$ をするかどうかで行動 $N$ をするのかどうかが変わるしどうすればええねん…で止まってしまった

## ABC096 D - Five, Five Everywhere
- 素数判定問題
- 当然 ${}_{55}C_5 \simeq 3.5 \times 10^6$ パターンに対して合成数かどうかなんて判定してたら余裕で`TLE`なわけで
  - なのでどの5つを選んでも合成数になるようにしなければならない
    - 5つ足して合成数なら5の倍数を目指すのが最も楽

## ABC264 E - Blackout 2
- 1つずつグラフの辺を削除しながらクエリに答える系の問題
- 逆順にすればUnion-findで辺を追加しながらいけるんじゃね？とすぐにわかったのは◎
  - 発電所と繋ぐ場合は必ず親を発電所にすることで各都市が発電所につながっているか簡単に調べられることにも気づいた
- しかし辺を追加するたびにいちいち全都市に対して発電所が親かどうかを確認してしまい $O(NQ) = O(10^{11})$ で無事`TLE`
  - 正しくは、発電所につながっていないグループのサイズがそのまま新しく電気が通る都市の数になることを利用する。この場合 $O(N + Q)$ のはず…
- Union-findは割とカスタマイズできる（connectの親の選び方、戻り値）ことを覚えておく

## ABC164 D - Multiple of 2019
- ${}_{N}C_2$通りすべてを調べるともちろん`TLE`
- 2019の倍数かどうかを調べる問題なので、余りの遷移をみたい
  - 遷移を1つだけ保持するのではなく、余りごとに個数を記録すべし
- 当然ながら $i < j$ に対し $S_{[i, N]} \equiv S_{[j, N]}$ ならば $S_{[i, j - 1]} \equiv 0 \pmod{2019}$ という数学的考察も大事

## AGC003 B - Simplified mahjong
- **麻雀と聞いて（ｶﾞﾀｯ**
  - 麻雀関連はいろいろコードを書いたことがあったので、考察が楽に捗った
- それでもまさか単に下から貪欲に刻子→順子の順に取るだけだとは思わず、疑心暗鬼で提出したらあっさり`AC`で拍子抜け
  - やっぱり**今の水色は難しすぎる**って！

## ABC198 D - Send More Money
- $10! = 3.6 \times 10^6$ なので全パターン試してもよさそう
- というわけで`next_permutation()`でゴリゴリ回す
  - 文字列の置き換えも含めて $O(N^2 \times N!)$ …のはず（ただし $N = \max \{ |S_1|, |S_2|, |S_3| \}$）

## ABC062 C - Chocolate Bar
- まず、 $H$ か $W$ が3の倍数のときは~~アホになります~~3等分ができる
- そうでなくてもとりあえず縦2回 or 横2回で切れば $S_{\max} - S_{\min} = \min \{ H, W \}$ とできる
- あとは縦→横 or 横→縦の順番で切るパターンを考える
  - いずれの場合も2回目の切断はできる2つのピースの面積を最小にするべきなので、中央（奇数ならほぼ中央）で切る
  - 1回目の切る場所は全探索しても $O(H + W)$ なので問題なし

## ABC089 D - Practical Skill Test
- **計算量は毎回きちんと見積もること**
  - そりゃ全てのクエリで毎回探索してたら $O(HWQ)$ で`TLE`だわな…
- $D$ が共通であることにピンとくることができる体になりたい
  - そして差を求める系の問題には累積和が特効薬

## ABC256 E - Takahashi's Anguish
- 全てのノードにおいて出次数が1なので、1つの連結成分に対し必ずちょうど1個のサイクルが生じる
  - サイクルではない部分に関しては、入次数が0の人からグラフをたどるように渡していけば全員に不満が生じない
  - サイクル部分に関しては、グラフをたどるように渡していけば最後に渡される人にのみ不満が生じる
- よってサイクルごとに最小辺を見つけ、その不満度を合計すれば解になる
- 具体的にはUnion-find木を構築し、根ごとにDFSを回してサイクルを取得、その最小辺のコストを合計した
  - が、提出後にUnion-find木の構築中にサイクルを検出できることに気づく
    - しかも今回は全てのノードの出次数が1なので、サイクル復元も単にforループを1回回すだけで済む…
      - 要するにDFSが大げさすぎる
        - ま、まぁ`AC`したからよしとしましょう（震え声）

## ABC200 D - Happy Birthday! 2
- 以下 $A_i$ は $A_i \bmod 200$ に置き換える
- とりあえず思いついたのはDP
  - `dp[i][k]`: $A$ の先頭 $i$ 個からいくつか選んだ和の200で割った余りが $k$ になるパターンの総数
- DP復元は初挑戦だったが…
  - デバッグの嵐
    - わからなすぎて禁断のテストケース覗き見を敢行
      - $A_i = 0$ のとき、 $A_i$ を選んでも選ばなくても $k$ の遷移元が同じなので区別がつかず、 $B$ と $C$ で同じ選択をしてしまっていた
        - 復元のときに $A_i = 0$ について別個に処理することで対処
      - **普通にオーバーフロー**
        - DPの値は2以上ならば差はないので、既に2以上のときは（経路復元用のほうも含めて）更新しないようにした
- （公式解説）ここで鳩の巣原理はカッコよすぎる

## ABC308 F - Vouchers
- 間違った貪欲法をしてしまい行方不明に
  - なぜか $P_i \geq L_j$ となる最小の $j$ （ただし、同じ $L_j$ のクーポンが複数ある場合は $D_j$ が最も大きいもの）のクーポンを選んで使っていた
- もちろん正しくは $P_i \geq L_j$ となるクーポン $j$ のうち、最も $D_j$ が大きいものを選択する必要がある
  - ただし実装を間違うと余裕で`TLE`なのでさらなる考察が要る
    - $A_i$ と $L_j$ をそれぞれ昇順に並べた場合、$i$ が増えるとともに使えるクーポン $j$ が $0$ から順番に増えていく
      - 順番に増えるというのがポイントで、使えるクーポンを探索する必要がない（どこまで使えるのかを記録するだけでOK）
    - 一方で使うクーポンはその時点で最も $D$ が大きいものになる
    - ここでクーポンのデータを2重で持つと計算量を減らせる
      - まずはクーポン全体をソートされた配列で持つ
      - 次にその時点で使えるクーポンを管理する`priority_queue`を作る
        - これによりその時点で $D$ が最大になるクーポンが $O(1)$ で選べるばかりか、使ったクーポンを削除するのも $O(1)$ でいいことずくめ
- 「全体から検索」が計算量的にきつそうなら「全体→今候補になるもの→検索」というクッションを作る！

## ABC300 E - Dice Product 3
- $\bmod \ 998244353$ での割り算を計算する術がない！
  - もちろんAtCoder Libraryを使ってもよかったのだが、後学のために自作した
    - ガバいテストケースも作ってちゃんとテストを通したのでヨシ！~~（現場猫案件ではないことを祈る）~~
    - 忘れたころにやってくるフェルマーの小定理さん：「整数 $a$ 、素数 $p$ に対し $a^{p - 1} \equiv 1 \pmod p$」
- 計算は例によってDP
  - $dp_{i,j,k}$ を $x = 2^i3^j5^k$ になる確率と定義
    - このとき $dp_{i,j,k} = \frac{1}{6}dp_{i,j,k} + \frac{1}{6}dp_{i-1,j,k} + \frac{1}{6}dp_{i,j-1,k} + \frac{1}{6}dp_{i-2,j,k} + \frac{1}{6}dp_{i,j,k-1} + \frac{1}{6}dp_{i-1,j-1,k}$
      - ただし $i = 1,2$ or $j = 1$ or $k = 1$ のときは添え字が0以下になる項は $0$ として扱う
    - 変形して $dp_{i,j,k} = \frac{1}{5}dp_{i-1,j,k} + \frac{1}{5}dp_{i,j-1,k} + \frac{1}{5}dp_{i-2,j,k} + \frac{1}{5}dp_{i,j,k-1} + \frac{1}{5}dp_{i-1,j-1,k}$
    - 計算量は $O((\log N)^3)$ なので問題なし
    - DPの更新順も特に気を使う必要がなく楽に実装
- サイコロの積に関する問題は大学入試数学でも割と見るため、すぐに $2^i3^j5^k$ がキーになると気づけた
- なお確率が $0$ となる条件をしくじって`WA`を喰らった模様
  - 相変わらず詰めが甘い…

## ARC052 B - 円錐
- **問題文が分かりづれぇ！**
  - 「いずれか」ではなく「すべての」とかにすべきだと思う
  - ~~というかこいつが水色なのはこの問題文のせいなのでは…？~~
- 円錐の底面 $x$ 座標と高さが整数であるから、$V_x$ を各円錐の区間 $[x, x+1]$ の部分における体積の合計と置いて計算ができる
  - 計算量は $O(NH_i) = O(10^6)$ なので十分に余裕がある
- あとは各クエリについて $\sum_{x = A_i}^{B_i - 1} V_x$ を求めるだけ
  - 本当は累積和を使うべきだけど、そのまま愚直に計算しても9msで通った

## ABC196 D - Hanjo
- 探索順でしくって`WA`
- 下手にDP探索とかやるからこうなる
  - 単なるDFSで良かった件について
- まぁビット列での管理はすぐに思いついたのでそこはよしとしましょう…
- $HW \leq 16$ という超親切設計なので計算量では悩まなくてよし

## ABC014 C - AtColor
- ABCのC問題で（試験管とはいえ）水色だと！？
- しばらく考えて座標圧縮を試みるも1つのテストケースがギリギリ通らず`TLE`
  - 座標圧縮後に愚直にカウントしてしまったのが原因
- 区間 $[L_i, R_i]$ がたくさん与えられるとき、 整数 $x$ を含む区間の個数を高速に調べるには以下の方法を取ればよい
  - 配列 $A$ を全て0で初期化する
  - 全ての区間に対して $A_{L_i}$ に $1$ を加え、 $A_{R_i + 1}$ から $1$ を引く
  - $A$ の累積和 $S$ を作れば、 $S_x$ が $x$ を含む区間の個数になる。
- むしろ↑のアプローチをとれば座標圧縮はいらなかったっぽい
- 前にやったはずなんだけど忘れてますねぇ…

## 天下一プログラマーコンテスト2013予選B B - 天下一後入れ先出しデータ構造
- もちろん`stack`を使えばよいのだが $N$ や $L$ が大きくそのままでは`TLE`と予想できる
- データ入力の仕様からして同じ数字が何個も並ぶので、`pair`で数字と個数を管理
  - `Pop`がやや複雑になるのと、`Size`に答えるために別にサイズのデータを持つ必要があることに注意すればそれほど難しくはない

## ABC103 D - Islands War
- **区間スケジューリング問題**
- 要望を $b_i$ が小さい順にソートして考える
  - 順に要望を見ていき、満たされていない要望 $i$ に対して橋 $[b_i - 1, b_i]$ をなくしていく
    - 橋 $[b_i - 1, b_i]$ を選ぶのは、最も右の橋をなくすことで同じ $b_i$ の要望の全てに答えることができるから

## ABC183 E - Queen on Grid
- 愚直にDPしてしまい`TLE`
  - 水色がそんな単純なわけがない
- なので累積和を使うが、3方向からの移動を全て累積和にする必要がある
  - 壁について
    - 右方向の移動の場合、壁より右の全てのマスは、壁より左のあらゆるマスから遷移できない
    - すなわち $(x, y)$ が壁の場合、$(x + 1, y)$ の右方向からの累積和は $0$ になる
    - 勿論ほかの方向でも同様

## ABC021 C - 正直者の高橋くん
- グラフの最短経路を求めるアルゴリズムはいくつかあるが、今回はDijkstra法をちょちょいといじる
  - 最短経路のまとめは[最短経路問題の解法まとめ](https://qiita.com/taka256/items/a023a11efe17ab097433)がわかりやすい。感謝。
- 最短経路長を更新するついでに経路数を数える
  - 町 $a$ から町 $i (1 \leq i \leq N)$ への最短経路長を $D_i$、町 $a$ から町 $i$ への最短経路数を $C_i$ とすると
    - 町 $i$ と町 $j$ をつなぐ道路によって $D_j$ が更新される場合、$C_j \gets C_i$ とする（最短経路が完全に更新される）
    - 町 $i$ と町 $j$ をつなぐ道路が存在して $D_j = D_i + 1$ が成り立つ場合、$C_j \gets C_j + C_i$ とする（最短経路と同じ長さの経路が他にもある）

## ABC191 E- Come Back Quickly
- 多重辺について、同じ向きで所要時間のより大きい道は明らかに不要
- それぞれの町間の最小所要時間（行けない場合は`INF`）を求められればあとは $O(N^2)$ でいけそう
- 制限3秒ならWarshall-Floyd法で行けるかと思ったが見事に`TLE`
  - 隣接行列を使ったのもダメだったか
- **辺の数が少なければ全頂点についてDijkstra法でも充分早い**
  - Dijkstra法を使う場合は自己ループ辺は邪魔なので別に管理しておく
  - 各頂点に対してDijkstra法を用いて、各頂点間の最小距離 $d_{i, j}$ を全て求める
  - 各 $i$ に対して $d_{i,j} + d_{j ,i}$ の最小値を求め、あらかじめ除けておいた自己ループと比べて小さいほうを出力する

## ABC307 C - Ideal Sheet
- シートのサイズが最大で10なので全探索（$O(H_AW_AH_BW_BH_XW_X)$）で十分間に合う
- シートA, BのそれぞれがシートXと共通部分を持つように左上座標をずらしながらシートXを作れるかどうかを判定する
  - このときシートA, Bの黒マスがシートXからはみ出ていないかの判定をいちいちするのが面倒くさいので、あらかじめシートA, Bの黒マスの左端、右端、上端、下端を求めておいて、はみ出るような箇所はそもそも探索しないようにする
    - 具体的にはシートXの左上座標を原点とし、シートAの黒マスの左端、右端、上端、下端をそれぞれ $A_L, A_R, A_U, A_D$とするとき、シートAの左上の座標 $(i, j)$ に関して $-A_L \leq i \lt W_X - A_R, -A_U \leq j \lt H_X - A_D$ とすれば、シートAの黒マスはシートXからはみ出さない（シートBも同様にする）

## Donutsプロコンチャレンジ2015 B - Tokyo 7th シスターズ
- $N \leq 16$ なのでユニットはビット列で表せるし、$2^{16} = 65536$ なので全探索も余裕
  - ユニットの人数がちょうど9人という点については、整数 $i$ を2進数表記したときの`1`の個数を $c_i$ とするとき、$c_i = 9$ となる $i$ に対してのみ能力値を計算すれば問題ない
- コンボボーナスの組み合わせもビット列で表せば余計な探索は不要になる
  - ユニットを表す整数 $i$ とコンボボーナスの組み合わせを表す整数 $j$ に対し、$c_{i \land j} \geq 3$ ならばコンボボーナスが得られる
  - 示された組み合わせのうち3人いれば大丈夫という点を見落としてグダりかけたのは内緒

## CODE FESTIVAL 2014 Easy C - 身体バランス
- どうみてもDijkstra法ですありがとうございました
- 計算量は $O((N + M)\log N)$？

## ABC248 E - K-colinear Line
- まず、解が`Infinity`になる必要十分条件は $K = 1$
- よって以降 $K \geq 2$ とする
- $N(N - 1)/2$ 本の直線に対して $K$ 個以上の点を通るものをカウントする方針を検討するも
  - 直線のダブりを排除する方法が割と面倒くさいことに気づく
    - 傾きと切片の2パラメータでやろうとすると小数になるので誤差が怖い
    - $ax + by + c = 0$ の形にすれば3パラメータになるが整数で管理できる。この方針はありかもしれなかったが採用はしなかった
- 代わりに各点ごとにその点を通る直線を引いてカウントすることにする
  - 点 $i (1 \leq i \leq N)$ に対し、点 $i$ から点 $j (j \neq i)$ に向かうベクトル $V_{ij}$ を考える
  - ベクトルを以下のように正規化する
      1. ベクトルの各成分を、全成分の最大公約数で割る
          - ただし任意の整数 $n$ に対し $\gcd (n, 0) = n$ とする
      1. $x$ 成分が負の場合は各成分の符号を反転する
  - ↑の正規化により、もともと平行なベクトルは完全に一致するようになる
  - $n - 1$個の正規化されたベクトル $V_{ij}$ の中でちょうど $k - 1$ 個が一致するとき、1本の直線上に $k$ 個の点があることになる
  - これを全ての $i$ に対して行うが、$k$ 個の点が同一直線上にあるとき、$k$ 回重複してカウントしていることになる
    - よって各 $k \geq K$ に対して別個にカウントし、それぞれを $k$ で割ることにより重複を取り除ける
- 正規化されたベクトルのうち何個が一致するのか数えるのにソートを使っているので、計算量は $O(N^2\log N)$

## ABC268 D - Unique Username
- $S_i$ の並び替えに関しては`next_permutation()`に丸投げするとして、問題は`_`の数
- $\sum_{i = 1}^N |S_i| = L$ とおくと、余分に追加できる`_`は最大で $16 - L - (N - 1)$ 個である。以下これを $E$ として、
  - 各項が $0$ 以上で合計が $E$ 以下になる $n-1$ 項の数列 $A$ が用意できれば、$A_i$ が $S'_i$ と $S'_{i + 1}$の間に余分に挿入される`_`の個数とすることができる
    - で、これをどうやって作るのか
- こういうときは再帰関数の出番
  - 以下の3つを持つ再帰関数で、
    - $k$
    - $k$ 番目までの $S'_i$ を適当な個数の`_`で繋いだ文字列
    - その時点で余分に挿入できる`_`の個数 $E_k$
  - 次に $S'_{k + 1}$ を繋げるときに余分な`_`の個数を $0$ 以上 $E_k$ 以下で全て探索するようにすればOK
- $T_i$ は`set`に放り込んで`find()`の計算量を $O(\log M)$ にしておく
- $|X| \geq 3$ のような小さい条件を見失わないように注意（1敗）
- 計算量は $O(N! {}_{16-N}C_{N-1} \log M)$

## ARC048 B - AtCoderでじゃんけんを
- レーティングが自分より低い人/高い人の人数は`lower_bound()`と`upper_bound()`に任せればOK
- レーティングが自分と同じ人に関して
  - $O(N^2)$ だと`TLE`の可能性が高いので毎回探索するわけにはいかない
    - よってレーティングをkey、グー・チョキ・パーを出した人がそれぞれ何人いるかをvalueとする`unordered_map`をあらかじめ作っておき、レーティングが同じ人に対する勝敗を $O(1)$ で判断できるようにする
- 計算量は $O(N \log N)$

## ABC242 D - ABC Transform
- $Q \leq 10^5$ より、1回のクエリは多くても対数時間に抑えないと`TLE`になる
  - まぁそもそも長さ $10^{18}$ の文字列なんざまともに相手できないわけで
- 与えられた文字列について、`A, B, C`をそれぞれ`0, 1, 2`に置き換えて考える
- すると $S^{(t)}_{k} = x$ のとき、$S^{(t + 1)}_{2k - 1} \equiv x + 1 \pmod 3, S^{(t + 1)}_{2k} \equiv x + 2 \pmod 3$ となる
- よって $S^{(t)}_{k}$ は $S^{(t - 1)}_{\lceil k / 2 \rceil}$ を見ればわかる
- これを繰り返すことで $S^{(0)}_{k'}$ か $S^{(t')}_1$ までたどり着けば $O(1)$ で文字が何かわかるため、高々64回の計算でクエリに答えることができる
  - 具体的には $k - 1$ の2進数表記における`1`の数を $c$、$p = \lfloor (k - 1) / 2^t \rfloor + 1$ とするとき、$S^{(t)}_k \equiv S^{(0)}_p + t + c \pmod 3$ となる
- 計算量は $k_i$ の最大値を $K$ として $O(Q \log K)$

## ABC184 D - increment of coins
- どうみてもDPですありがとうございました
- $dp_{i,j,k}$ をいずれかの硬貨が100枚になるまでに必要な操作回数の期待値とおくと、降順で求められる
  - 「条件を満たすまで必要な期待値を降順で求める」というのはABC314Eで得たばかりの知識
  - 2匹目のドジョウはいたらしい
- 具体的には以下の通り
  - $dp_{i,j,k} = x_{i,j,k}(1 + dp_{i + 1, j, k}) + y_{i,j,k}(1 + dp_{i, j + 1, k}) + z_{i,j,k}(1 + dp_{i, j, k + 1})$
    - ただし、$x_{i,j,k}, y_{i,j,k}, z_{i,j,k}$ は金貨 $i$ 枚、銀貨 $j$ 枚、銅貨 $k$ 枚の状態でそれぞれ金貨、銀貨、銅貨を取り出す確率
  - この遷移式を導出するのにナチュラルに手間取った
    - 確率の遷移には慣れているが、期待値の遷移にまだまだ慣れていない
- 誤差について
  - 絶対誤差あるいは相対誤差が $10^{-6}$ まで許されるので、浮動小数点の丸め誤差は気にしなくてよい
  - 減算はないので桁落ちは生じない
  - 加算による情報落ちの可能性を考える
    - $x_{i,j,k}$ の最小値は $x_{1,99,99} = 1/199 \approx 0.05$
      - もちろん $y_{i,j,k}, z_{i,j,k}$ も同様
    - 操作回数は最低でも1回は必要であり、最大でも295回（$A=B=C=1$ のとき）であるから、$1 \leq dp_{i,j,k} \leq 295$
    - よって加算の各オペランドは最大でも4桁差なので情報落ちは生じない

## ABC073 D - joisino's travel
- $R \leq 8$ であり、$8! = 40320$ なので訪れる順に関しては`next_permutation()`による全探索でいけそう
- Warshall-Floyd法で全頂点間の距離を求めておけば楽
  - $\Theta (N^3)$ だが $N \leq 200$ なので余裕で間に合う
- 計算量は $O(\max \{ R!, N^3 \})$

## ABC151 E - Max-Min Sums
- $f$ の線形性より、$A_i$ が $\max S$ および $\min S$ として選ばれる回数が分かれば解が求まる
- $i \geq K$ のとき $\max S = A_i$ となるような $S$ の選び方は ${}_{i-1}C_{K-1}$ 通り
- $i \leq n - K + 1$ のとき $\min S = A_i$ となるような $S$ の選び方は ${}_{N-i}C_{K-1}$ 通り
  - これは $i \geq k$ のとき $\min S = A_{n + 1 - i}$ となるような $S$ の選び方は ${}_{i-1}C_{K-1}$ 通りと言い換えられる
- よって $\sum_{i = K}^{N} {}_{i-1}C_{K-1}(A_i - A_{N + 1 - i})$ を求めればよい
- 問題となるのは ${}_{i-1}C_{K-1}$ だが、$i = K$ のとき ${}_{i-1}C_{K-1} = {}_{K-1}C_{K-1} = 1$ であり、$i > K$ において ${}_{i-1}C_{K-1} = {}_{i-2}C_{K-1} \cdot (i-1)/(i-K)$ であるから、ループ中で更新することにより $O(1)$ で計算できる
- 数学的考察はきちんとできたが、時間がかかりすぎ…
  - 植木算的要素をすぐに処理できる人間になりたい

## ABC119 D - Lazy Faith
- 地点 $x_i$ より東にある神社に関して、地点 $x_i$ に最も近い神社以外を訪れるのは明らかに損
  - 西方向も同様であり、もちろん寺についても同様である
- よって以下の4つが分かれば解がわかる
  - 地点 $x_i$ より東にある最も近い神社までの距離 $R_1$
  - 地点 $x_i$ より東にある最も近い寺までの距離 $R_2$
  - 地点 $x_i$ より西にある最も近い神社までの距離 $L_1$
  - 地点 $x_i$ より西にある最も近い寺までの距離 $L_2$
- 考えられる距離は以下の4つで、これらの最小値が解になる
  - 東にある神社と東にある寺を訪れる場合、$\max\{R_1, R_2\}$
  - 東にある神社と西にある寺を訪れる場合、$R_1 + L_2 + \min\{R_1, L_2\}$（第3項は折り返すために必要）
  - 西にある神社と西にある寺を訪れる場合、$\max\{L_1, L_2\}$
  - 西にある神社と東にある寺を訪れる場合、$L_1 + R_2 + \min\{L_1, R_2\}$（第3項は折り返すために必要）
- それぞれのクエリについて、地点 $x_i$ より東に神社or寺が存在すれば $R_1, R_2$ は`lower_bound()`ですぐに求まり、$L_1, L_2$ に関してもイテレータを1つ戻すことで地点 $x_i$ より西に神社or寺が存在すれば $L_1, L_2$ もすぐに求まる
  - 「存在すれば」の部分が面倒くさいので、ここでは番兵法を用いる
    - すなわち、道路の東端より東（$x \gt 10^{10}$）および西端より西（$x < 0$）に神社と寺が存在するようにすれば場合分けが不要になる
      - ただし解に影響を及ぼさないように距離は十分に（$\gt 10^{10}$）空ける
- 計算量は $O(Q \log \max \{A, B\})$
- 4通りの場合分けも番兵法もすぐに思いついてサクサク解けた
  - いつもこのくらいのスピードだといいんだけどねぇ…

## ABC046 C - AtCoDeerくんと選挙速報
- $i$ 回目における2人の実際の得票数は整数 $k_i$ を用いて $k_iT_i, k_iA_i$ と表せる
- 得票数が減らないことから、$k_{i+1}T_{i+1} \geq k_iT_i, \ k_{i+1}A_{i+1} \geq k_iA_i$ が成り立つ
  - これを変形して、$k_{i+1} \geq k_iT_i / T_{i+1}, \ k_{i+1} \geq k_iA_i / A_{i+1}$
    - よって $k_{i+1}$ が整数であることから $k_{i+1} \geq \max \{ \lceil k_iT_i / T_{i+1} \rceil, \lceil k_iA_i / A_{i+1} \rceil \}$ となる
      - 求めるものが最小であることから $k_{i+1} = \max \{ \lceil k_iT_i / T_{i+1} \rceil, \lceil k_iA_i / A_{i+1} \rceil \}$ と確定できる。あとはこれをループで求めるだけ
- 計算量は $O(N)$

## ABC126 E - 1 or 2
- やたらとややこしいが、要するに $A_{X_i}$ がわかれば $A_{Y_i}$ もわかる構造（逆も然り）
- よって2頂点 $X_i, Y_i$ 間に辺を張り、連結成分の個数を答えればOK
- 計算量は $O(N+M)$
- この問題緑色の間違いじゃないのか…？

## エイシング プログラミング コンテスト 2020 D - Anything Goes to Zero
- $\mathrm{popcount}(n) \leq \lfloor \log_2{n} \rfloor + 1$ であるから、$f$ を適用する毎に $n$ は小さくなり、かつだいたい $\log_2{n}$ 回の操作で $0$ になりそう
- $f(X_i) \leq N$ なので1回の操作で $n \leq N$ となるから、あらかじめ $i (1 \leq i \leq N)$ に対して $f(i)$ を計算したテーブルを用意しておけばあとはこのテーブルを引きまくればOK
- よってあとは初回の $f(X_i)$ に注力するのみ
- 各 $X_i$ に対して毎回 $f(X_i)$ を一から計算していては $O(N^2)$ で`TLE`なので工夫が必要
  - まず、$\mathrm{popcount}(X_i)$ は $\mathrm{popcount}(X)+1, \mathrm{popcount}(X)-1$ のいずれかである
    - 以下これを順に $p_1, p_2$ とする
  - $X_i = X \oplus 2^{N-i}$ すなわち $X_i = X + 2^{N-i}$ または $X_i = X - 2^{N-i}$ であるから、あらかじめ $i (1 \leq i \leq N)$ に対して $2^i \bmod p_1, \ 2^i \bmod p_2$ および $X \bmod p_1, \ X \bmod p_2$ を計算しておけば $O(1)$ で $f(X_i)$ を求められる
- 以上により $O(N \log N)$ で全ての解が求まる。…のだが
- コーナーケースの処理に手間取る
  - まず $\mathrm{popcount}(X) = 0$ すなわち $X = 0$ のとき
    - 必ず $\mathrm{popcount}(X_i) = 1$ となるので全ての $i$ に対して解は $1$
  - 次に $\mathrm{popcount}(X) = 1$ のとき
    - $X$ の上から $i$ 桁目のビットが $1$ のときはそもそも $X_i = 0$ となるので解は $0$
    - $p_1$ のほうは普通に使えるのに対し、$p_2 = 0$ より $2^i \bmod p_2$ などは0除算エラーになるため場合分けで除ける
      - ここを力技で分けたがもっとスムーズな書き方はなかったものか…
- 途中に提出した解答が見事に`AC`と`TLE`と`RE`と`WA`が混ざっていて噴いた
  - これを一発で`AC`する人の思考回路を是非言語化していただきたいものである

## [ABC281 E - Least Elements](https://atcoder.jp/contests/abc281/tasks/abc281_e)
- `multiset`で管理して、$A_i$ 番目を削除して $A_{M + i - 1}$ 番目を挿入すればいいことはわかったが
  - 対象となる $K$ 個のほうだけを`multiset`に突っ込んでいたのでそこの判断をどうすればいいのかわからなかった
    - （公式解説を見る）対象にならない $M-K$ 個も`multiset`で管理すればよかったのか…
- STLの計算量を整理したい…

## [ABC190 F - Shift and Inversions](https://atcoder.jp/contests/abc190/tasks/abc190_f)
- 2重ループでゴリ押しで転倒数を求めるのは $O(N^2)$ で勿論`TLE`
- 何か良いアルゴリズムがないか検索したところ、Binary Indexed Treeを使えば $O(N \log N)$ にできるようだ
  - 以下のページを参考にした。感謝。
    - [Binary Indexed Tree (BIT) 総まとめ！区間加算や二次元BITまで](https://algo-logic.info/binary-indexed-tree/)
    - [転倒数    [いかたこのたこつぼ]](https://ikatakos.com/pot/programming_algorithm/dynamic_programming/inversion)
- 添え字には気を付けよう（1敗）
- $k = k_1$ のときの数列 $B_{k_1}$ と $k = k_1 + 1$ のときの数列 $B_{k_1 + 1}$ を比べると
  - $B_{k_1 + 1}$ は $B_{k_1}$ の初項 $a_{k_1}$ を末項に移したものになる
    - $a_{k_1}$ が初項でなくなることで減少する転倒数は $a_{k_1}$
    - $a_{k_1}$ が末項に来ることで増加する転倒数は $N - 1 - a_{k_1}$
  - すなわち、$B_{k_1 + 1}$ の転倒数は $B_{k_1}$ の転倒数に $N - 1 - 2a_{k_1}$ を加えたものとなる
  - よって $k \geq 1$ における $B$ の転倒数はそれぞれ $O(1)$ で求まる
    - ここの考察は自力ですぐに思いついたので、あとはBITの扱いに慣れなければ…

## [ABC106 D - AtCoder Express 2](https://atcoder.jp/contests/abc106/tasks/abc106_d)
- 1次元累積和、余事象などいろいろ考えた挙句…
  - 2次元累積和なら上手くいくのではないかと考える
- $a_{i,j}$ をちょうど区間 $[i, j]$ を走る列車の数とし、$2 \leq i \leq N+1$ および $2 \leq j \leq N+1$ に対し $S_{i,j}$ を 範囲 $[1, i) \times [1, j)$ における $a_{i,j}$ の総和とすると
  - 範囲 $[l, r] \times [l, r]$ における $a_{i,j}$ の総和は $S_{r+1, r+1} - S_{l, r+1} - S_{r+1, l} + S_{l, l}$ と表せる
- よって各クエリの解は $S_{q_i + 1, q_i + 1} - S_{p_i, q_i + 1} - S_{q_i + 1, p_i} + S_{p_i, p_i}$ となる
- 計算量は $O(\max \{ N^2, Q \})$
- 2次元累積和のメモ：
  - 前処理：$S_{i+1,j+1} = a_{i,j} + S_{i+1,j} + S_{i,j+1} - S{i,j}$
  - $[l, r) \times [t, b)$ の和は $S_{r,b} - S_{l,b} - S_{r,t} + S_{l,t}$

## [ABC267 E - Erasing Vertices 2](https://atcoder.jp/contests/abc267/tasks/abc267_e)
- コストが小さいほうから操作するのがよさそうと思いつつも、正直わからなかったので解説をチラ見
  - こういうときこそ`priority_queue`の出番！
- ただしコストが途中で更新されるのでそこをどうするのか
  - 「更新」をやめて新たなコストを設定してキューに突っ込むようにする
    - その代わりに、古いほうで操作をしないように操作済かどうかをわかるようにする
      - 操作をする頂点に対し $A_i = 0$ とすることで判別するようにした

## [ABC273 E - Notebook](https://atcoder.jp/contests/abc273/tasks/abc273_e)
- ノートの各ページにいちいち配列の内容を書き込んでいては間に合わないが
  - `LOAD`によって $A$ の内容が大幅に書き換わる可能性があるので、単純に配列で $A$ を保持しても解けない
  - すなわち $A$ の最新の内容と過去の内容を同時に保持する必要がある
- 問題の仕様から $A$ の途中のみが書き換わることはないので、$A_i$ と $A_{i+1}$ を辺で結ぶグラフを作ると木になる
  - この木 $G$ と今どの頂点に注目しているかを管理する変数 $c$ があれば問題を解くことができる
  - 具体的には以下
    - $G$ の初期状態を唯一の頂点 $V_0 = -1$ を持つグラフとし、$c = 0$ とする
    - 配列 $B$ を用意し、全ての項を $0$ とする
    - 順番にクエリを処理する
      - クエリが`ADD x`の場合
        - $G$ に新たな頂点 $V_i = x$ を追加し、$V_c$ と $V_i$ を新たな辺で繋ぐ
        - $c \gets i$ とする
        - $x$ を出力する
      - クエリが`DELETE`の場合
        - 頂点 $V_c$ の親 $V_p$ を用いて $c \gets p$ とする
        - $V_p$ を出力する
      - クエリが`SAVE y`の場合
        - $B_y \gets c$ とする
        - $V_c$ を出力する
      - クエリが`LOAD z`の場合
        - $c \gets B_z$ とする
        - $V_c$ を出力する
  - ただし、実際の実装に関しては $B$ を配列にすると`MLE`になるので、代わりに`unordered_map`を使っている

## [ABC114 D - 756](https://atcoder.jp/contests/abc114/tasks/abc114_d)
- 自然数 $n$ の正の約数の個数は、相異なる素数 $p_1, p_2, \dots p_m$ と正整数列 $\{ a_m \}$を用いて $\displaystyle n = \prod_{i = 1}^m p_i^{a_i}$ と表せるとき、$\displaystyle \prod_{i = 1}^m (a_i + 1)$ 個と求められる
  - 要するに $n$ の素因数分解ができれば良い
  - このあたりは大学入試数学で必須の知識なので助かった
- $N!$ の素因数分解の結果は $N$ 以下の全ての自然数の素因数分解の積であることから、$2$ から $N$ までを順に素因数分解すればよい
  - 普段は迂闊にやると計算量で死ぬ素因数分解だが、今回は $N \leq 100$ なので余裕
- $\displaystyle N! = \prod_{i = 1}^m p_i^{a_i}$ と表すと、$N!$ のあらゆる正の約数は全ての $i$ に対し $b_i \leq a_i$ となる非負整数列を用いて $\displaystyle \prod_{i = 1}^m p_i^{b_i}$ と表せる
  - あとは $\displaystyle \prod_{i = 1}^m (b_i + 1) = 75$ となるものを探せばよい
    - $p_i$ が相異なる素数であることから非負整数列 $\{ b_m \}$ が完全に一致しなければ必ず別の数になることが保証される
  - 具体的には $75 = 25 \cdot 3, 15 \cdot 5, 5 \cdot 5 \cdot 3$ より以下
    - 非負整数列 $\{ b_m \}$ に $74$ がちょうど1個含まれ、他は全て $0$
    - 非負整数列 $\{ b_m \}$ に $24$ と $2$ がちょうど1個ずつ含まれ、他は全て $0$
    - 非負整数列 $\{ b_m \}$ に $14$ と $4$ がちょうど1個ずつ含まれ、他は全て $0$
    - 非負整数列 $\{ b_m \}$ に $4$ がちょうど2個、および $2$ がちょうど1個含まれ、他は全て $0$
  - 愚直に多重ループで数えられるので、計算量は $N$ 以下の素数の個数を $M$ として $O(\max \{ N \log N, M^3 \})$

## [ABC154 E - Almost Everywhere Zero](https://atcoder.jp/contests/abc154/tasks/abc154_e)
- 愚直に組み合わせで数えようとするも、上から数桁が $N$ と一致するパターンがややこしくて詰む
- DPも考えたが3要素目（$N$ 以下であることが確定しているかどうか）を思いつかず撃沈
- コードは公式解説の要点だけを見て書いたもの
  - ユーザー解説を見るにDPの更新の仕方は様々のようだ
- それにしてもDP遷移式を考えるのが遅い。もっと慣れが必要か

## [ABC306 E - Best Performances](https://atcoder.jp/contests/abc306/tasks/abc306_e)
- 公式解説をチラ見すると
  - 「ABC281 E - Least Elements」でやったやつと同じやんけ！
    - この鳥頭である
- なお先に $A_{X_i}$ を削除し後から $Y_i$ を突っ込む方針だと $K = 1$ のとき大きいほう $K$ 個の集合 $L$ が一瞬空になり、さらに $Y_i$ をどちらの集合に突っ込むべきかをイテレータ`multiset::begin()`の指す要素を用いて判断すると`WA`となる
  - なんとも絶妙なやらかし
  - 空のコンテナに対する`begin()`は`end()`と等しく、`end()`の指す要素は不正な範囲になる
  - 先に $Y_i$ を突っ込んで後から $A_{X_i}$ を削除すれば $L$ が空になることがないので避けられる
- 計算量は $O(Q \log K(N-K))$

## [ABC091 C - 2D Plane 2N Points](https://atcoder.jp/contests/abc091/tasks/arc092_a)
- 二部グラフの最大マッチング問題
- [二部グラフのマッチング    [いかたこのたこつぼ]](https://ikatakos.com/pot/programming_algorithm/graph_theory/bipartite_matching)を参考に増大路を検索するアルゴリズムで書いた。感謝
  - これの計算量は頂点数を $V$ 、辺数を $E$ として $O(VE)$
- 公式解説曰く貪欲法でも行けるらしいが、まず気づかん…

## [ABC220 F - Distance Sums 2](https://atcoder.jp/contests/abc220/tasks/abc220_f)
- LCA（最小共通祖先）などを考えたがどう考えても計算量が $O(N^2)$ 以上になり間に合わない
  - 後学のためにLCAのリンク：[最小共通祖先 [いかたこのたこつぼ]](https://ikatakos.com/pot/programming_algorithm/graph_theory/lowest_common_ancestor)
- （公式解説）部分木のサイズがキーになる問題だった
- 部分木のサイズの求め方メモ：
    1. 整数列 $\{s_n\}$ の全ての項を1（自身のサイズ）で初期化する
    1. 帰りがけ順で子のサイズ $s_i$ の全てを自身のサイズに加える
        - 帰りがけ順と言っても、全ての子のDFSを呼び出すループが終わった後ではなく、それぞれの子のDFSを呼び出した直後にその子のサイズを加えるようにすれば余計なループが不要になる
- なお`accumulate()`の引数に`LL`をつけ忘れて1時間以上を溶かす

## [ABC235 E - MST + 1](https://atcoder.jp/contests/abc235/tasks/abc235_e)
- メモ：最小全域木のつくりかた
    1. 頂点のみのUnion-Findを用意する
    1. 辺の全てを重みの昇順でソートする
    1. それぞれの辺に対し、2頂点が連結でなければUnion-Findで繋ぐ
- 以下、$G$ の全ての辺からなる集合を $E$ とする
- 各クエリは辺の集合 $E \cup \{ e_i \}$ に対し、↑の方法で最小全域木を作れば答えられるが
  - この方法では $O(QM \log M)$ となり間に合わない
- （公式解説）複数のクエリを同時に扱ってもそれぞれのクエリの結果に影響を及ぼさないタイプなので、全てのクエリを同時にこなせばよい
  - すなわち $E \cup \{ e_1, e_2, \dots , e_Q \}$ に対し最小全域木を作れば（ただし $e_1, e_2, \dots , e_Q$ は木に加えない）$O((M+Q) \log (M+Q))$ で全てのクエリに答えることができる

## [ABC275 E - Sugoroku 4](https://atcoder.jp/contests/abc275/tasks/abc275_e)
- どうみても2要素DPですありがとうございました
- $dp_{i,j}$ をサイコロ $i$ 回振った後にマス $j$ にいる確率とすれば
  - 解は $\displaystyle \sum_{i = 0}^{K} dp_{i,N}$
  - DP1回あたりの計算量は $O(M)$ でありDPそのものは $NK$ 回更新するので、全体の計算量は $O(NMK)$ で間に合う

## [エイシング プログラミング コンテスト 2019 C - Alternating Path](https://atcoder.jp/contests/aising2019/tasks/aising2019_c)
- 全マスを頂点に持ち、隣り合うマスで色の異なる頂点間のみに辺を張ったグラフ $G$ を考えれば
  - その連結成分の任意の黒頂点と白頂点は題意を満たす移動ができる
    - よって各連結成分ごとに黒頂点の数と白頂点の数の積を求め、その和を答えればよい
- Union-Findを改造して黒頂点と白頂点の数を数えられるようにしたが
　- 途中でグラフの構造が変わるわけではないのでそもそも単にDFSでよかった

## [ARC141 B - Increasing Prefix XOR](https://atcoder.jp/contests/arc141/tasks/arc141_b)
- 以下、$x$ の最上位ビットを $\mathrm{msb}(x)$ と表す
- 一般に自然数 $a, b \ (a \lt b)$ に対して $a \lt a \oplus b \Leftrightarrow \mathrm{msb}(a) \lt \mathrm{msb}(b)$ が成り立つ
  - $\mathrm{msb}(a) = \mathrm{msb}(b)$ だとXORにより最上位ビットが0になってしまうため
- 全ての $i (1 \leq i \lt N)$ に対し $\mathrm{msb}(A_i) \lt \mathrm{msb}(A_{i+1})$ であることを帰納法で示す
    1. $B_1 \lt B_2$ より $A_1 \lt A_1 \oplus A_2 \Leftrightarrow \mathrm{msb}(A_1) \lt \mathrm{msb}(A_2)$
    1. 自然数 $k$ に対して $\mathrm{msb}(A_1) \lt \mathrm{msb}(A_2) \lt \dots \lt \mathrm{msb}(A_k)$ と仮定する
        - このとき $\mathrm{msb}(B_k) = \mathrm{msb}(A_k)$ が成り立つので
            - $B_k \lt B_{k+1} = B_k \oplus A_{k+1} \Leftrightarrow \mathrm{msb}(B_k) \lt \mathrm{msb}(A_{k+1}) \Leftrightarrow \mathrm{msb}(A_k) \lt \mathrm{msb}(A_{k+1})$
    1. 以上により帰納的に $\mathrm{msb}(A_i) \lt \mathrm{msb}(A_{i+1})$ が示せた
- これにより $N \gt \mathrm{msb}(M) + 1$ のときは条件を満たす数列 $A$ は存在しないことがわかる
- あとは $dp_{i,j}$ を 「$\mathrm{msb}(A_i) = j$ となるような数列 $(A_1, A_2, \dots, A_i)$ の場合の数 $\pmod{998244353}$」として以下のように数えるのみ
    - $c_j$ を $\mathrm{msb}(x) = j$ かつ $x \leq M$ を満たす自然数 $x$ の個数とする
    - 初期値：$dp_{1,j} = c_j$
    - 更新式：$\displaystyle dp_{i,j} = \sum_{k = 1}^{j - 1} c_j dp_{i-1,k}$
- 計算量は $O(\min \{ N, \log M \}(\log M)^2)$

## [ABC261 E - Many Operations](https://atcoder.jp/contests/abc261/tasks/abc261_e)
- 純粋に全操作を行うと $O(N^2)$ で間に合わない
- ここでポイントになるのは、各操作はビット毎に独立であるという点
  - すなわち、操作 $1, 2, \dots i$ を順に行って得られる新たな $X$ の2進数表記での下から $j$ 桁目は、操作前の $X$ の2進数表記での下から $j$ 桁目に依存する
    - よって、各ビットごとに初期値の $j$ ビット目が $0$ および $1$ であるときに操作 $1, 2, \dots i$ を順に行って得られる数の $j$ ビット目 $b_{0,i,j}, b_{1,i,j}$ を求めれば、新たな $X$ の各桁がそれぞれ $O(1)$ で求まる
- 具体的には以下の通り
    1. $C_0 = 0, C_1 = 2^{30} - 1, X = C$ とする
    1. $i (1 \leq i \leq N)$ について以下を順に行う
        1. $C_0, C_1$ のそれぞれに操作 $i$ を行う
        1. $j (1 \leq j \leq 30)$ について以下を順に行う
            - $X$ の $j$ ビット目を、それが $0$ なら $C_0$ の $j$ ビット目に、$1$ なら $C_1$ の $j$ ビット目に書き換える
        1. $X$ を出力する
- 計算量は $O(N)$
- 後から解説を見て、新たな $X$ を得るのにわざわざループでビットごとに計算せずとも $(X \ \mathrm{and} \ C_1) \ \mathrm{or} \ ((X \ \mathrm{xor} \ 2^{30} - 1) \ \mathrm{and} \ C_0)$ で良かったことに気づく
  - 定数倍とはいえかなり計算量が変わるので反省

## [ABC120 D - Decayed Bridges](https://atcoder.jp/contests/abc120/tasks/abc120_d)
- 「順番に辺を削除しながらクエリに答える」＝「逆順にして順番にUnion-Findで辺を追加しながらクエリに答える」
  - これは前にどこかでやったパターン
- 逆順にすれば、最初は全ての橋がないので不便さは $_{N}C_2 = \frac{1}{2}N(N-1)$ であり
  - 橋 $i$ を繋ぐ際に、島 $A_i$ と $B_i$ が異なる連結成分に存在すればそれらのサイズの積の分だけ不便さが減っていく
- 計算量は $O(M \alpha(N)) \simeq O(M)$

## [ABC187 E - Through Path](https://atcoder.jp/contests/abc187/tasks/abc187_e)
- クエリごとに全ての頂点を1個ずつ書き換えるのは $O(QN)$ で勿論`TLE`
- クエリ $i$ において（$t_i = 2$ のときは $a_{e_i}$ と $b_{e_i}$ を入れ替えると）書き換わる頂点は
  - $a_{e_i}$ が $b_{e_i}$ の子の場合は $a_{e_i}$ を頂点とする部分木
  - $a_{e_i}$ が $b_{e_i}$ の親の場合は木全体から $b_{e_i}$ を頂点とする部分木を除いたもの
- よって以下の方針でなんとかなりそう
  - Euler Tourでタイムスタンプを求めて部分木の頂点がすぐに分かるようにする
  - まとまった範囲に加算をするので累積和を用いて計算量を減らす
- 具体的には以下の通り
    1. 根を起点にDFSを行い、各頂点を初めて通る時刻 $p_i$ と最後に通る時刻 $q_i$ を求める
    1. 長さ $2N$ の整数列 $S$ を用意する（初期値はすべて0とする）
    1. 各クエリ $i$ に対し以下を行う
        1. 頂点 $v, u$ を以下のように定める
            - $t_i = 1$ のとき $v = a_{e_i}, u = b_{e_i}$
            - $t_i = 2$ のとき $v = b_{e_i}, u = a_{e_i}$
        1. 以下の通りに $S$ を更新する
            - $v$ が $u$ の子のとき
                - $S_{p_v}$ に $x_i$ を加え、$S_{q_v}$ から $x_i$ を引く
            - $a_{e_i}$ が $b_{e_i}$ の親のとき
                - $S_{1}, \ S_{q_u}$ に $x_i$ を加え、$S_{p_u}, S_{2N}$ から $x_i$ を引く
    1. $j (2 \leq j \leq 2N)$ に対し、昇順に $S_j \gets S_j + S_{j - 1}$ とする（$S$ の累積和を求める）
    1. 各頂点 $i$ に対し、$S_{p_i}$ を $c_i$ として出力する
- 計算量は $O(N + Q)$

## [ARC142 C - Tree Queries](https://atcoder.jp/contests/arc142/tasks/arc142_c)
- とりあえずすべての $i \ (3 \leq i \leq N)$ に対して $d_{1,i}$ と $d_{2,i}$ を尋ねる
- $d_{1,i}$ の最小値が $2$ の場合
  - 頂点 $1$ が葉であり、その親が頂点 $2$ であることがわかるので、解は $1$ である
  - $d_{2,i}$ の最小値が $2$ の場合も同様である
- $d_{1,i}$ の最小値および $d_{2,i}$ の最小値が $1$ の場合
  - 頂点 $1$ に隣接する頂点で頂点 $2$ に最も近いものを $v$ とする（複数ある場合はどれでも良い）
  - $d_{2,v} \neq 2$ ならば $d_{1,v} + d_{2,v}$ が解になる
  - $d_{2,v} = 2$ の場合は頂点 $1,2$ が隣接しているケースとそうでないケースの区別がつかないので、さらに以下を行う
    - 頂点 $2$ に隣接する頂点で頂点 $1$ に最も近いものを $u$ とする（複数ある場合はどれでも良い）
    - $d_{u,v}$ を尋ねる
      - $d_{u,v} = 3$ ならば、頂点 $1,2$ が並んでいるケースなので解は $1$ である
      - そうでないならば解は $3$ である

## [ABC104 C - All Green](https://atcoder.jp/contests/abc104/tasks/abc104_c)
- 以下 $100i$ 点を付けられた問題の集合をカテゴリ $i$ と呼ぶことにする
- コンプリートボーナスを無視するならカテゴリ番号の大きいほうから貪欲に解けばよい
- $D \leq 10$ よりどのカテゴリをコンプリートするかどうかはビット列で管理できる
- よって以下の方針で解ける
  - $T = \{ 1, 2, \dots, D \}$ の部分集合 $S$ に対して以下を行い、解いた問題数の最小値を解として出力する
      1. $S$ に含まれるカテゴリの問題を全て解く
      2. まだ目標スコアに届かない場合は、まだ解いていないカテゴリ番号の大きいほうから貪欲に解く
          - もちろんコンプリートボーナスも忘れずに
- $T$ の部分集合は $2^D$ 個なので計算量は $O(D2^D)$

## [CODE FESTIVAL 2017 Final C - Time Gap](https://atcoder.jp/contests/cf17-final/tasks/cf17_final_c)
- 以下、高橋君の都市が $0$ 時のタイミングでの各参加者 $i$ の都市における時刻を $T_i \ (-12 \lt T_i \leq 12)$ とする
  - かつ、高橋君を考慮に入れるために $i = 0$ が高橋君を示すものとし、$D_0 = 0$ とする
- $C_t (0 \leq t \leq 12)$ を $D_i = t$ となる相異なる $i$ の個数とおく
- まず、$s$ の最大値が $0$ になるケースを考える
  - $D_i = t \ (0 \lt t \lt 12)$ の場合、$T_i$ としてあり得る値は $t, 24-t$ の2つ 
  - $D_i = 0, 12$ の場合、$T_i$ としてあり得る値はそれぞれ $0, 12$ の1つのみ
  - よって鳩の巣原理より、以下の条件のいずれかを満たす場合は同じ時刻となる参加者の組が必ず存在する
    - $C_0 \geq 2$
    - $C_{12} \geq 2$
    - いずれかの $t$ に対し $C_t \geq 3$
- ↑以外の場合において
  - この時点で $C_0 = 1, \ C_{12} \leq 1, \ C_t \leq 2$ が確定している
  - $C_{12} = 1$ ならば該当する参加者 $i$ に対し $T_i = 12$ を割り当てる
  - $C_t = 2$ ならば該当する参加者 $i, j$ に対し $T_i = t, \ T_j = -t$ を割り当てる
  - $C_t = 1$ に対しては該当する参加者 $i$ に対し $T_i = t, -t$ の2通りの割り当てが存在する
- よって $C_t = 1$ となる各 $t$（高々11個）に対し実際に2通りの割り当てを全探索することで $s$ の最大値が求まる
  - $2^{11} = 2048$ より計算量は余裕
  - それぞれのパターンにおいて $s$ を求めるには、$T_i$ を昇順に並べたうえでその末項に $(\mathrm{初項}) + 24$ を加え、階差の最小値を取ればよい

## [ABC226 E - Just one](https://atcoder.jp/contests/abc226/tasks/abc226_e)
- 明らかに連結成分ごとに考えてOK
- 連結成分が木の場合
  - 葉を開始地点として、子から親のほうへ向きを付けることを繰り返せば根以外は条件を満たすことができる
  - ただし根が条件を満たさないのでNG
- 連結成分が木ではない場合
  - 閉路がちょうど1つ含まれる場合
    - 閉路に含まれる頂点に関しては時計回りか反時計回りの2通りの向きの付け方がある
    - 閉路に含まれない頂点に関しては、閉路に含まれる頂点1つを根とした木と見ることができるので条件を満たせる
  - 閉路が2つ以上含まれる場合は必ず出次数が2以上になる頂点が含まれるため条件を満たせない
- 以上により
  - 各連結成分が閉路をちょうど1つ含む場合は、連結成分の個数を $k$ として解は $2^k$
  - 1つでも↑を満たさない連結成分がある場合は解は $0$
- 計算量は $O(\max \{ N \alpha(N), M \alpha(N) \})$

## [ABC074 C - Sugar Water](https://atcoder.jp/contests/abc074/tasks/arc083_a)
- $F \leq 3000$ より全探索ができそう
- よってまずは全探索で水の質量、すなわち $100Aa + 100Bb \leq F$ になる全ての $(a, b)$ の組を求める
  - ↑のそれぞれに対して砂糖の質量を全探索で求めることを考える
    - まず、砂糖の質量の最大値 $M$ は以下を考慮して $M = \min \{ F - 100Aa - 100Bb, (Aa + Bb)E \}$ である
      - 水溶液全体が $F$ より重くなってはならない
      - 飽和状態よりも多く砂糖を入れることはできない
    - よって $Cc + Dd \leq M$ となる全ての $(c, d)$ の組を考え、それぞれに対して濃度を計算し、最大値を更新できればそのときの水溶液の質量 $100Aa + 100Bb + Cc + Dd$ と砂糖の質量 $Cc + Dd$ を記録すればよい
- $a, b, c, d$ の各ループは高々30回なので4重ループでも計算量は十分に少ない

## [ARC149 C - Avoid Prime Sum](https://atcoder.jp/contests/arc149/tasks/arc149_c)
- $N$ が偶数のとき
  - 上半分を全て偶数、下半分を全て奇数で埋めれば、偶数と奇数の境界以外の隣り合う2マスの数の和はすべて偶数かつ2より大きいので条件を満たす
  - 境界部分に関しては全て3の倍数かつ $2$ と $1$ が隣り合わないようにすればOK
- $N$ が奇数のとき
  - 左上から $(N^2 - 1) / 2$ マスを偶数で、右下から $(N^2 + 1) / 2$ マスを奇数で埋めれば、やはり偶数と奇数の境界以外は条件を満たす
  - 境界部分に関しては $N$ が偶数のときと同様だが、中央のマス（奇数）のみ2つの偶数と接するのでその2つの偶数を3で割った余りが異なると双方との和の両方を3の倍数にすることはできない
    - この場合偶数を適当に入れ替えて対応する
- 実装が適当過ぎて $N = 3$ のときに苦労した
  - 奇数の埋める順番を間違えると解がなくなってしまう

## [ABC032 D - ナップサック問題](https://atcoder.jp/contests/abc032/tasks/abc032_d)
- Recommendationに表示されたわけではないのだが気になったので解いてみた
- 問題自体はシンプルなナップサック問題なのだが、制約が複数種類あるため方針を変える必要がある
  - ある意味一粒で何度もおいしい問題
- $\displaystyle \max_{1 \leq i \leq N} w_i \leq 1000$ の場合
    - いわゆる最もポピュラーなケース
    - $dp_{i,j}$ を「$i$ 個目までのナップサックを見て合計質量が $j$ になるような選び方をした時の価値の和の最大値」とおいて以下の通りに更新する
        - 初期値：$dp_{1,w_1} = v_1$、それ以外は $0$
        - 更新：
            - $j \lt v_i$ ならば $dp_{i+1,j} = dp_{i,j}$
            - $j \geq v_i$ ならば $dp_{i+1,j} = \max \{ dp_{i,j}, dp_{i, j - w_i} + v_i \}$
    - 解は $\displaystyle \max_{0 \leq j \leq W} dp_{N, j}$
    - 計算量は $O(NW)$ であり $NW \leq 1000N^2 \leq 4 \times 10^7$ なので十分に間に合う 
- $\displaystyle \max_{1 \leq i \leq N} v_i \leq 1000$ の場合
    - ↑と同じDPを作ると $w_i \leq 10^9$ の制約により $w_i$ の最大値がデカいと`MLE`になる
    - DPの要素に $w_i$ ではなく $v_i$ を使いたい
    - $dp_{i,j}$ を「$i$ 個目までのナップサックを見て合計価値が $j$ になるような選び方をした時の重量の和の最小値」とおいて以下の通りに更新する
        - $\displaystyle V = \sum_{i = 1}^N v_i$ とおく
        - 初期値：$dp_{1,v_1} = w_1$、$1 \leq i \leq N$ に対し $dp_{i, 0} = 0$、それ以外は $\infty$
        - 更新：
            - $j \lt w_i$ ならば $dp_{i+1,j} = dp_{i,j}$
            - $j \geq w_i$ ならば $dp_{i+1,j} = \min \{ dp_{i,j}, dp_{i, j - v_i} + w_i \}$
    - 解は $dp_{N,j} \leq W$ となる最大の $j$
    - 計算量は $O(NV)$ であり $NV \leq 1000N^2 \leq 4 \times 10^7$ なので十分に間に合う
- $N \leq 30$ の場合
    - $v_i, w_i$ ともに大きすぎてDPの要素にできないのでDPは諦める
    - 代わりに $2^{30} \simeq 10^9$ なのでギリギリ全探索可能
    - ただし純粋にビット列で計算すると価値の和を求めるのに $O(N)$ の計算量が必要なため、全体で $O(N2^N)$ となり`TLE`
    - ここでナップサックを半分に分けて計算量を減らすことを考える
        - 前半 $\lceil \frac{N}{2} \rceil$ 個と後半 $\lfloor \frac{N}{2} \rfloor$ 個に分けてそれぞれビット列で全探索すると、価値の和と重さの和を求める計算量は $O(\lceil \frac{N}{2} \rceil 2^{\lceil \frac{N}{2} \rceil} + \lfloor \frac{N}{2} \rfloor 2^{\lfloor \frac{N}{2} \rfloor}) \simeq O(\frac{N}{2} 2^{\frac{N}{2}})$
            - $\frac{N}{2} 2^{\frac{N}{2}}$ は最大でも $5 \times 10^5$ 程度なのでかなり余裕がある
        - 勿論そのあとに前半と後半を組み合わせて解を求める必要がある
            - この計算量は $O(2^{\lceil \frac{N}{2} \rceil}2^{\lfloor \frac{N}{2} \rfloor}) = O(2^N)$ なので前述の通りギリギリ間に合う

## [ABC184 E - Third Avenue](https://atcoder.jp/contests/abc184/tasks/abc184_e)
- グリッドグラフにさらにテレポーターどうしを辺で繋いだものを考え、それに対してDijkstraで最短距離を求める。以上！
  - ただし実際に辺を繋いでしまうと辺数は最大で $(HW - 2)(HW - 3)/2 \simeq 8 \times 10^{12}$ であり`MLE`を食らうので、同じ種類のテレポーターの座標のみをリストで保持し、探索時に参照する形をとった
- 計算量は辺数を $E$ として $(E+HW)\log{HW}$ であり、$E$ は前述の通り $H^2W^2$ のオーダーになる可能性があるが、テレポーターが多すぎるとゴールまでの距離も短くなるため実際にはそこまでの計算量にはならない…はず
  - テストケースは最大約2100msで通っている

## [ABC119 C - Synthetic Kadomatsu](https://atcoder.jp/contests/abc119/tasks/abc119_c)
- $N \leq 8$ より間違いなく全探索なんだろうなと思いつつ、うまい具合に計算する方法が思いつかず
- どうせ全探索なんだからどこまでも愚直にやってやろうと考える
- 合成魔法を使わずに目的を達成するための最小MPは以下の考え方で求められる
  - 今持っている竹から3本を選ぶ全ての組み合わせについて以下を計算し、その最小値を求める
    - 選んだ竹の長い順にそれぞれ $A, B, C$ との差の絶対値を計算し、その合計を求める
- 合成魔法を使う場合は以下のように考える
  - 今持っている竹から2本を選ぶ全ての組み合わせに対し、再帰的に以下を考える
      1. 選んだ竹を合成する
      1. その状態で合成魔法を使わずに目的を達成するための最小MPを求める
      1. 竹が4本以上あれば2本を選んで1. へ
  - ↑の考え方だと結果的に同じ合成結果になる組み合わせがいくつも存在するが、組み合わせの総数は最大で ${}_8C_2 \times {}_7C_2 \times {}_6C_2 \times {}_5C_2 \times {}_4C_2 \simeq 5.3 \times 10^5$ であり計算量もメモリ消費量も余裕があるため、重複チェックをする必要はないと判断した
- （公式解説）竹のそれぞれについて「$A$ で使う」「$B$ で使う」「$C$ で使う」「使わない」を決める…考え方も実装も簡潔すぎる！
  - こういう主客逆転の考え方がすぐに思いつける体になりたい

## [ABC215 E - Chain Contestant](https://atcoder.jp/contests/abc215/tasks/abc215_e)
- $A_i$ を $i$ 回目のコンテストの種類とする
- キーになるのは以下の2つ
  - まだ参加したことのない種類のコンテストは任意のタイミングで参加できる
  - 既に参加したことのある種類のコンテストは直前に参加したものと同じ種類でないと参加できない
- よって $dp_{i,j,k}$ を「$i$ 回目以前のコンテストで参加した種類の集合が $j$ であり、$i - 1$ 回目に参加したコンテストの種類が $k$ であるようなコンテストの参加の仕方の場合の数」とすると、
  - 初期値：$dp_{1, \{ A_0 \}, A_0} = 1$
  - 遷移
    - $i$ 回目に参加しない：任意の $j, k$ に対し $dp_{i, j, k} = dp_{i - 1, j, k}$
    - $i$ 回目に参加する：
      - $k = A_i$ ならば
        - 任意の $j$ に対し、 $dp_{i, j, k}$ に $dp_{i - 1, j ,k}$ を加算
      - $j \not\ni A_i$ ならば
        - 任意の $j \not\ni A_i$ と任意の $k$ に対し、$dp_{i, j \cup \{ A_i \}, A_i}$ に $dp_{i - 1, j, k}$ を加算
  - 解は $\displaystyle \sum_{j} \sum_{k=1}^{10} dp_{n,j,k}$
- $j$ はビットで集合を表せばOK

## [AGC020 B - Ice Rink Game](https://atcoder.jp/contests/agc020/tasks/agc020_b)
- 後ろから順にあり得る最大値と最小値を計算するも上手くいかず
  - 最大値と最小値を完全に分けて考えてしまったため、$N$ が存在しないケース（最大値と最小値の間に $A_i$ の倍数が無い場合は $N$ が存在しない）を上手くはじくことができなかった
- （公式解説）自分の解答で試したものは線形走査であり計算量も二分探索より優れているのだが、この問題で二分探索を用いるという発想が出なかったので後学のために二分探索で実装してみた
  - そもそも二分探索が使えるのは（広義）単調増加、単調減少性がある場合である。逆に言えば、（広義）単調増加、単調減少性がある場合は（ベストかどうかはともかく）二分探索を検討すべきである。
  - 「最終的に2人**以上**が残る最小の $N$」「最終的に2人**以下**が残る最大の $N$」と読み替えられるかどうか
 
## [ABC289 E - Swap Places](https://atcoder.jp/contests/abc289/tasks/abc289_e)
- Dijkstra法をちょちょいといじればOK
  - 普段は「頂点 $1$ から頂点 $i$ までの最短距離を $d_i$」としているところを、「高橋君が頂点 $i$ に、青木君が頂点 $j$ にいる状態にするための最小の移動回数を $d_{i,j}$」とする
    - はじめは単に「高橋君が頂点 $i$ に行くまでの最小の移動回数 $a_i$」と「青木君が頂点 $j$ に行くまでの最小の移動回数 $b_i$」に分けてそれぞれを更新していくことを考えたが、「2人が同時にそれぞれ頂点 $i,j$ にいる状態」を考えるべきと気づいて↑のようにした
- 通常のDijkstra法と比べて計算量としてネックになるのは2人が行くことのできる隣接頂点を探すときの2重ループだが、$M \leq 2000$ より多くとも $10^6$ 通りの組み合わせしかないため問題ないと見た