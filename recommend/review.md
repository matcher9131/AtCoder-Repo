# AtCoder Problems Recommendation Reivew
AtCoder Problems Recommendationでおすすめされる問題をひたすら解いてひたすらレビューする

※ 添え字は特に記述のない限り1-indexedとする

## ABC174 E - Logs
- 最小化問題すなわち二分探索法
  - 最小値を直接求めるのは難しいが、ある値にすることができるかどうかの判定が容易い場合の鉄板パターン
- めぐる式二分探索法でやってみた

## ABC251 E - Takahashi and Animals
- 行動 $1$ をするDPと行動 $1$ をしないDPに場合分けして考える
- DPそのものを場合分けして2回やる発想はなかった
  - 一応2次元DPまではわかっており、その点は◎
  - DPなんだろうなぁと思いつつ、行動 $1$ をするかどうかで行動 $N$ をするのかどうかが変わるしどうすればええねん…で止まってしまった

## ABC096 D - Five, Five Everywhere
- 素数判定問題
- 当然 ${}_{55}C_5 \simeq 3.5 \times 10^6$ パターンに対して合成数かどうかなんて判定してたら余裕で`TLE`なわけで
  - なのでどの5つを選んでも合成数になるようにしなければならない
    - 5つ足して合成数なら5の倍数を目指すのが最も楽

## ABC264 E - Blackout 2
- 1つずつグラフの辺を削除しながらクエリに答える系の問題
- 逆順にすればUnion-findで辺を追加しながらいけるんじゃね？とすぐにわかったのは◎
  - 発電所と繋ぐ場合は必ず親を発電所にすることで各都市が発電所につながっているか簡単に調べられることにも気づいた
- しかし辺を追加するたびにいちいち全都市に対して発電所が親かどうかを確認してしまい $O(NQ) = O(10^{11})$ で無事`TLE`
  - 正しくは、発電所につながっていないグループのサイズがそのまま新しく電気が通る都市の数になることを利用する。この場合 $O(N + Q)$ のはず…
- Union-findは割とカスタマイズできる（connectの親の選び方、戻り値）ことを覚えておく

## ABC164 D - Multiple of 2019
- ${}_{N}C_2$通りすべてを調べるともちろん`TLE`
- 2019の倍数かどうかを調べる問題なので、余りの遷移をみたい
  - 遷移を1つだけ保持するのではなく、余りごとに個数を記録すべし
- 当然ながら $i < j$ に対し $S_{[i, N]} \equiv S_{[j, N]}$ ならば $S_{[i, j - 1]} \equiv 0 \pmod{2019}$ という数学的考察も大事

## AGC003 B - Simplified mahjong
- **麻雀と聞いて（ｶﾞﾀｯ**
  - 麻雀関連はいろいろコードを書いたことがあったので、考察が楽に捗った
- それでもまさか単に下から貪欲に刻子→順子の順に取るだけだとは思わず、疑心暗鬼で提出したらあっさり`AC`で拍子抜け
  - やっぱり**今の水色は難しすぎる**って！

## ABC198 D - Send More Money
- $10! = 3.6 \times 10^6$ なので全パターン試してもよさそう
- というわけで`next_permutation()`でゴリゴリ回す
  - 文字列の置き換えも含めて $O(N^2 \times N!)$ …のはず（ただし $N = \max \{ |S_1|, |S_2|, |S_3| \}$）

## ABC062 C - Chocolate Bar
- まず、 $H$ か $W$ が3の倍数のときは~~アホになります~~3等分ができる
- そうでなくてもとりあえず縦2回 or 横2回で切れば $S_{\max} - S_{\min} = \min \{ H, W \}$ とできる
- あとは縦→横 or 横→縦の順番で切るパターンを考える
  - いずれの場合も2回目の切断はできる2つのピースの面積を最小にするべきなので、中央（奇数ならほぼ中央）で切る
  - 1回目の切る場所は全探索しても $O(H + W)$ なので問題なし

## ABC089 D - Practical Skill Test
- **計算量は毎回きちんと見積もること**
  - そりゃ全てのクエリで毎回探索してたら $O(HWQ)$ で`TLE`だわな…
- $D$ が共通であることにピンとくることができる体になりたい
  - そして差を求める系の問題には累積和が特効薬

## ABC256 E - Takahashi's Anguish
- 全てのノードにおいて出次数が1なので、1つの連結成分に対し必ずちょうど1個のサイクルが生じる
  - サイクルではない部分に関しては、入次数が0の人からグラフをたどるように渡していけば全員に不満が生じない
  - サイクル部分に関しては、グラフをたどるように渡していけば最後に渡される人にのみ不満が生じる
- よってサイクルごとに最小辺を見つけ、その不満度を合計すれば解になる
- 具体的にはUnion-find木を構築し、根ごとにDFSを回してサイクルを取得、その最小辺のコストを合計した
  - が、提出後にUnion-find木の構築中にサイクルを検出できることに気づく
    - しかも今回は全てのノードの出次数が1なので、サイクル復元も単にforループを1回回すだけで済む…
      - 要するにDFSが大げさすぎる
        - ま、まぁ`AC`したからよしとしましょう（震え声）

## ABC200 D - Happy Birthday! 2
- 以下 $A_i$ は $A_i \bmod 200$ に置き換える
- とりあえず思いついたのはDP
  - `dp[i][k]`: $A$ の先頭 $i$ 個からいくつか選んだ和の200で割った余りが $k$ になるパターンの総数
- DP復元は初挑戦だったが…
  - デバッグの嵐
    - わからなすぎて禁断のテストケース覗き見を敢行
      - $A_i = 0$ のとき、 $A_i$ を選んでも選ばなくても $k$ の遷移元が同じなので区別がつかず、 $B$ と $C$ で同じ選択をしてしまっていた
        - 復元のときに $A_i = 0$ について別個に処理することで対処
      - **普通にオーバーフロー**
        - DPの値は2以上ならば差はないので、既に2以上のときは（経路復元用のほうも含めて）更新しないようにした
- （公式解説）ここで鳩の巣原理はカッコよすぎる

## ABC308 F - Vouchers
- 間違った貪欲法をしてしまい行方不明に
  - なぜか $P_i \geq L_j$ となる最小の $j$ （ただし、同じ $L_j$ のクーポンが複数ある場合は $D_j$ が最も大きいもの）のクーポンを選んで使っていた
- もちろん正しくは $P_i \geq L_j$ となるクーポン $j$ のうち、最も $D_j$ が大きいものを選択する必要がある
  - ただし実装を間違うと余裕で`TLE`なのでさらなる考察が要る
    - $A_i$ と $L_j$ をそれぞれ昇順に並べた場合、$i$ が増えるとともに使えるクーポン $j$ が $0$ から順番に増えていく
      - 順番に増えるというのがポイントで、使えるクーポンを探索する必要がない（どこまで使えるのかを記録するだけでOK）
    - 一方で使うクーポンはその時点で最も $D$ が大きいものになる
    - ここでクーポンのデータを2重で持つと計算量を減らせる
      - まずはクーポン全体をソートされた配列で持つ
      - 次にその時点で使えるクーポンを管理する`priority_queue`を作る
        - これによりその時点で $D$ が最大になるクーポンが $O(1)$ で選べるばかりか、使ったクーポンを削除するのも $O(1)$ でいいことずくめ
- 「全体から検索」が計算量的にきつそうなら「全体→今候補になるもの→検索」というクッションを作る！

## ABC300 E - Dice Product 3
- $\bmod \ 998244353$ での割り算を計算する術がない！
  - もちろんAtCoder Libraryを使ってもよかったのだが、後学のために自作した
    - ガバいテストケースも作ってちゃんとテストを通したのでヨシ！~~（現場猫案件ではないことを祈る）~~
    - 忘れたころにやってくるフェルマーの小定理さん：「整数 $a$ 、素数 $p$ に対し $a^{p - 1} \equiv 1 \pmod p$」
- 計算は例によってDP
  - $dp_{i,j,k}$ を $x = 2^i3^j5^k$ になる確率と定義
    - このとき $dp_{i,j,k} = \frac{1}{6}dp_{i,j,k} + \frac{1}{6}dp_{i-1,j,k} + \frac{1}{6}dp_{i,j-1,k} + \frac{1}{6}dp_{i-2,j,k} + \frac{1}{6}dp_{i,j,k-1} + \frac{1}{6}dp_{i-1,j-1,k}$
      - ただし $i = 1,2$ or $j = 1$ or $k = 1$ のときは添え字が0以下になる項は $0$ として扱う
    - 変形して $dp_{i,j,k} = \frac{1}{5}dp_{i-1,j,k} + \frac{1}{5}dp_{i,j-1,k} + \frac{1}{5}dp_{i-2,j,k} + \frac{1}{5}dp_{i,j,k-1} + \frac{1}{5}dp_{i-1,j-1,k}$
    - 計算量は $O((\log N)^3)$ なので問題なし
    - DPの更新順も特に気を使う必要がなく楽に実装
- サイコロの積に関する問題は大学入試数学でも割と見るため、すぐに $2^i3^j5^k$ がキーになると気づけた
- なお確率が $0$ となる条件をしくじって`WA`を喰らった模様
  - 相変わらず詰めが甘い…

## ARC052 B - 円錐
- **問題文が分かりづれぇ！**
  - 「いずれか」ではなく「すべての」とかにすべきだと思う
  - ~~というかこいつが水色なのはこの問題文のせいなのでは…？~~
- 円錐の底面 $x$ 座標と高さが整数であるから、$V_x$ を各円錐の区間 $[x, x+1]$ の部分における体積の合計と置いて計算ができる
  - 計算量は $O(NH_i) = O(10^6)$ なので十分に余裕がある
- あとは各クエリについて $\sum_{x = A_i}^{B_i - 1} V_x$ を求めるだけ
  - 本当は累積和を使うべきだけど、そのまま愚直に計算しても9msで通った

## ABC196 D - Hanjo
- 探索順でしくって`WA`
- 下手にDP探索とかやるからこうなる
  - 単なるDFSで良かった件について
- まぁビット列での管理はすぐに思いついたのでそこはよしとしましょう…
- $HW \leq 16$ という超親切設計なので計算量では悩まなくてよし

## ABC014 C - AtColor
- ABCのC問題で（試験管とはいえ）水色だと！？
- しばらく考えて座標圧縮を試みるも1つのテストケースがギリギリ通らず`TLE`
  - 座標圧縮後に愚直にカウントしてしまったのが原因
- 区間 $[L_i, R_i]$ がたくさん与えられるとき、 整数 $x$ を含む区間の個数を高速に調べるには以下の方法を取ればよい
  - 配列 $A$ を全て0で初期化する
  - 全ての区間に対して $A_{L_i}$ に $1$ を加え、 $A_{R_i + 1}$ から $1$ を引く
  - $A$ の累積和 $S$ を作れば、 $S_x$ が $x$ を含む区間の個数になる。
- むしろ↑のアプローチをとれば座標圧縮はいらなかったっぽい
- 前にやったはずなんだけど忘れてますねぇ…

## 天下一プログラマーコンテスト2013予選B B - 天下一後入れ先出しデータ構造
- もちろん`stack`を使えばよいのだが $N$ や $L$ が大きくそのままでは`TLE`と予想できる
- データ入力の仕様からして同じ数字が何個も並ぶので、`pair`で数字と個数を管理
  - `Pop`がやや複雑になるのと、`Size`に答えるために別にサイズのデータを持つ必要があることに注意すればそれほど難しくはない

## ABC103 D - Islands War
- **区間スケジューリング問題**
- 要望を $b_i$ が小さい順にソートして考える
  - 順に要望を見ていき、満たされていない要望 $i$ に対して橋 $[b_i - 1, b_i]$ をなくしていく
    - 橋 $[b_i - 1, b_i]$ を選ぶのは、最も右の橋をなくすことで同じ $b_i$ の要望の全てに答えることができるから

## ABC183 E - Queen on Grid
- 愚直にDPしてしまい`TLE`
  - 水色がそんな単純なわけがない
- なので累積和を使うが、3方向からの移動を全て累積和にする必要がある
  - 壁について
    - 右方向の移動の場合、壁より右の全てのマスは、壁より左のあらゆるマスから遷移できない
    - すなわち $(x, y)$ が壁の場合、$(x + 1, y)$ の右方向からの累積和は $0$ になる
    - 勿論ほかの方向でも同様

## ABC021 C - 正直者の高橋くん
- グラフの最短経路を求めるアルゴリズムはいくつかあるが、今回はDijkstra法をちょちょいといじる
  - 最短経路のまとめは[最短経路問題の解法まとめ](https://qiita.com/taka256/items/a023a11efe17ab097433)がわかりやすい。感謝。
- 最短経路長を更新するついでに経路数を数える
  - 町 $a$ から町 $i (1 \leq i \leq N)$ への最短経路長を $D_i$、町 $a$ から町 $i$ への最短経路数を $C_i$ とすると
    - 町 $i$ と町 $j$ をつなぐ道路によって $D_j$ が更新される場合、$C_j \gets C_i$ とする（最短経路が完全に更新される）
    - 町 $i$ と町 $j$ をつなぐ道路が存在して $D_j = D_i + 1$ が成り立つ場合、$C_j \gets C_j + C_i$ とする（最短経路と同じ長さの経路が他にもある）

## ABC191 E- Come Back Quickly
- 多重辺について、同じ向きで所要時間のより大きい道は明らかに不要
- それぞれの町間の最小所要時間（行けない場合は`INF`）を求められればあとは $O(N^2)$ でいけそう
- 制限3秒ならWarshall-Floyd法で行けるかと思ったが見事に`TLE`
  - 隣接行列を使ったのもダメだったか
- **辺の数が少なければ全頂点についてDijkstra法でも充分早い**
  - Dijkstra法を使う場合は自己ループ辺は邪魔なので別に管理しておく
  - 各頂点に対してDijkstra法を用いて、各頂点間の最小距離 $d_{i, j}$ を全て求める
  - 各 $i$ に対して $d_{i,j} + d_{j ,i}$ の最小値を求め、あらかじめ除けておいた自己ループと比べて小さいほうを出力する

## ABC307 C - Ideal Sheet
- シートのサイズが最大で10なので全探索（$O(H_AW_AH_BW_BH_XW_X)$）で十分間に合う
- シートA, BのそれぞれがシートXと共通部分を持つように左上座標をずらしながらシートXを作れるかどうかを判定する
  - このときシートA, Bの黒マスがシートXからはみ出ていないかの判定をいちいちするのが面倒くさいので、あらかじめシートA, Bの黒マスの左端、右端、上端、下端を求めておいて、はみ出るような箇所はそもそも探索しないようにする
    - 具体的にはシートXの左上座標を原点とし、シートAの黒マスの左端、右端、上端、下端をそれぞれ $A_L, A_R, A_U, A_D$とするとき、シートAの左上の座標 $(i, j)$ に関して $-A_L \leq i \lt W_X - A_R, -A_U \leq j \lt H_X - A_D$ とすれば、シートAの黒マスはシートXからはみ出さない（シートBも同様にする）

## Donutsプロコンチャレンジ2015 B - Tokyo 7th シスターズ
- $N \leq 16$ なのでユニットはビット列で表せるし、$2^{16} = 65536$ なので全探索も余裕
  - ユニットの人数がちょうど9人という点については、整数 $i$ を2進数表記したときの`1`の個数を $c_i$ とするとき、$c_i = 9$ となる $i$ に対してのみ能力値を計算すれば問題ない
- コンボボーナスの組み合わせもビット列で表せば余計な探索は不要になる
  - ユニットを表す整数 $i$ とコンボボーナスの組み合わせを表す整数 $j$ に対し、$c_{i \land j} \geq 3$ ならばコンボボーナスが得られる
  - 示された組み合わせのうち3人いれば大丈夫という点を見落としてグダりかけたのは内緒

## CODE FESTIVAL 2014 Easy C - 身体バランス
- どうみてもDijkstra法ですありがとうございました
- 計算量は $O((N + M)\log N)$？

## ABC248 E - K-colinear Line
- まず、解が`Infinity`になる必要十分条件は $K = 1$
- よって以降 $K \geq 2$ とする
- $N(N - 1)/2$ 本の直線に対して $K$ 個以上の点を通るものをカウントする方針を検討するも
  - 直線のダブりを排除する方法が割と面倒くさいことに気づく
    - 傾きと切片の2パラメータでやろうとすると小数になるので誤差が怖い
    - $ax + by + c = 0$ の形にすれば3パラメータになるが整数で管理できる。この方針はありかもしれなかったが採用はしなかった
- 代わりに各点ごとにその点を通る直線を引いてカウントすることにする
  - 点 $i (1 \leq i \leq N)$ に対し、点 $i$ から点 $j (j \neq i)$ に向かうベクトル $V_{ij}$ を考える
  - ベクトルを以下のように正規化する
      1. ベクトルの各成分を、全成分の最大公約数で割る
          - ただし任意の整数 $n$ に対し $\gcd (n, 0) = n$ とする
      1. $x$ 成分が負の場合は各成分の符号を反転する
  - ↑の正規化により、もともと平行なベクトルは完全に一致するようになる
  - $n - 1$個の正規化されたベクトル $V_{ij}$ の中でちょうど $k - 1$ 個が一致するとき、1本の直線上に $k$ 個の点があることになる
  - これを全ての $i$ に対して行うが、$k$ 個の点が同一直線上にあるとき、$k$ 回重複してカウントしていることになる
    - よって各 $k \geq K$ に対して別個にカウントし、それぞれを $k$ で割ることにより重複を取り除ける
- 正規化されたベクトルのうち何個が一致するのか数えるのにソートを使っているので、計算量は $O(N^2\log N)$

## ABC268 D - Unique Username
- $S_i$ の並び替えに関しては`next_permutation()`に丸投げするとして、問題は`_`の数
- $\sum_{i = 1}^N |S_i| = L$ とおくと、余分に追加できる`_`は最大で $16 - L - (N - 1)$ 個である。以下これを $E$ として、
  - 各項が $0$ 以上で合計が $E$ 以下になる $n-1$ 項の数列 $A$ が用意できれば、$A_i$ が $S'_i$ と $S'_{i + 1}$の間に余分に挿入される`_`の個数とすることができる
    - で、これをどうやって作るのか
- こういうときは再帰関数の出番
  - 以下の3つを持つ再帰関数で、
    - $k$
    - $k$ 番目までの $S'_i$ を適当な個数の`_`で繋いだ文字列
    - その時点で余分に挿入できる`_`の個数 $E_k$
  - 次に $S'_{k + 1}$ を繋げるときに余分な`_`の個数を $0$ 以上 $E_k$ 以下で全て探索するようにすればOK
- $T_i$ は`set`に放り込んで`find()`の計算量を $O(\log M)$ にしておく
- $|X| \geq 3$ のような小さい条件を見失わないように注意（1敗）
- 計算量は $O(N! {}_{16-N}C_{N-1} \log M)$

## ARC048 B - AtCoderでじゃんけんを
- レーティングが自分より低い人/高い人の人数は`lower_bound()`と`upper_bound()`に任せればOK
- レーティングが自分と同じ人に関して
  - $O(N^2)$ だと`TLE`の可能性が高いので毎回探索するわけにはいかない
    - よってレーティングをkey、グー・チョキ・パーを出した人がそれぞれ何人いるかをvalueとする`unordered_map`をあらかじめ作っておき、レーティングが同じ人に対する勝敗を $O(1)$ で判断できるようにする
- 計算量は $O(N \log N)$

## ABC242 D - ABC Transform
- $Q \leq 10^5$ より、1回のクエリは多くても対数時間に抑えないと`TLE`になる
  - まぁそもそも長さ $10^{18}$ の文字列なんざまともに相手できないわけで
- 与えられた文字列について、`A, B, C`をそれぞれ`0, 1, 2`に置き換えて考える
- すると $S^{(t)}_{k} = x$ のとき、$S^{(t + 1)}_{2k - 1} \equiv x + 1 \pmod 3, S^{(t + 1)}_{2k} \equiv x + 2 \pmod 3$ となる
- よって $S^{(t)}_{k}$ は $S^{(t - 1)}_{\lceil k / 2 \rceil}$ を見ればわかる
- これを繰り返すことで $S^{(0)}_{k'}$ か $S^{(t')}_1$ までたどり着けば $O(1)$ で文字が何かわかるため、高々64回の計算でクエリに答えることができる
  - 具体的には $k - 1$ の2進数表記における`1`の数を $c$、$p = \lfloor (k - 1) / 2^t \rfloor + 1$ とするとき、$S^{(t)}_k \equiv S^{(0)}_p + t + c \pmod 3$ となる
- 計算量は $k_i$ の最大値を $K$ として $O(Q \log K)$

## ABC184 D - increment of coins
- どうみてもDPですありがとうございました
- $dp_{i,j,k}$ をいずれかの硬貨が100枚になるまでに必要な操作回数の期待値とおくと、降順で求められる
  - 「条件を満たすまで必要な期待値を降順で求める」というのはABC314Eで得たばかりの知識
  - 2匹目のドジョウはいたらしい
- 具体的には以下の通り
  - $dp_{i,j,k} = x_{i,j,k}(1 + dp_{i + 1, j, k}) + y_{i,j,k}(1 + dp_{i, j + 1, k}) + z_{i,j,k}(1 + dp_{i, j, k + 1})$
    - ただし、$x_{i,j,k}, y_{i,j,k}, z_{i,j,k}$ は金貨 $i$ 枚、銀貨 $j$ 枚、銅貨 $k$ 枚の状態でそれぞれ金貨、銀貨、銅貨を取り出す確率
  - この遷移式を導出するのにナチュラルに手間取った
    - 確率の遷移には慣れているが、期待値の遷移にまだまだ慣れていない
- 誤差について
  - 絶対誤差あるいは相対誤差が $10^{-6}$ まで許されるので、浮動小数点の丸め誤差は気にしなくてよい
  - 減算はないので桁落ちは生じない
  - 加算による情報落ちの可能性を考える
    - $x_{i,j,k}$ の最小値は $x_{1,99,99} = 1/199 \approx 0.05$
      - もちろん $y_{i,j,k}, z_{i,j,k}$ も同様
    - 操作回数は最低でも1回は必要であり、最大でも295回（$A=B=C=1$ のとき）であるから、$1 \leq dp_{i,j,k} \leq 295$
    - よって加算の各オペランドは最大でも4桁差なので情報落ちは生じない

## ABC073 D - joisino's travel
- $R \leq 8$ であり、$8! = 40320$ なので訪れる順に関しては`next_permutation()`による全探索でいけそう
- Warshall-Floyd法で全頂点間の距離を求めておけば楽
  - $\Theta (N^3)$ だが $N \leq 200$ なので余裕で間に合う
- 計算量は $O(\max \{ R!, N^3 \})$

## ABC151 E - Max-Min Sums
- $f$ の線形性より、$A_i$ が $\max S$ および $\min S$ として選ばれる回数が分かれば解が求まる
- $i \geq K$ のとき $\max S = A_i$ となるような $S$ の選び方は ${}_{i-1}C_{K-1}$ 通り
- $i \leq n - K + 1$ のとき $\min S = A_i$ となるような $S$ の選び方は ${}_{N-i}C_{K-1}$ 通り
  - これは $i \geq k$ のとき $\min S = A_{n + 1 - i}$ となるような $S$ の選び方は ${}_{i-1}C_{K-1}$ 通りと言い換えられる
- よって $\sum_{i = K}^{N} {}_{i-1}C_{K-1}(A_i - A_{N + 1 - i})$ を求めればよい
- 問題となるのは ${}_{i-1}C_{K-1}$ だが、$i = K$ のとき ${}_{i-1}C_{K-1} = {}_{K-1}C_{K-1} = 1$ であり、$i > K$ において ${}_{i-1}C_{K-1} = {}_{i-2}C_{K-1} \cdot (i-1)/(i-K)$ であるから、ループ中で更新することにより $O(1)$ で計算できる
- 数学的考察はきちんとできたが、時間がかかりすぎ…
  - 植木算的要素をすぐに処理できる人間になりたい

## ABC119 D - Lazy Faith
- 地点 $x_i$ より東にある神社に関して、地点 $x_i$ に最も近い神社以外を訪れるのは明らかに損
  - 西方向も同様であり、もちろん寺についても同様である
- よって以下の4つが分かれば解がわかる
  - 地点 $x_i$ より東にある最も近い神社までの距離 $R_1$
  - 地点 $x_i$ より東にある最も近い寺までの距離 $R_2$
  - 地点 $x_i$ より西にある最も近い神社までの距離 $L_1$
  - 地点 $x_i$ より西にある最も近い寺までの距離 $L_2$
- 考えられる距離は以下の4つで、これらの最小値が解になる
  - 東にある神社と東にある寺を訪れる場合、$\max\{R_1, R_2\}$
  - 東にある神社と西にある寺を訪れる場合、$R_1 + L_2 + \min\{R_1, L_2\}$（第3項は折り返すために必要）
  - 西にある神社と西にある寺を訪れる場合、$\max\{L_1, L_2\}$
  - 西にある神社と東にある寺を訪れる場合、$L_1 + R_2 + \min\{L_1, R_2\}$（第3項は折り返すために必要）
- それぞれのクエリについて、地点 $x_i$ より東に神社or寺が存在すれば $R_1, R_2$ は`lower_bound()`ですぐに求まり、$L_1, L_2$ に関してもイテレータを1つ戻すことで地点 $x_i$ より西に神社or寺が存在すれば $L_1, L_2$ もすぐに求まる
  - 「存在すれば」の部分が面倒くさいので、ここでは番兵法を用いる
    - すなわち、道路の東端より東（$x \gt 10^{10}$）および西端より西（$x < 0$）に神社と寺が存在するようにすれば場合分けが不要になる
      - ただし解に影響を及ぼさないように距離は十分に（$\gt 10^{10}$）空ける
- 計算量は $O(Q \log \max \{A, B\})$
- 4通りの場合分けも番兵法もすぐに思いついてサクサク解けた
  - いつもこのくらいのスピードだといいんだけどねぇ…

## ABC046 C - AtCoDeerくんと選挙速報
- $i$ 回目における2人の実際の得票数は整数 $k_i$ を用いて $k_iT_i, k_iA_i$ と表せる
- 得票数が減らないことから、$k_{i+1}T_{i+1} \geq k_iT_i, \ k_{i+1}A_{i+1} \geq k_iA_i$ が成り立つ
  - これを変形して、$k_{i+1} \geq k_iT_i / T_{i+1}, \ k_{i+1} \geq k_iA_i / A_{i+1}$
    - よって $k_{i+1}$ が整数であることから $k_{i+1} \geq \max \{ \lceil k_iT_i / T_{i+1} \rceil, \lceil k_iA_i / A_{i+1} \rceil \}$ となる
      - 求めるものが最小であることから $k_{i+1} = \max \{ \lceil k_iT_i / T_{i+1} \rceil, \lceil k_iA_i / A_{i+1} \rceil \}$ と確定できる。あとはこれをループで求めるだけ
- 計算量は $O(N)$

## ABC126 E - 1 or 2
- やたらとややこしいが、要するに $A_{X_i}$ がわかれば $A_{Y_i}$ もわかる構造（逆も然り）
- よって2頂点 $X_i, Y_i$ 間に辺を張り、連結成分の個数を答えればOK
- 計算量は $O(N+M)$
- この問題緑色の間違いじゃないのか…？

## エイシング プログラミング コンテスト 2020 D - Anything Goes to Zero
- $\textrm{popcount}(n) \leq \lfloor \log_2{n} \rfloor + 1$ であるから、$f$ を適用する毎に $n$ は小さくなり、かつだいたい $\log_2{n}$ 回の操作で $0$ になりそう
- $f(X_i) \leq N$ なので1回の操作で $n \leq N$ となるから、あらかじめ $i (1 \leq i \leq N)$ に対して $f(i)$ を計算したテーブルを用意しておけばあとはこのテーブルを引きまくればOK
- よってあとは初回の $f(X_i)$ に注力するのみ
- 各 $X_i$ に対して毎回 $f(X_i)$ を一から計算していては $O(N^2)$ で`TLE`なので工夫が必要
  - まず、$\textrm{popcount}(X_i)$ は $\textrm{popcount}(X)+1, \textrm{popcount}(X)-1$ のいずれかである
    - 以下これを順に $p_1, p_2$ とする
  - $X_i = X \oplus 2^{N-i}$ すなわち $X_i = X + 2^{N-i}$ または $X_i = X - 2^{N-i}$ であるから、あらかじめ $i (1 \leq i \leq N)$ に対して $2^i \bmod p_1, \ 2^i \bmod p_2$ および $X \bmod p_1, \ X \bmod p_2$ を計算しておけば $O(1)$ で $f(X_i)$ を求められる
- 以上により $O(N \log N)$ で全ての解が求まる。…のだが
- コーナーケースの処理に手間取る
  - まず $\textrm{popcount}(X) = 0$ すなわち $X = 0$ のとき
    - 必ず $\textrm{popcount}(X_i) = 1$ となるので全ての $i$ に対して解は $1$
  - 次に $\textrm{popcount}(X) = 1$ のとき
    - $X$ の上から $i$ 桁目のビットが $1$ のときはそもそも $X_i = 0$ となるので解は $0$
    - $p_1$ のほうは普通に使えるのに対し、$p_2 = 0$ より $2^i \bmod p_2$ などは0除算エラーになるため場合分けで除ける
      - ここを力技で分けたがもっとスムーズな書き方はなかったものか…
- 途中に提出した解答が見事に`AC`と`TLE`と`RE`と`WA`が混ざっていて噴いた
  - これを一発で`AC`する人の思考回路を是非言語化していただきたいものである

## [ABC281 E - Least Elements](https://atcoder.jp/contests/abc281/tasks/abc281_e)
- `multiset`で管理して、$A_i$ 番目を削除して $A_{M + i - 1}$ 番目を挿入すればいいことはわかったが
  - 対象となる $K$ 個のほうだけを`multiset`に突っ込んでいたのでそこの判断をどうすればいいのかわからなかった
    - （公式解説を見る）対象にならない $M-K$ 個も`multiset`で管理すればよかったのか…
- STLの計算量を整理したい…

## [ABC190 F - Shift and Inversions](https://atcoder.jp/contests/abc190/tasks/abc190_f)
- 2重ループでゴリ押しで転倒数を求めるのは $O(N^2)$ で勿論`TLE`
- 何か良いアルゴリズムがないか検索したところ、Binary Indexed Treeを使えば $O(N \log N)$ にできるようだ
  - 以下のページを参考にした。感謝。
    - [Binary Indexed Tree (BIT) 総まとめ！区間加算や二次元BITまで](https://algo-logic.info/binary-indexed-tree/)
    - [転倒数    [いかたこのたこつぼ]](https://ikatakos.com/pot/programming_algorithm/dynamic_programming/inversion)
- 添え字には気を付けよう（1敗）
- $k = k_1$ のときの数列 $B_{k_1}$ と $k = k_1 + 1$ のときの数列 $B_{k_1 + 1}$ を比べると
  - $B_{k_1 + 1}$ は $B_{k_1}$ の初項 $a_{k_1}$ を末項に移したものになる
    - $a_{k_1}$ が初項でなくなることで減少する転倒数は $a_{k_1}$
    - $a_{k_1}$ が末項に来ることで増加する転倒数は $N - 1 - a_{k_1}$
  - すなわち、$B_{k_1 + 1}$ の転倒数は $B_{k_1}$ の転倒数に $N - 1 - 2a_{k_1}$ を加えたものとなる
  - よって $k \geq 1$ における $B$ の転倒数はそれぞれ $O(1)$ で求まる
    - ここの考察は自力ですぐに思いついたので、あとはBITの扱いに慣れなければ…

## [ABC106 D - AtCoder Express 2](https://atcoder.jp/contests/abc106/tasks/abc106_d)
- 1次元累積和、余事象などいろいろ考えた挙句…
  - 2次元累積和なら上手くいくのではないかと考える
- $a_{i,j}$ をちょうど区間 $[i, j]$ を走る列車の数とし、$2 \leq i \leq N+1$ および $2 \leq j \leq N+1$ に対し $S_{i,j}$ を 範囲 $[1, i) \times [1, j)$ における $a_{i,j}$ の総和とすると
  - 範囲 $[l, r] \times [l, r]$ における $a_{i,j}$ の総和は $S_{r+1, r+1} - S_{l, r+1} - S_{r+1, l} + S_{l, l}$ と表せる
- よって各クエリの解は $S_{q_i + 1, q_i + 1} - S_{p_i, q_i + 1} - S_{q_i + 1, p_i} + S_{p_i, p_i}$ となる
- 計算量は $O(\max \{ N^2, Q \})$
- 2次元累積和のメモ：
  - 前処理：$S_{i+1,j+1} = a_{i,j} + S_{i+1,j} + S_{i,j+1} - S{i,j}$
  - $[l, r) \times [t, b)$ の和は $S_{r,b} - S_{l,b} - S_{r,t} + S_{l,t}$

## [ABC267 E - Erasing Vertices 2](https://atcoder.jp/contests/abc267/tasks/abc267_e)
- コストが小さいほうから操作するのがよさそうと思いつつも、正直わからなかったので解説をチラ見
  - こういうときこそ`priority_queue`の出番！
- ただしコストが途中で更新されるのでそこをどうするのか
  - 「更新」をやめて新たなコストを設定してキューに突っ込むようにする
    - その代わりに、古いほうで操作をしないように操作済かどうかをわかるようにする
      - 操作をする頂点に対し $A_i = 0$ とすることで判別するようにした

## [ABC273 E - Notebook](https://atcoder.jp/contests/abc273/tasks/abc273_e)
- ノートの各ページにいちいち配列の内容を書き込んでいては間に合わないが
  - `LOAD`によって $A$ の内容が大幅に書き換わる可能性があるので、単純に配列で $A$ を保持しても解けない
  - すなわち $A$ の最新の内容と過去の内容を同時に保持する必要がある
- 問題の仕様から $A$ の途中のみが書き換わることはないので、$A_i$ と $A_{i+1}$ を辺で結ぶグラフを作ると木になる
  - この木 $G$ と今どの頂点に注目しているかを管理する変数 $c$ があれば問題を解くことができる
  - 具体的には以下
    - $G$ の初期状態を唯一の頂点 $V_0 = -1$ を持つグラフとし、$c = 0$ とする
    - 配列 $B$ を用意し、全ての項を $0$ とする
    - 順番にクエリを処理する
      - クエリが`ADD x`の場合
        - $G$ に新たな頂点 $V_i = x$ を追加し、$V_c$ と $V_i$ を新たな辺で繋ぐ
        - $c \gets i$ とする
        - $x$ を出力する
      - クエリが`DELETE`の場合
        - 頂点 $V_c$ の親 $V_p$ を用いて $c \gets p$ とする
        - $V_p$ を出力する
      - クエリが`SAVE y`の場合
        - $B_y \gets c$ とする
        - $V_c$ を出力する
      - クエリが`LOAD z`の場合
        - $c \gets B_z$ とする
        - $V_c$ を出力する
  - ただし、実際の実装に関しては $B$ を配列にすると`MLE`になるので、代わりに`unordered_map`を使っている

## [ABC114 D - 756](https://atcoder.jp/contests/abc114/tasks/abc114_d)
- 自然数 $n$ の正の約数の個数は、相異なる素数 $p_1, p_2, \dots p_m$ と正整数列 $\{ a_m \}$を用いて $\displaystyle n = \prod_{i = 1}^m p_i^{a_i}$ と表せるとき、$\displaystyle \prod_{i = 1}^m (a_i + 1)$ 個と求められる
  - 要するに $n$ の素因数分解ができれば良い
  - このあたりは大学入試数学で必須の知識なので助かった
- $N!$ の素因数分解の結果は $N$ 以下の全ての自然数の素因数分解の積であることから、$2$ から $N$ までを順に素因数分解すればよい
  - 普段は迂闊にやると計算量で死ぬ素因数分解だが、今回は $N \leq 100$ なので余裕
- $\displaystyle N! = \prod_{i = 1}^m p_i^{a_i}$ と表すと、$N!$ のあらゆる正の約数は全ての $i$ に対し $b_i \leq a_i$ となる非負整数列を用いて $\displaystyle \prod_{i = 1}^m p_i^{b_i}$ と表せる
  - あとは $\displaystyle \prod_{i = 1}^m (b_i + 1) = 75$ となるものを探せばよい
    - $p_i$ が相異なる素数であることから非負整数列 $\{ b_m \}$ が完全に一致しなければ必ず別の数になることが保証される
  - 具体的には $75 = 25 \cdot 3, 15 \cdot 5, 5 \cdot 5 \cdot 3$ より以下
    - 非負整数列 $\{ b_m \}$ に $74$ がちょうど1個含まれ、他は全て $0$
    - 非負整数列 $\{ b_m \}$ に $24$ と $2$ がちょうど1個ずつ含まれ、他は全て $0$
    - 非負整数列 $\{ b_m \}$ に $14$ と $4$ がちょうど1個ずつ含まれ、他は全て $0$
    - 非負整数列 $\{ b_m \}$ に $4$ がちょうど2個、および $2$ がちょうど1個含まれ、他は全て $0$
  - 愚直に多重ループで数えられるので、計算量は $N$ 以下の素数の個数を $M$ として $O(\max \{ N \log N, M^3 \})$

## [ABC154 E - Almost Everywhere Zero](https://atcoder.jp/contests/abc154/tasks/abc154_e)
- 愚直に組み合わせで数えようとするも、上から数桁が $N$ と一致するパターンがややこしくて詰む
- DPも考えたが3要素目（$N$ 以下であることが確定しているかどうか）を思いつかず撃沈
- コードは公式解説の要点だけを見て書いたもの
  - ユーザー解説を見るにDPの更新の仕方は様々のようだ
- それにしてもDP遷移式を考えるのが遅い。もっと慣れが必要か

## [ABC306 E - Best Performances](https://atcoder.jp/contests/abc306/tasks/abc306_e)
- 公式解説をチラ見すると
  - 「ABC281 E - Least Elements」でやったやつと同じやんけ！
    - この鳥頭である
- なお先に $A_{X_i}$ を削除し後から $Y_i$ を突っ込む方針だと $K = 1$ のとき大きいほう $K$ 個の集合 $L$ が一瞬空になり、さらに $Y_i$ をどちらの集合に突っ込むべきかをイテレータ`multiset::begin()`の指す要素を用いて判断すると`WA`となる
  - なんとも絶妙なやらかし
  - 空のコンテナに対する`begin()`は`end()`と等しく、`end()`の指す要素は不正な範囲になる
  - 先に $Y_i$ を突っ込んで後から $A_{X_i}$ を削除すれば $L$ が空になることがないので避けられる
- 計算量は $O(Q \log K(N-K))$

## [ABC091 C - 2D Plane 2N Points](https://atcoder.jp/contests/abc091/tasks/arc092_a)
- 二部グラフの最大マッチング問題
- [二部グラフのマッチング    [いかたこのたこつぼ]](https://ikatakos.com/pot/programming_algorithm/graph_theory/bipartite_matching)を参考に増大路を検索するアルゴリズムで書いた。感謝
  - これの計算量は頂点数を $V$ 、辺数を $E$ として $O(VE)$
- 公式解説曰く貪欲法でも行けるらしいが、まず気づかん…

## [ABC220 F - Distance Sums 2](https://atcoder.jp/contests/abc220/tasks/abc220_f)
- LCA（最小共通祖先）などを考えたがどう考えても計算量が $O(N^2)$ 以上になり間に合わない
  - 後学のためにLCAのリンク：[最小共通祖先 [いかたこのたこつぼ]](https://ikatakos.com/pot/programming_algorithm/graph_theory/lowest_common_ancestor)
- （公式解説）部分木のサイズがキーになる問題だった
- 部分木のサイズの求め方メモ：
    1. 整数列 $\{s_n\}$ の全ての項を1（自身のサイズ）で初期化する
    1. 帰りがけ順で子のサイズ $s_i$ の全てを自身のサイズに加える
        - 帰りがけ順と言っても、全ての子のDFSを呼び出すループが終わった後ではなく、それぞれの子のDFSを呼び出した直後にその子のサイズを加えるようにすれば余計なループが不要になる
- なお`accumulate()`の引数に`LL`をつけ忘れて1時間以上を溶かす

## [ABC235 E - MST + 1](https://atcoder.jp/contests/abc235/tasks/abc235_e)
- メモ：最小全域木のつくりかた
    1. 頂点のみのUnion-Findを用意する
    1. 辺の全てを重みの昇順でソートする
    1. それぞれの辺に対し、2頂点が連結でなければUnion-Findで繋ぐ
- 以下、$G$ の全ての辺からなる集合を $E$ とする
- 各クエリは辺の集合 $E \cup \{ e_i \}$ に対し、↑の方法で最小全域木を作れば答えられるが
  - この方法では $O(QM \log M)$ となり間に合わない
- （公式解説）複数のクエリを同時に扱ってもそれぞれのクエリの結果に影響を及ぼさないタイプなので、全てのクエリを同時にこなせばよい
  - すなわち $E \cup \{ e_1, e_2, \dots , e_Q \}$ に対し最小全域木を作れば（ただし $e_1, e_2, \dots , e_Q$ は木に加えない）$O((M+Q) \log (M+Q))$ で全てのクエリに答えることができる

## [ABC275 E - Sugoroku 4](https://atcoder.jp/contests/abc275/tasks/abc275_e)
- どうみても2要素DPですありがとうございました
- $dp_{i,j}$ をサイコロ $i$ 回振った後にマス $j$ にいる確率とすれば
  - 解は $\displaystyle \sum_{i = 0}^{K} dp_{i,N}$
  - DP1回あたりの計算量は $O(M)$ でありDPそのものは $NK$ 回更新するので、全体の計算量は $O(NMK)$ で間に合う