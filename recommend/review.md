# AtCoder Problems Recommendation Reivew
AtCoder Problems Recommendationでおすすめされる問題をひたすら解いてひたすらレビューする

※ 添え字は特に記述のない限り1-indexedとする

## ABC174 E - Logs
- 最小化問題すなわち二分探索法
  - 最小値を直接求めるのは難しいが、ある値にすることができるかどうかの判定が容易い場合の鉄板パターン
- めぐる式二分探索法でやってみた

## ABC251 E - Takahashi and Animals
- 行動 $1$ をするDPと行動 $1$ をしないDPに場合分けして考える
- DPそのものを場合分けして2回やる発想はなかった
  - 一応2次元DPまではわかっており、その点は◎
  - DPなんだろうなぁと思いつつ、行動 $1$ をするかどうかで行動 $N$ をするのかどうかが変わるしどうすればええねん…で止まってしまった

## ABC096 D - Five, Five Everywhere
- 素数判定問題
- 当然 ${}_{55}C_5 \simeq 3.5 \times 10^6$ パターンに対して合成数かどうかなんて判定してたら余裕で`TLE`なわけで
  - なのでどの5つを選んでも合成数になるようにしなければならない
    - 5つ足して合成数なら5の倍数を目指すのが最も楽

## ABC264 E - Blackout 2
- 1つずつグラフの辺を削除しながらクエリに答える系の問題
- 逆順にすればUnion-findで辺を追加しながらいけるんじゃね？とすぐにわかったのは◎
  - 発電所と繋ぐ場合は必ず親を発電所にすることで各都市が発電所につながっているか簡単に調べられることにも気づいた
- しかし辺を追加するたびにいちいち全都市に対して発電所が親かどうかを確認してしまい $O(NQ) = O(10^{11})$ で無事`TLE`
  - 正しくは、発電所につながっていないグループのサイズがそのまま新しく電気が通る都市の数になることを利用する。この場合 $O(N + Q)$ のはず…
- Union-findは割とカスタマイズできる（connectの親の選び方、戻り値）ことを覚えておく

## ABC164 D - Multiple of 2019
- ${}_{N}C_2$通りすべてを調べるともちろん`TLE`
- 2019の倍数かどうかを調べる問題なので、余りの遷移をみたい
  - 遷移を1つだけ保持するのではなく、余りごとに個数を記録すべし
- 当然ながら $i < j$ に対し $S_{[i, N]} \equiv S_{[j, N]}$ ならば $S_{[i, j - 1]} \equiv 0 \pmod{2019}$ という数学的考察も大事

## AGC003 B - Simplified mahjong
- **麻雀と聞いて（ｶﾞﾀｯ**
  - 麻雀関連はいろいろコードを書いたことがあったので、考察が楽に捗った
- それでもまさか単に下から貪欲に刻子→順子の順に取るだけだとは思わず、疑心暗鬼で提出したらあっさり`AC`で拍子抜け
  - やっぱり**今の水色は難しすぎる**って！

## ABC198 D - Send More Money
- $10! = 3.6 \times 10^6$ なので全パターン試してもよさそう
- というわけで`next_permutation()`でゴリゴリ回す
  - 文字列の置き換えも含めて $O(N^2 \times N!)$ …のはず（ただし $N = \max \{ |S_1|, |S_2|, |S_3| \}$）

## ABC062 C - Chocolate Bar
- まず、 $H$ か $W$ が3の倍数のときは~~アホになります~~3等分ができる
- そうでなくてもとりあえず縦2回 or 横2回で切れば $S_{\max} - S_{\min} = \min \{ H, W \}$ とできる
- あとは縦→横 or 横→縦の順番で切るパターンを考える
  - いずれの場合も2回目の切断はできる2つのピースの面積を最小にするべきなので、中央（奇数ならほぼ中央）で切る
  - 1回目の切る場所は全探索しても $O(H + W)$ なので問題なし

## ABC089 D - Practical Skill Test
- **計算量は毎回きちんと見積もること**
  - そりゃ全てのクエリで毎回探索してたら $O(HWQ)$ で`TLE`だわな…
- $D$ が共通であることにピンとくることができる体になりたい
  - そして差を求める系の問題には累積和が特効薬

## ABC256 E - Takahashi's Anguish
- 全てのノードにおいて出次数が1なので、1つの連結成分に対し必ずちょうど1個のサイクルが生じる
  - サイクルではない部分に関しては、入次数が0の人からグラフをたどるように渡していけば全員に不満が生じない
  - サイクル部分に関しては、グラフをたどるように渡していけば最後に渡される人にのみ不満が生じる
- よってサイクルごとに最小辺を見つけ、その不満度を合計すれば解になる
- 具体的にはUnion-find木を構築し、根ごとにDFSを回してサイクルを取得、その最小辺のコストを合計した
  - が、提出後にUnion-find木の構築中にサイクルを検出できることに気づく
    - しかも今回は全てのノードの出次数が1なので、サイクル復元も単にforループを1回回すだけで済む…
      - 要するにDFSが大げさすぎる
        - ま、まぁ`AC`したからよしとしましょう（震え声）

## ABC200 D - Happy Birthday! 2
- 以下 $A_i$ は $A_i \bmod 200$ に置き換える
- とりあえず思いついたのはDP
  - `dp[i][k]`: $A$ の先頭 $i$ 個からいくつか選んだ和の200で割った余りが $k$ になるパターンの総数
- DP復元は初挑戦だったが…
  - デバッグの嵐
    - わからなすぎて禁断のテストケース覗き見を敢行
      - $A_i = 0$ のとき、 $A_i$ を選んでも選ばなくても $k$ の遷移元が同じなので区別がつかず、 $B$ と $C$ で同じ選択をしてしまっていた
        - 復元のときに $A_i = 0$ について別個に処理することで対処
      - **普通にオーバーフロー**
        - DPの値は2以上ならば差はないので、既に2以上のときは（経路復元用のほうも含めて）更新しないようにした
- （公式解説）ここで鳩の巣原理はカッコよすぎる

## ABC308 F - Vouchers
- 間違った貪欲法をしてしまい行方不明に
  - なぜか $P_i \geq L_j$ となる最小の $j$ （ただし、同じ $L_j$ のクーポンが複数ある場合は $D_j$ が最も大きいもの）のクーポンを選んで使っていた
- もちろん正しくは $P_i \geq L_j$ となるクーポン $j$ のうち、最も $D_j$ が大きいものを選択する必要がある
  - ただし実装を間違うと余裕で`TLE`なのでさらなる考察が要る
    - $A_i$ と $L_j$ をそれぞれ昇順に並べた場合、$i$ が増えるとともに使えるクーポン $j$ が $0$ から順番に増えていく
      - 順番に増えるというのがポイントで、使えるクーポンを探索する必要がない（どこまで使えるのかを記録するだけでOK）
    - 一方で使うクーポンはその時点で最も $D$ が大きいものになる
    - ここでクーポンのデータを2重で持つと計算量を減らせる
      - まずはクーポン全体をソートされた配列で持つ
      - 次にその時点で使えるクーポンを管理する`priority_queue`を作る
        - これによりその時点で $D$ が最大になるクーポンが $O(1)$ で選べるばかりか、使ったクーポンを削除するのも $O(1)$ でいいことずくめ
- 「全体から検索」が計算量的にきつそうなら「全体→今候補になるもの→検索」というクッションを作る！

## ABC300 E - Dice Product 3
- $\bmod \ 998244353$ での割り算を計算する術がない！
  - もちろんAtCoder Libraryを使ってもよかったのだが、後学のために自作した
    - ガバいテストケースも作ってちゃんとテストを通したのでヨシ！~~（現場猫案件ではないことを祈る）~~
    - 忘れたころにやってくるフェルマーの小定理さん：「整数 $a$ 、素数 $p$ に対し $a^{p - 1} \equiv 1 \pmod p$」
- 計算は例によってDP
  - $dp_{i,j,k}$ を $x = 2^i3^j5^k$ になる確率と定義
    - このとき $dp_{i,j,k} = \frac{1}{6}dp_{i,j,k} + \frac{1}{6}dp_{i-1,j,k} + \frac{1}{6}dp_{i,j-1,k} + \frac{1}{6}dp_{i-2,j,k} + \frac{1}{6}dp_{i,j,k-1} + \frac{1}{6}dp_{i-1,j-1,k}$
      - ただし $i = 1,2$ or $j = 1$ or $k = 1$ のときは添え字が0以下になる項は $0$ として扱う
    - 変形して $dp_{i,j,k} = \frac{1}{5}dp_{i-1,j,k} + \frac{1}{5}dp_{i,j-1,k} + \frac{1}{5}dp_{i-2,j,k} + \frac{1}{5}dp_{i,j,k-1} + \frac{1}{5}dp_{i-1,j-1,k}$
    - 計算量は $O((\log N)^3)$ なので問題なし
    - DPの更新順も特に気を使う必要がなく楽に実装
- サイコロの積に関する問題は大学入試数学でも割と見るため、すぐに $2^i3^j5^k$ がキーになると気づけた
- なお確率が $0$ となる条件をしくじって`WA`を喰らった模様
  - 相変わらず詰めが甘い…

## ARC052 B - 円錐
- **問題文が分かりづれぇ！**
  - 「いずれか」ではなく「すべての」とかにすべきだと思う
  - ~~というかこいつが水色なのはこの問題文のせいなのでは…？~~
- 円錐の底面 $x$ 座標と高さが整数であるから、$V_x$ を各円錐の区間 $[x, x+1]$ の部分における体積の合計と置いて計算ができる
  - 計算量は $O(NH_i) = O(10^6)$ なので十分に余裕がある
- あとは各クエリについて $\sum_{x = A_i}^{B_i - 1} V_x$ を求めるだけ
  - 本当は累積和を使うべきだけど、そのまま愚直に計算しても9msで通った

## ABC196 D - Hanjo
- 探索順でしくって`WA`
- 下手にDP探索とかやるからこうなる
  - 単なるDFSで良かった件について
- まぁビット列での管理はすぐに思いついたのでそこはよしとしましょう…
- $HW \leq 16$ という超親切設計なので計算量では悩まなくてよし

## ABC014 C - AtColor
- ABCのC問題で（試験管とはいえ）水色だと！？
- しばらく考えて座標圧縮を試みるも1つのテストケースがギリギリ通らず`TLE`
  - 座標圧縮後に愚直にカウントしてしまったのが原因
- 区間 $[L_i, R_i]$ がたくさん与えられるとき、 整数 $x$ を含む区間の個数を高速に調べるには以下の方法を取ればよい
  - 配列 $A$ を全て0で初期化する
  - 全ての区間に対して $A_{L_i}$ に $1$ を加え、 $A_{R_i + 1}$ から $1$ を引く
  - $A$ の累積和 $S$ を作れば、 $S_x$ が $x$ を含む区間の個数になる。
- むしろ↑のアプローチをとれば座標圧縮はいらなかったっぽい
- 前にやったはずなんだけど忘れてますねぇ…

## 天下一プログラマーコンテスト2013予選B B - 天下一後入れ先出しデータ構造
- もちろん`stack`を使えばよいのだが $N$ や $L$ が大きくそのままでは`TLE`と予想できる
- データ入力の仕様からして同じ数字が何個も並ぶので、`pair`で数字と個数を管理
  - `Pop`がやや複雑になるのと、`Size`に答えるために別にサイズのデータを持つ必要があることに注意すればそれほど難しくはない

## ABC103 D - Islands War
- **区間スケジューリング問題**
- 要望を $b_i$ が小さい順にソートして考える
  - 順に要望を見ていき、満たされていない要望 $i$ に対して橋 $[b_i - 1, b_i]$ をなくしていく
    - 橋 $[b_i - 1, b_i]$ を選ぶのは、最も右の橋をなくすことで同じ $b_i$ の要望の全てに答えることができるから

## ABC183 E - Queen on Grid
- 愚直にDPしてしまい`TLE`
  - 水色がそんな単純なわけがない
- なので累積和を使うが、3方向からの移動を全て累積和にする必要がある
  - 壁について
    - 右方向の移動の場合、壁より右の全てのマスは、壁より左のあらゆるマスから遷移できない
    - すなわち $(x, y)$ が壁の場合、$(x + 1, y)$ の右方向からの累積和は $0$ になる
    - 勿論ほかの方向でも同様

## ABC021 C - 正直者の高橋くん
- グラフの最短経路を求めるアルゴリズムはいくつかあるが、今回はDijkstra法をちょちょいといじる
  - 最短経路のまとめは[最短経路問題の解法まとめ](https://qiita.com/taka256/items/a023a11efe17ab097433)がわかりやすい。感謝。
- 最短経路長を更新するついでに経路数を数える
  - 町 $a$ から町 $i (1 \leq i \leq N)$ への最短経路長を $D_i$、町 $a$ から町 $i$ への最短経路数を $C_i$ とすると
    - 町 $i$ と町 $j$ をつなぐ道路によって $D_j$ が更新される場合、$C_j \gets C_i$ とする（最短経路が完全に更新される）
    - 町 $i$ と町 $j$ をつなぐ道路が存在して $D_j = D_i + 1$ が成り立つ場合、$C_j \gets C_j + C_i$ とする（最短経路と同じ長さの経路が他にもある）

## ABC191 E- Come Back Quickly
- 多重辺について、同じ向きで所要時間のより大きい道は明らかに不要
- それぞれの町間の最小所要時間（行けない場合は`INF`）を求められればあとは $O(N^2)$ でいけそう
- 制限3秒ならWarshall-Floyd法で行けるかと思ったが見事に`TLE`
  - 隣接行列を使ったのもダメだったか
- **辺の数が少なければ全頂点についてDijkstra法でも充分早い**
  - Dijkstra法を使う場合は自己ループ辺は邪魔なので別に管理しておく
  - 各頂点に対してDijkstra法を用いて、各頂点間の最小距離 $d_{i, j}$ を全て求める
  - 各 $i$ に対して $d_{i,j} + d_{j ,i}$ の最小値を求め、あらかじめ除けておいた自己ループと比べて小さいほうを出力する

## ABC307 C - Ideal Sheet
- シートのサイズが最大で10なので全探索（$O(H_AW_AH_BW_BH_XW_X)$）で十分間に合う
- シートA, BのそれぞれがシートXと共通部分を持つように左上座標をずらしながらシートXを作れるかどうかを判定する
  - このときシートA, Bの黒マスがシートXからはみ出ていないかの判定をいちいちするのが面倒くさいので、あらかじめシートA, Bの黒マスの左端、右端、上端、下端を求めておいて、はみ出るような箇所はそもそも探索しないようにする
    - 具体的にはシートXの左上座標を原点とし、シートAの黒マスの左端、右端、上端、下端をそれぞれ $A_L, A_R, A_U, A_D$とするとき、シートAの左上の座標 $(i, j)$ に関して $-A_L \leq i \lt W_X - A_R, -A_U \leq j \lt H_X - A_D$ とすれば、シートAの黒マスはシートXからはみ出さない（シートBも同様にする）

## Donutsプロコンチャレンジ2015 B - Tokyo 7th シスターズ
- $N \leq 16$ なのでユニットはビット列で表せるし、$2^{16} = 65536$ なので全探索も余裕
  - ユニットの人数がちょうど9人という点については、整数 $i$ を2進数表記したときの`1`の個数を $c_i$ とするとき、$c_i = 9$ となる $i$ に対してのみ能力値を計算すれば問題ない
- コンボボーナスの組み合わせもビット列で表せば余計な探索は不要になる
  - ユニットを表す整数 $i$ とコンボボーナスの組み合わせを表す整数 $j$ に対し、$c_{i \land j} \geq 3$ ならばコンボボーナスが得られる
  - 示された組み合わせのうち3人いれば大丈夫という点を見落としてグダりかけたのは内緒

## CODE FESTIVAL 2014 Easy C - 身体バランス
- どうみてもDijkstra法ですありがとうございました
- 計算量は $O((N + M)\log N)$？

## ABC248 E - K-colinear Line
- まず、解が`Infinity`になる必要十分条件は $K = 1$
- よって以降 $K \geq 2$ とする
- $N(N - 1)/2$ 本の直線に対して $K$ 個以上の点を通るものをカウントする方針を検討するも
  - 直線のダブりを排除する方法が割と面倒くさいことに気づく
    - 傾きと切片の2パラメータでやろうとすると小数になるので誤差が怖い
    - $ax + by + c = 0$ の形にすれば3パラメータになるが整数で管理できる。この方針はありかもしれなかったが採用はしなかった
- 代わりに各点ごとにその点を通る直線を引いてカウントすることにする
  - 点 $i (1 \leq i \leq N)$ に対し、点 $i$ から点 $j (j \neq i)$ に向かうベクトル $V_{ij}$ を考える
  - ベクトルを以下のように正規化する
      1. ベクトルの各成分を、全成分の最大公約数で割る
          - ただし任意の整数 $n$ に対し $\gcd (n, 0) = n$ とする
      1. $x$ 成分が負の場合は各成分の符号を反転する
  - ↑の正規化により、もともと平行なベクトルは完全に一致するようになる
  - $n - 1$個の正規化されたベクトル $V_{ij}$ の中でちょうど $k - 1$ 個が一致するとき、1本の直線上に $k$ 個の点があることになる
  - これを全ての $i$ に対して行うが、$k$ 個の点が同一直線上にあるとき、$k$ 回重複してカウントしていることになる
    - よって各 $k \geq K$ に対して別個にカウントし、それぞれを $k$ で割ることにより重複を取り除ける
- 正規化されたベクトルのうち何個が一致するのか数えるのにソートを使っているので、計算量は $O(N^2\log N)$

## ABC268 D - Unique Username
- $S_i$ の並び替えに関しては`next_permutation()`に丸投げするとして、問題は`_`の数
- $\sum_{i = 1}^N |S_i| = L$ とおくと、余分に追加できる`_`は最大で $16 - L - (N - 1)$ 個である。以下これを $E$ として、
  - 各項が $0$ 以上で合計が $E$ 以下になる $n-1$ 項の数列 $A$ が用意できれば、$A_i$ が $S'_i$ と $S'_{i + 1}$の間に余分に挿入される`_`の個数とすることができる
    - で、これをどうやって作るのか
- こういうときは再帰関数の出番
  - 以下の3つを持つ再帰関数で、
    - $k$
    - $k$ 番目までの $S'_i$ を適当な個数の`_`で繋いだ文字列
    - その時点で余分に挿入できる`_`の個数 $E_k$
  - 次に $S'_{k + 1}$ を繋げるときに余分な`_`の個数を $0$ 以上 $E_k$ 以下で全て探索するようにすればOK
- $T_i$ は`set`に放り込んで`find()`の計算量を $O(\log M)$ にしておく
- $|X| \geq 3$ のような小さい条件を見失わないように注意（1敗）
- 計算量は $O(N! {}_{16-N}C_{N-1} \log M)$

## ARC048 B - AtCoderでじゃんけんを
- レーティングが自分より低い人/高い人の人数は`lower_bound()`と`upper_bound()`に任せればOK
- レーティングが自分と同じ人に関して
  - $O(N^2)$ だと`TLE`の可能性が高いので毎回探索するわけにはいかない
    - よってレーティングをkey、グー・チョキ・パーを出した人がそれぞれ何人いるかをvalueとする`unordered_map`をあらかじめ作っておき、レーティングが同じ人に対する勝敗を $O(1)$ で判断できるようにする
- 計算量は $O(N \log N)$

## ABC242 D - ABC Transform
- $Q \leq 10^5$ より、1回のクエリは多くても対数時間に抑えないと`TLE`になる
  - まぁそもそも長さ $10^{18}$ の文字列なんざまともに相手できないわけで
- 与えられた文字列について、`A, B, C`をそれぞれ`0, 1, 2`に置き換えて考える
- すると $S^{(t)}_{k} = x$ のとき、$S^{(t + 1)}_{2k - 1} \equiv x + 1 \pmod 3, S^{(t + 1)}_{2k} \equiv x + 2 \pmod 3$ となる
- よって $S^{(t)}_{k}$ は $S^{(t - 1)}_{\lceil k / 2 \rceil}$ を見ればわかる
- これを繰り返すことで $S^{(0)}_{k'}$ か $S^{(t')}_1$ までたどり着けば $O(1)$ で文字が何かわかるため、高々64回の計算でクエリに答えることができる
  - 具体的には $k - 1$ の2進数表記における`1`の数を $c$、$p = \lfloor (k - 1) / 2^t \rfloor + 1$ とするとき、$S^{(t)}_k \equiv S^{(0)}_p + t + c \pmod 3$ となる
- 計算量は $k_i$ の最大値を $K$ として $O(Q \log K)$

## ABC184 D - increment of coins
- どうみてもDPですありがとうございました
- $dp_{i,j,k}$ をいずれかの硬貨が100枚になるまでに必要な操作回数の期待値とおくと、降順で求められる
  - 「条件を満たすまで必要な期待値を降順で求める」というのはABC314Eで得たばかりの知識
  - 2匹目のドジョウはいたらしい
- 具体的には以下の通り
  - $dp_{i,j,k} = x_{i,j,k}(1 + dp_{i + 1, j, k}) + y_{i,j,k}(1 + dp_{i, j + 1, k}) + z_{i,j,k}(1 + dp_{i, j, k + 1})$
    - ただし、$x_{i,j,k}, y_{i,j,k}, z_{i,j,k}$ は金貨 $i$ 枚、銀貨 $j$ 枚、銅貨 $k$ 枚の状態でそれぞれ金貨、銀貨、銅貨を取り出す確率
  - この遷移式を導出するのにナチュラルに手間取った
    - 確率の遷移には慣れているが、期待値の遷移にまだまだ慣れていない
- 誤差について
  - 絶対誤差あるいは相対誤差が $10^{-6}$ まで許されるので、浮動小数点の丸め誤差は気にしなくてよい
  - 減算はないので桁落ちは生じない
  - 加算による情報落ちの可能性を考える
    - $x_{i,j,k}$ の最小値は $x_{1,99,99} = 1/199 \approx 0.05$
      - もちろん $y_{i,j,k}, z_{i,j,k}$ も同様
    - 操作回数は最低でも1回は必要であり、最大でも295回（$A=B=C=1$ のとき）であるから、$1 \leq dp_{i,j,k} \leq 295$
    - よって加算の各オペランドは最大でも4桁差なので情報落ちは生じない

## ABC073 D - joisino's travel
- $R \leq 8$ であり、$8! = 40320$ なので訪れる順に関しては`next_permutation()`による全探索でいけそう
- Warshall-Floyd法で全頂点間の距離を求めておけば楽
  - $\Theta (N^3)$ だが $N \leq 200$ なので余裕で間に合う
- 計算量は $O(\max \{ R!, N^3 \})$

## ABC151 E - Max-Min Sums
- $f$ の線形性より、$A_i$ が $\max S$ および $\min S$ として選ばれる回数が分かれば解が求まる
- $i \geq K$ のとき $\max S = A_i$ となるような $S$ の選び方は ${}_{i-1}C_{K-1}$ 通り
- $i \leq n - K + 1$ のとき $\min S = A_i$ となるような $S$ の選び方は ${}_{N-i}C_{K-1}$ 通り
  - これは $i \geq k$ のとき $\min S = A_{n + 1 - i}$ となるような $S$ の選び方は ${}_{i-1}C_{K-1}$ 通りと言い換えられる
- よって $\sum_{i = K}^{N} {}_{i-1}C_{K-1}(A_i - A_{N + 1 - i})$ を求めればよい
- 問題となるのは ${}_{i-1}C_{K-1}$ だが、$i = K$ のとき ${}_{i-1}C_{K-1} = {}_{K-1}C_{K-1} = 1$ であり、$i > K$ において ${}_{i-1}C_{K-1} = {}_{i-2}C_{K-1} \cdot (i-1)/(i-K)$ であるから、ループ中で更新することにより $O(1)$ で計算できる
- 数学的考察はきちんとできたが、時間がかかりすぎ…
  - 植木算的要素をすぐに処理できる人間になりたい

## ABC119 D - Lazy Faith
- 地点 $x_i$ より東にある神社に関して、地点 $x_i$ に最も近い神社以外を訪れるのは明らかに損
  - 西方向も同様であり、もちろん寺についても同様である
- よって以下の4つが分かれば解がわかる
  - 地点 $x_i$ より東にある最も近い神社までの距離 $R_1$
  - 地点 $x_i$ より東にある最も近い寺までの距離 $R_2$
  - 地点 $x_i$ より西にある最も近い神社までの距離 $L_1$
  - 地点 $x_i$ より西にある最も近い寺までの距離 $L_2$
- 考えられる距離は以下の4つで、これらの最小値が解になる
  - 東にある神社と東にある寺を訪れる場合、$\max\{R_1, R_2\}$
  - 東にある神社と西にある寺を訪れる場合、$R_1 + L_2 + \min\{R_1, L_2\}$（第3項は折り返すために必要）
  - 西にある神社と西にある寺を訪れる場合、$\max\{L_1, L_2\}$
  - 西にある神社と東にある寺を訪れる場合、$L_1 + R_2 + \min\{L_1, R_2\}$（第3項は折り返すために必要）
- それぞれのクエリについて、地点 $x_i$ より東に神社or寺が存在すれば $R_1, R_2$ は`lower_bound()`ですぐに求まり、$L_1, L_2$ に関してもイテレータを1つ戻すことで地点 $x_i$ より西に神社or寺が存在すれば $L_1, L_2$ もすぐに求まる
  - 「存在すれば」の部分が面倒くさいので、ここでは番兵法を用いる
    - すなわち、道路の東端より東（$x \gt 10^{10}$）および西端より西（$x < 0$）に神社と寺が存在するようにすれば場合分けが不要になる
      - ただし解に影響を及ぼさないように距離は十分に（$\gt 10^{10}$）空ける
- 計算量は $O(Q \log \max \{A, B\})$
- 4通りの場合分けも番兵法もすぐに思いついてサクサク解けた
  - いつもこのくらいのスピードだといいんだけどねぇ…

## ABC046 C - AtCoDeerくんと選挙速報
- $i$ 回目における2人の実際の得票数は整数 $k_i$ を用いて $k_iT_i, k_iA_i$ と表せる
- 得票数が減らないことから、$k_{i+1}T_{i+1} \geq k_iT_i, \ k_{i+1}A_{i+1} \geq k_iA_i$ が成り立つ
  - これを変形して、$k_{i+1} \geq k_iT_i / T_{i+1}, \ k_{i+1} \geq k_iA_i / A_{i+1}$
    - よって $k_{i+1}$ が整数であることから $k_{i+1} \geq \max \{ \lceil k_iT_i / T_{i+1} \rceil, \lceil k_iA_i / A_{i+1} \rceil \}$ となる
      - 求めるものが最小であることから $k_{i+1} = \max \{ \lceil k_iT_i / T_{i+1} \rceil, \lceil k_iA_i / A_{i+1} \rceil \}$ と確定できる。あとはこれをループで求めるだけ
- 計算量は $O(N)$

## ABC126 E - 1 or 2
- やたらとややこしいが、要するに $A_{X_i}$ がわかれば $A_{Y_i}$ もわかる構造（逆も然り）
- よって2頂点 $X_i, Y_i$ 間に辺を張り、連結成分の個数を答えればOK
- 計算量は $O(N+M)$
- この問題緑色の間違いじゃないのか…？

## エイシング プログラミング コンテスト 2020 D - Anything Goes to Zero
- $\mathrm{popcount}(n) \leq \lfloor \log_2{n} \rfloor + 1$ であるから、$f$ を適用する毎に $n$ は小さくなり、かつだいたい $\log_2{n}$ 回の操作で $0$ になりそう
- $f(X_i) \leq N$ なので1回の操作で $n \leq N$ となるから、あらかじめ $i (1 \leq i \leq N)$ に対して $f(i)$ を計算したテーブルを用意しておけばあとはこのテーブルを引きまくればOK
- よってあとは初回の $f(X_i)$ に注力するのみ
- 各 $X_i$ に対して毎回 $f(X_i)$ を一から計算していては $O(N^2)$ で`TLE`なので工夫が必要
  - まず、$\mathrm{popcount}(X_i)$ は $\mathrm{popcount}(X)+1, \mathrm{popcount}(X)-1$ のいずれかである
    - 以下これを順に $p_1, p_2$ とする
  - $X_i = X \oplus 2^{N-i}$ すなわち $X_i = X + 2^{N-i}$ または $X_i = X - 2^{N-i}$ であるから、あらかじめ $i (1 \leq i \leq N)$ に対して $2^i \bmod p_1, \ 2^i \bmod p_2$ および $X \bmod p_1, \ X \bmod p_2$ を計算しておけば $O(1)$ で $f(X_i)$ を求められる
- 以上により $O(N \log N)$ で全ての解が求まる。…のだが
- コーナーケースの処理に手間取る
  - まず $\mathrm{popcount}(X) = 0$ すなわち $X = 0$ のとき
    - 必ず $\mathrm{popcount}(X_i) = 1$ となるので全ての $i$ に対して解は $1$
  - 次に $\mathrm{popcount}(X) = 1$ のとき
    - $X$ の上から $i$ 桁目のビットが $1$ のときはそもそも $X_i = 0$ となるので解は $0$
    - $p_1$ のほうは普通に使えるのに対し、$p_2 = 0$ より $2^i \bmod p_2$ などは0除算エラーになるため場合分けで除ける
      - ここを力技で分けたがもっとスムーズな書き方はなかったものか…
- 途中に提出した解答が見事に`AC`と`TLE`と`RE`と`WA`が混ざっていて噴いた
  - これを一発で`AC`する人の思考回路を是非言語化していただきたいものである

## [ABC281 E - Least Elements](https://atcoder.jp/contests/abc281/tasks/abc281_e)
- `multiset`で管理して、$A_i$ 番目を削除して $A_{M + i - 1}$ 番目を挿入すればいいことはわかったが
  - 対象となる $K$ 個のほうだけを`multiset`に突っ込んでいたのでそこの判断をどうすればいいのかわからなかった
    - （公式解説を見る）対象にならない $M-K$ 個も`multiset`で管理すればよかったのか…
- STLの計算量を整理したい…

## [ABC190 F - Shift and Inversions](https://atcoder.jp/contests/abc190/tasks/abc190_f)
- 2重ループでゴリ押しで転倒数を求めるのは $O(N^2)$ で勿論`TLE`
- 何か良いアルゴリズムがないか検索したところ、Binary Indexed Treeを使えば $O(N \log N)$ にできるようだ
  - 以下のページを参考にした。感謝。
    - [Binary Indexed Tree (BIT) 総まとめ！区間加算や二次元BITまで](https://algo-logic.info/binary-indexed-tree/)
    - [転倒数    [いかたこのたこつぼ]](https://ikatakos.com/pot/programming_algorithm/dynamic_programming/inversion)
- 添え字には気を付けよう（1敗）
- $k = k_1$ のときの数列 $B_{k_1}$ と $k = k_1 + 1$ のときの数列 $B_{k_1 + 1}$ を比べると
  - $B_{k_1 + 1}$ は $B_{k_1}$ の初項 $a_{k_1}$ を末項に移したものになる
    - $a_{k_1}$ が初項でなくなることで減少する転倒数は $a_{k_1}$
    - $a_{k_1}$ が末項に来ることで増加する転倒数は $N - 1 - a_{k_1}$
  - すなわち、$B_{k_1 + 1}$ の転倒数は $B_{k_1}$ の転倒数に $N - 1 - 2a_{k_1}$ を加えたものとなる
  - よって $k \geq 1$ における $B$ の転倒数はそれぞれ $O(1)$ で求まる
    - ここの考察は自力ですぐに思いついたので、あとはBITの扱いに慣れなければ…

## [ABC106 D - AtCoder Express 2](https://atcoder.jp/contests/abc106/tasks/abc106_d)
- 1次元累積和、余事象などいろいろ考えた挙句…
  - 2次元累積和なら上手くいくのではないかと考える
- $a_{i,j}$ をちょうど区間 $[i, j]$ を走る列車の数とし、$2 \leq i \leq N+1$ および $2 \leq j \leq N+1$ に対し $S_{i,j}$ を 範囲 $[1, i) \times [1, j)$ における $a_{i,j}$ の総和とすると
  - 範囲 $[l, r] \times [l, r]$ における $a_{i,j}$ の総和は $S_{r+1, r+1} - S_{l, r+1} - S_{r+1, l} + S_{l, l}$ と表せる
- よって各クエリの解は $S_{q_i + 1, q_i + 1} - S_{p_i, q_i + 1} - S_{q_i + 1, p_i} + S_{p_i, p_i}$ となる
- 計算量は $O(\max \{ N^2, Q \})$
- 2次元累積和のメモ：
  - 前処理：$S_{i+1,j+1} = a_{i,j} + S_{i+1,j} + S_{i,j+1} - S{i,j}$
  - $[l, r) \times [t, b)$ の和は $S_{r,b} - S_{l,b} - S_{r,t} + S_{l,t}$

## [ABC267 E - Erasing Vertices 2](https://atcoder.jp/contests/abc267/tasks/abc267_e)
- コストが小さいほうから操作するのがよさそうと思いつつも、正直わからなかったので解説をチラ見
  - こういうときこそ`priority_queue`の出番！
- ただしコストが途中で更新されるのでそこをどうするのか
  - 「更新」をやめて新たなコストを設定してキューに突っ込むようにする
    - その代わりに、古いほうで操作をしないように操作済かどうかをわかるようにする
      - 操作をする頂点に対し $A_i = 0$ とすることで判別するようにした

## [ABC273 E - Notebook](https://atcoder.jp/contests/abc273/tasks/abc273_e)
- ノートの各ページにいちいち配列の内容を書き込んでいては間に合わないが
  - `LOAD`によって $A$ の内容が大幅に書き換わる可能性があるので、単純に配列で $A$ を保持しても解けない
  - すなわち $A$ の最新の内容と過去の内容を同時に保持する必要がある
- 問題の仕様から $A$ の途中のみが書き換わることはないので、$A_i$ と $A_{i+1}$ を辺で結ぶグラフを作ると木になる
  - この木 $G$ と今どの頂点に注目しているかを管理する変数 $c$ があれば問題を解くことができる
  - 具体的には以下
    - $G$ の初期状態を唯一の頂点 $V_0 = -1$ を持つグラフとし、$c = 0$ とする
    - 配列 $B$ を用意し、全ての項を $0$ とする
    - 順番にクエリを処理する
      - クエリが`ADD x`の場合
        - $G$ に新たな頂点 $V_i = x$ を追加し、$V_c$ と $V_i$ を新たな辺で繋ぐ
        - $c \gets i$ とする
        - $x$ を出力する
      - クエリが`DELETE`の場合
        - 頂点 $V_c$ の親 $V_p$ を用いて $c \gets p$ とする
        - $V_p$ を出力する
      - クエリが`SAVE y`の場合
        - $B_y \gets c$ とする
        - $V_c$ を出力する
      - クエリが`LOAD z`の場合
        - $c \gets B_z$ とする
        - $V_c$ を出力する
  - ただし、実際の実装に関しては $B$ を配列にすると`MLE`になるので、代わりに`unordered_map`を使っている

## [ABC114 D - 756](https://atcoder.jp/contests/abc114/tasks/abc114_d)
- 自然数 $n$ の正の約数の個数は、相異なる素数 $p_1, p_2, \dots p_m$ と正整数列 $\{ a_m \}$を用いて $\displaystyle n = \prod_{i = 1}^m p_i^{a_i}$ と表せるとき、$\displaystyle \prod_{i = 1}^m (a_i + 1)$ 個と求められる
  - 要するに $n$ の素因数分解ができれば良い
  - このあたりは大学入試数学で必須の知識なので助かった
- $N!$ の素因数分解の結果は $N$ 以下の全ての自然数の素因数分解の積であることから、$2$ から $N$ までを順に素因数分解すればよい
  - 普段は迂闊にやると計算量で死ぬ素因数分解だが、今回は $N \leq 100$ なので余裕
- $\displaystyle N! = \prod_{i = 1}^m p_i^{a_i}$ と表すと、$N!$ のあらゆる正の約数は全ての $i$ に対し $b_i \leq a_i$ となる非負整数列を用いて $\displaystyle \prod_{i = 1}^m p_i^{b_i}$ と表せる
  - あとは $\displaystyle \prod_{i = 1}^m (b_i + 1) = 75$ となるものを探せばよい
    - $p_i$ が相異なる素数であることから非負整数列 $\{ b_m \}$ が完全に一致しなければ必ず別の数になることが保証される
  - 具体的には $75 = 25 \cdot 3, 15 \cdot 5, 5 \cdot 5 \cdot 3$ より以下
    - 非負整数列 $\{ b_m \}$ に $74$ がちょうど1個含まれ、他は全て $0$
    - 非負整数列 $\{ b_m \}$ に $24$ と $2$ がちょうど1個ずつ含まれ、他は全て $0$
    - 非負整数列 $\{ b_m \}$ に $14$ と $4$ がちょうど1個ずつ含まれ、他は全て $0$
    - 非負整数列 $\{ b_m \}$ に $4$ がちょうど2個、および $2$ がちょうど1個含まれ、他は全て $0$
  - 愚直に多重ループで数えられるので、計算量は $N$ 以下の素数の個数を $M$ として $O(\max \{ N \log N, M^3 \})$

## [ABC154 E - Almost Everywhere Zero](https://atcoder.jp/contests/abc154/tasks/abc154_e)
- 愚直に組み合わせで数えようとするも、上から数桁が $N$ と一致するパターンがややこしくて詰む
- DPも考えたが3要素目（$N$ 以下であることが確定しているかどうか）を思いつかず撃沈
- コードは公式解説の要点だけを見て書いたもの
  - ユーザー解説を見るにDPの更新の仕方は様々のようだ
- それにしてもDP遷移式を考えるのが遅い。もっと慣れが必要か

## [ABC306 E - Best Performances](https://atcoder.jp/contests/abc306/tasks/abc306_e)
- 公式解説をチラ見すると
  - 「ABC281 E - Least Elements」でやったやつと同じやんけ！
    - この鳥頭である
- なお先に $A_{X_i}$ を削除し後から $Y_i$ を突っ込む方針だと $K = 1$ のとき大きいほう $K$ 個の集合 $L$ が一瞬空になり、さらに $Y_i$ をどちらの集合に突っ込むべきかをイテレータ`multiset::begin()`の指す要素を用いて判断すると`WA`となる
  - なんとも絶妙なやらかし
  - 空のコンテナに対する`begin()`は`end()`と等しく、`end()`の指す要素は不正な範囲になる
  - 先に $Y_i$ を突っ込んで後から $A_{X_i}$ を削除すれば $L$ が空になることがないので避けられる
- 計算量は $O(Q \log K(N-K))$

## [ABC091 C - 2D Plane 2N Points](https://atcoder.jp/contests/abc091/tasks/arc092_a)
- 二部グラフの最大マッチング問題
- [二部グラフのマッチング    [いかたこのたこつぼ]](https://ikatakos.com/pot/programming_algorithm/graph_theory/bipartite_matching)を参考に増大路を検索するアルゴリズムで書いた。感謝
  - これの計算量は頂点数を $V$ 、辺数を $E$ として $O(VE)$
- 公式解説曰く貪欲法でも行けるらしいが、まず気づかん…

## [ABC220 F - Distance Sums 2](https://atcoder.jp/contests/abc220/tasks/abc220_f)
- LCA（最小共通祖先）などを考えたがどう考えても計算量が $O(N^2)$ 以上になり間に合わない
  - 後学のためにLCAのリンク：[最小共通祖先 [いかたこのたこつぼ]](https://ikatakos.com/pot/programming_algorithm/graph_theory/lowest_common_ancestor)
- （公式解説）部分木のサイズがキーになる問題だった
- 部分木のサイズの求め方メモ：
    1. 整数列 $\{s_n\}$ の全ての項を1（自身のサイズ）で初期化する
    1. 帰りがけ順で子のサイズ $s_i$ の全てを自身のサイズに加える
        - 帰りがけ順と言っても、全ての子のDFSを呼び出すループが終わった後ではなく、それぞれの子のDFSを呼び出した直後にその子のサイズを加えるようにすれば余計なループが不要になる
- なお`accumulate()`の引数に`LL`をつけ忘れて1時間以上を溶かす

## [ABC235 E - MST + 1](https://atcoder.jp/contests/abc235/tasks/abc235_e)
- メモ：最小全域木のつくりかた
    1. 頂点のみのUnion-Findを用意する
    1. 辺の全てを重みの昇順でソートする
    1. それぞれの辺に対し、2頂点が連結でなければUnion-Findで繋ぐ
- 以下、$G$ の全ての辺からなる集合を $E$ とする
- 各クエリは辺の集合 $E \cup \{ e_i \}$ に対し、↑の方法で最小全域木を作れば答えられるが
  - この方法では $O(QM \log M)$ となり間に合わない
- （公式解説）複数のクエリを同時に扱ってもそれぞれのクエリの結果に影響を及ぼさないタイプなので、全てのクエリを同時にこなせばよい
  - すなわち $E \cup \{ e_1, e_2, \dots , e_Q \}$ に対し最小全域木を作れば（ただし $e_1, e_2, \dots , e_Q$ は木に加えない）$O((M+Q) \log (M+Q))$ で全てのクエリに答えることができる

## [ABC275 E - Sugoroku 4](https://atcoder.jp/contests/abc275/tasks/abc275_e)
- どうみても2要素DPですありがとうございました
- $dp_{i,j}$ をサイコロ $i$ 回振った後にマス $j$ にいる確率とすれば
  - 解は $\displaystyle \sum_{i = 0}^{K} dp_{i,N}$
  - DP1回あたりの計算量は $O(M)$ でありDPそのものは $NK$ 回更新するので、全体の計算量は $O(NMK)$ で間に合う

## [エイシング プログラミング コンテスト 2019 C - Alternating Path](https://atcoder.jp/contests/aising2019/tasks/aising2019_c)
- 全マスを頂点に持ち、隣り合うマスで色の異なる頂点間のみに辺を張ったグラフ $G$ を考えれば
  - その連結成分の任意の黒頂点と白頂点は題意を満たす移動ができる
    - よって各連結成分ごとに黒頂点の数と白頂点の数の積を求め、その和を答えればよい
- Union-Findを改造して黒頂点と白頂点の数を数えられるようにしたが
  - 途中でグラフの構造が変わるわけではないのでそもそも単にDFSでよかった

## [ARC141 B - Increasing Prefix XOR](https://atcoder.jp/contests/arc141/tasks/arc141_b)
- 以下、$x$ の最上位ビットを $\mathrm{msb}(x)$ と表す
- 一般に自然数 $a, b \ (a \lt b)$ に対して $a \lt a \oplus b \Leftrightarrow \mathrm{msb}(a) \lt \mathrm{msb}(b)$ が成り立つ
  - $\mathrm{msb}(a) = \mathrm{msb}(b)$ だとXORにより最上位ビットが0になってしまうため
- 全ての $i (1 \leq i \lt N)$ に対し $\mathrm{msb}(A_i) \lt \mathrm{msb}(A_{i+1})$ であることを帰納法で示す
    1. $B_1 \lt B_2$ より $A_1 \lt A_1 \oplus A_2 \Leftrightarrow \mathrm{msb}(A_1) \lt \mathrm{msb}(A_2)$
    1. 自然数 $k$ に対して $\mathrm{msb}(A_1) \lt \mathrm{msb}(A_2) \lt \dots \lt \mathrm{msb}(A_k)$ と仮定する
        - このとき $\mathrm{msb}(B_k) = \mathrm{msb}(A_k)$ が成り立つので
            - $B_k \lt B_{k+1} = B_k \oplus A_{k+1} \Leftrightarrow \mathrm{msb}(B_k) \lt \mathrm{msb}(A_{k+1}) \Leftrightarrow \mathrm{msb}(A_k) \lt \mathrm{msb}(A_{k+1})$
    1. 以上により帰納的に $\mathrm{msb}(A_i) \lt \mathrm{msb}(A_{i+1})$ が示せた
- これにより $N \gt \mathrm{msb}(M) + 1$ のときは条件を満たす数列 $A$ は存在しないことがわかる
- あとは $dp_{i,j}$ を 「$\mathrm{msb}(A_i) = j$ となるような数列 $(A_1, A_2, \dots, A_i)$ の場合の数 $\pmod{998244353}$」として以下のように数えるのみ
    - $c_j$ を $\mathrm{msb}(x) = j$ かつ $x \leq M$ を満たす自然数 $x$ の個数とする
    - 初期値：$dp_{1,j} = c_j$
    - 更新式：$\displaystyle dp_{i,j} = \sum_{k = 1}^{j - 1} c_j dp_{i-1,k}$
- 計算量は $O(\min \{ N, \log M \}(\log M)^2)$

## [ABC261 E - Many Operations](https://atcoder.jp/contests/abc261/tasks/abc261_e)
- 純粋に全操作を行うと $O(N^2)$ で間に合わない
- ここでポイントになるのは、各操作はビット毎に独立であるという点
  - すなわち、操作 $1, 2, \dots i$ を順に行って得られる新たな $X$ の2進数表記での下から $j$ 桁目は、操作前の $X$ の2進数表記での下から $j$ 桁目に依存する
    - よって、各ビットごとに初期値の $j$ ビット目が $0$ および $1$ であるときに操作 $1, 2, \dots i$ を順に行って得られる数の $j$ ビット目 $b_{0,i,j}, b_{1,i,j}$ を求めれば、新たな $X$ の各桁がそれぞれ $O(1)$ で求まる
- 具体的には以下の通り
    1. $C_0 = 0, C_1 = 2^{30} - 1, X = C$ とする
    1. $i (1 \leq i \leq N)$ について以下を順に行う
        1. $C_0, C_1$ のそれぞれに操作 $i$ を行う
        1. $j (1 \leq j \leq 30)$ について以下を順に行う
            - $X$ の $j$ ビット目を、それが $0$ なら $C_0$ の $j$ ビット目に、$1$ なら $C_1$ の $j$ ビット目に書き換える
        1. $X$ を出力する
- 計算量は $O(N)$
- 後から解説を見て、新たな $X$ を得るのにわざわざループでビットごとに計算せずとも $(X \ \mathrm{and} \ C_1) \ \mathrm{or} \ ((X \ \mathrm{xor} \ 2^{30} - 1) \ \mathrm{and} \ C_0)$ で良かったことに気づく
  - 定数倍とはいえかなり計算量が変わるので反省

## [ABC120 D - Decayed Bridges](https://atcoder.jp/contests/abc120/tasks/abc120_d)
- 「順番に辺を削除しながらクエリに答える」＝「逆順にして順番にUnion-Findで辺を追加しながらクエリに答える」
  - これは前にどこかでやったパターン
- 逆順にすれば、最初は全ての橋がないので不便さは $_{N}C_2 = \frac{1}{2}N(N-1)$ であり
  - 橋 $i$ を繋ぐ際に、島 $A_i$ と $B_i$ が異なる連結成分に存在すればそれらのサイズの積の分だけ不便さが減っていく
- 計算量は $O(M \alpha(N)) \simeq O(M)$

## [ABC187 E - Through Path](https://atcoder.jp/contests/abc187/tasks/abc187_e)
- クエリごとに全ての頂点を1個ずつ書き換えるのは $O(QN)$ で勿論`TLE`
- クエリ $i$ において（$t_i = 2$ のときは $a_{e_i}$ と $b_{e_i}$ を入れ替えると）書き換わる頂点は
  - $a_{e_i}$ が $b_{e_i}$ の子の場合は $a_{e_i}$ を頂点とする部分木
  - $a_{e_i}$ が $b_{e_i}$ の親の場合は木全体から $b_{e_i}$ を頂点とする部分木を除いたもの
- よって以下の方針でなんとかなりそう
  - Euler Tourでタイムスタンプを求めて部分木の頂点がすぐに分かるようにする
  - まとまった範囲に加算をするので累積和を用いて計算量を減らす
- 具体的には以下の通り
    1. 根を起点にDFSを行い、各頂点を初めて通る時刻 $p_i$ と最後に通る時刻 $q_i$ を求める
    1. 長さ $2N$ の整数列 $S$ を用意する（初期値はすべて0とする）
    1. 各クエリ $i$ に対し以下を行う
        1. 頂点 $v, u$ を以下のように定める
            - $t_i = 1$ のとき $v = a_{e_i}, u = b_{e_i}$
            - $t_i = 2$ のとき $v = b_{e_i}, u = a_{e_i}$
        1. 以下の通りに $S$ を更新する
            - $v$ が $u$ の子のとき
                - $S_{p_v}$ に $x_i$ を加え、$S_{q_v}$ から $x_i$ を引く
            - $a_{e_i}$ が $b_{e_i}$ の親のとき
                - $S_{1}, \ S_{q_u}$ に $x_i$ を加え、$S_{p_u}, S_{2N}$ から $x_i$ を引く
    1. $j (2 \leq j \leq 2N)$ に対し、昇順に $S_j \gets S_j + S_{j - 1}$ とする（$S$ の累積和を求める）
    1. 各頂点 $i$ に対し、$S_{p_i}$ を $c_i$ として出力する
- 計算量は $O(N + Q)$

## [ARC142 C - Tree Queries](https://atcoder.jp/contests/arc142/tasks/arc142_c)
- とりあえずすべての $i \ (3 \leq i \leq N)$ に対して $d_{1,i}$ と $d_{2,i}$ を尋ねる
- $d_{1,i}$ の最小値が $2$ の場合
  - 頂点 $1$ が葉であり、その親が頂点 $2$ であることがわかるので、解は $1$ である
  - $d_{2,i}$ の最小値が $2$ の場合も同様である
- $d_{1,i}$ の最小値および $d_{2,i}$ の最小値が $1$ の場合
  - 頂点 $1$ に隣接する頂点で頂点 $2$ に最も近いものを $v$ とする（複数ある場合はどれでも良い）
  - $d_{2,v} \neq 2$ ならば $d_{1,v} + d_{2,v}$ が解になる
  - $d_{2,v} = 2$ の場合は頂点 $1,2$ が隣接しているケースとそうでないケースの区別がつかないので、さらに以下を行う
    - 頂点 $2$ に隣接する頂点で頂点 $1$ に最も近いものを $u$ とする（複数ある場合はどれでも良い）
    - $d_{u,v}$ を尋ねる
      - $d_{u,v} = 3$ ならば、頂点 $1,2$ が並んでいるケースなので解は $1$ である
      - そうでないならば解は $3$ である

## [ABC104 C - All Green](https://atcoder.jp/contests/abc104/tasks/abc104_c)
- 以下 $100i$ 点を付けられた問題の集合をカテゴリ $i$ と呼ぶことにする
- コンプリートボーナスを無視するならカテゴリ番号の大きいほうから貪欲に解けばよい
- $D \leq 10$ よりどのカテゴリをコンプリートするかどうかはビット列で管理できる
- よって以下の方針で解ける
  - $T = \{ 1, 2, \dots, D \}$ の部分集合 $S$ に対して以下を行い、解いた問題数の最小値を解として出力する
      1. $S$ に含まれるカテゴリの問題を全て解く
      2. まだ目標スコアに届かない場合は、まだ解いていないカテゴリ番号の大きいほうから貪欲に解く
          - もちろんコンプリートボーナスも忘れずに
- $T$ の部分集合は $2^D$ 個なので計算量は $O(D2^D)$

## [CODE FESTIVAL 2017 Final C - Time Gap](https://atcoder.jp/contests/cf17-final/tasks/cf17_final_c)
- 以下、高橋君の都市が $0$ 時のタイミングでの各参加者 $i$ の都市における時刻を $T_i \ (-12 \lt T_i \leq 12)$ とする
  - かつ、高橋君を考慮に入れるために $i = 0$ が高橋君を示すものとし、$D_0 = 0$ とする
- $C_t (0 \leq t \leq 12)$ を $D_i = t$ となる相異なる $i$ の個数とおく
- まず、$s$ の最大値が $0$ になるケースを考える
  - $D_i = t \ (0 \lt t \lt 12)$ の場合、$T_i$ としてあり得る値は $t, 24-t$ の2つ 
  - $D_i = 0, 12$ の場合、$T_i$ としてあり得る値はそれぞれ $0, 12$ の1つのみ
  - よって鳩の巣原理より、以下の条件のいずれかを満たす場合は同じ時刻となる参加者の組が必ず存在する
    - $C_0 \geq 2$
    - $C_{12} \geq 2$
    - いずれかの $t$ に対し $C_t \geq 3$
- ↑以外の場合において
  - この時点で $C_0 = 1, \ C_{12} \leq 1, \ C_t \leq 2$ が確定している
  - $C_{12} = 1$ ならば該当する参加者 $i$ に対し $T_i = 12$ を割り当てる
  - $C_t = 2$ ならば該当する参加者 $i, j$ に対し $T_i = t, \ T_j = -t$ を割り当てる
  - $C_t = 1$ に対しては該当する参加者 $i$ に対し $T_i = t, -t$ の2通りの割り当てが存在する
- よって $C_t = 1$ となる各 $t$（高々11個）に対し実際に2通りの割り当てを全探索することで $s$ の最大値が求まる
  - $2^{11} = 2048$ より計算量は余裕
  - それぞれのパターンにおいて $s$ を求めるには、$T_i$ を昇順に並べたうえでその末項に $(\mathrm{初項}) + 24$ を加え、階差の最小値を取ればよい

## [ABC226 E - Just one](https://atcoder.jp/contests/abc226/tasks/abc226_e)
- 明らかに連結成分ごとに考えてOK
- 連結成分が木の場合
  - 葉を開始地点として、子から親のほうへ向きを付けることを繰り返せば根以外は条件を満たすことができる
  - ただし根が条件を満たさないのでNG
- 連結成分が木ではない場合
  - 閉路がちょうど1つ含まれる場合
    - 閉路に含まれる頂点に関しては時計回りか反時計回りの2通りの向きの付け方がある
    - 閉路に含まれない頂点に関しては、閉路に含まれる頂点1つを根とした木と見ることができるので条件を満たせる
  - 閉路が2つ以上含まれる場合は必ず出次数が2以上になる頂点が含まれるため条件を満たせない
- 以上により
  - 各連結成分が閉路をちょうど1つ含む場合は、連結成分の個数を $k$ として解は $2^k$
  - 1つでも↑を満たさない連結成分がある場合は解は $0$
- 計算量は $O(\max \{ N \alpha(N), M \alpha(N) \})$

## [ABC074 C - Sugar Water](https://atcoder.jp/contests/abc074/tasks/arc083_a)
- $F \leq 3000$ より全探索ができそう
- よってまずは全探索で水の質量、すなわち $100Aa + 100Bb \leq F$ になる全ての $(a, b)$ の組を求める
  - ↑のそれぞれに対して砂糖の質量を全探索で求めることを考える
    - まず、砂糖の質量の最大値 $M$ は以下を考慮して $M = \min \{ F - 100Aa - 100Bb, (Aa + Bb)E \}$ である
      - 水溶液全体が $F$ より重くなってはならない
      - 飽和状態よりも多く砂糖を入れることはできない
    - よって $Cc + Dd \leq M$ となる全ての $(c, d)$ の組を考え、それぞれに対して濃度を計算し、最大値を更新できればそのときの水溶液の質量 $100Aa + 100Bb + Cc + Dd$ と砂糖の質量 $Cc + Dd$ を記録すればよい
- $a, b, c, d$ の各ループは高々30回なので4重ループでも計算量は十分に少ない

## [ARC149 C - Avoid Prime Sum](https://atcoder.jp/contests/arc149/tasks/arc149_c)
- $N$ が偶数のとき
  - 上半分を全て偶数、下半分を全て奇数で埋めれば、偶数と奇数の境界以外の隣り合う2マスの数の和はすべて偶数かつ2より大きいので条件を満たす
  - 境界部分に関しては全て3の倍数かつ $2$ と $1$ が隣り合わないようにすればOK
- $N$ が奇数のとき
  - 左上から $(N^2 - 1) / 2$ マスを偶数で、右下から $(N^2 + 1) / 2$ マスを奇数で埋めれば、やはり偶数と奇数の境界以外は条件を満たす
  - 境界部分に関しては $N$ が偶数のときと同様だが、中央のマス（奇数）のみ2つの偶数と接するのでその2つの偶数を3で割った余りが異なると双方との和の両方を3の倍数にすることはできない
    - この場合偶数を適当に入れ替えて対応する
- 実装が適当過ぎて $N = 3$ のときに苦労した
  - 奇数の埋める順番を間違えると解がなくなってしまう

## [ABC032 D - ナップサック問題](https://atcoder.jp/contests/abc032/tasks/abc032_d)
- Recommendationに表示されたわけではないのだが気になったので解いてみた
- 問題自体はシンプルなナップサック問題なのだが、制約が複数種類あるため方針を変える必要がある
  - ある意味一粒で何度もおいしい問題
- $\displaystyle \max_{1 \leq i \leq N} w_i \leq 1000$ の場合
    - いわゆる最もポピュラーなケース
    - $dp_{i,j}$ を「$i$ 個目までのナップサックを見て合計質量が $j$ になるような選び方をした時の価値の和の最大値」とおいて以下の通りに更新する
        - 初期値：$dp_{1,w_1} = v_1$、それ以外は $0$
        - 更新：
            - $j \lt v_i$ ならば $dp_{i+1,j} = dp_{i,j}$
            - $j \geq v_i$ ならば $dp_{i+1,j} = \max \{ dp_{i,j}, dp_{i, j - w_i} + v_i \}$
    - 解は $\displaystyle \max_{0 \leq j \leq W} dp_{N, j}$
    - 計算量は $O(NW)$ であり $NW \leq 1000N^2 \leq 4 \times 10^7$ なので十分に間に合う 
- $\displaystyle \max_{1 \leq i \leq N} v_i \leq 1000$ の場合
    - ↑と同じDPを作ると $w_i \leq 10^9$ の制約により $w_i$ の最大値がデカいと`MLE`になる
    - DPの要素に $w_i$ ではなく $v_i$ を使いたい
    - $dp_{i,j}$ を「$i$ 個目までのナップサックを見て合計価値が $j$ になるような選び方をした時の重量の和の最小値」とおいて以下の通りに更新する
        - $\displaystyle V = \sum_{i = 1}^N v_i$ とおく
        - 初期値：$dp_{1,v_1} = w_1$、$1 \leq i \leq N$ に対し $dp_{i, 0} = 0$、それ以外は $\infty$
        - 更新：
            - $j \lt w_i$ ならば $dp_{i+1,j} = dp_{i,j}$
            - $j \geq w_i$ ならば $dp_{i+1,j} = \min \{ dp_{i,j}, dp_{i, j - v_i} + w_i \}$
    - 解は $dp_{N,j} \leq W$ となる最大の $j$
    - 計算量は $O(NV)$ であり $NV \leq 1000N^2 \leq 4 \times 10^7$ なので十分に間に合う
- $N \leq 30$ の場合
    - $v_i, w_i$ ともに大きすぎてDPの要素にできないのでDPは諦める
    - 代わりに $2^{30} \simeq 10^9$ なのでギリギリ全探索可能
    - ただし純粋にビット列で計算すると価値の和を求めるのに $O(N)$ の計算量が必要なため、全体で $O(N2^N)$ となり`TLE`
    - ここでナップサックを半分に分けて計算量を減らすことを考える
        - 前半 $\lceil \frac{N}{2} \rceil$ 個と後半 $\lfloor \frac{N}{2} \rfloor$ 個に分けてそれぞれビット列で全探索すると、価値の和と重さの和を求める計算量は $O(\lceil \frac{N}{2} \rceil 2^{\lceil \frac{N}{2} \rceil} + \lfloor \frac{N}{2} \rfloor 2^{\lfloor \frac{N}{2} \rfloor}) \simeq O(\frac{N}{2} 2^{\frac{N}{2}})$
            - $\frac{N}{2} 2^{\frac{N}{2}}$ は最大でも $5 \times 10^5$ 程度なのでかなり余裕がある
        - 勿論そのあとに前半と後半を組み合わせて解を求める必要がある
            - この計算量は $O(2^{\lceil \frac{N}{2} \rceil}2^{\lfloor \frac{N}{2} \rfloor}) = O(2^N)$ なので前述の通りギリギリ間に合う

## [ABC184 E - Third Avenue](https://atcoder.jp/contests/abc184/tasks/abc184_e)
- グリッドグラフにさらにテレポーターどうしを辺で繋いだものを考え、それに対してDijkstraで最短距離を求める。以上！
  - ただし実際に辺を繋いでしまうと辺数は最大で $(HW - 2)(HW - 3)/2 \simeq 8 \times 10^{12}$ であり`MLE`を食らうので、同じ種類のテレポーターの座標のみをリストで保持し、探索時に参照する形をとった
- 計算量は辺数を $E$ として $(E+HW)\log{HW}$ であり、$E$ は前述の通り $H^2W^2$ のオーダーになる可能性があるが、テレポーターが多すぎるとゴールまでの距離も短くなるため実際にはそこまでの計算量にはならない…はず
  - テストケースは最大約2100msで通っている

## [ABC119 C - Synthetic Kadomatsu](https://atcoder.jp/contests/abc119/tasks/abc119_c)
- $N \leq 8$ より間違いなく全探索なんだろうなと思いつつ、うまい具合に計算する方法が思いつかず
- どうせ全探索なんだからどこまでも愚直にやってやろうと考える
- 合成魔法を使わずに目的を達成するための最小MPは以下の考え方で求められる
  - 今持っている竹から3本を選ぶ全ての組み合わせについて以下を計算し、その最小値を求める
    - 選んだ竹の長い順にそれぞれ $A, B, C$ との差の絶対値を計算し、その合計を求める
- 合成魔法を使う場合は以下のように考える
  - 今持っている竹から2本を選ぶ全ての組み合わせに対し、再帰的に以下を考える
      1. 選んだ竹を合成する
      1. その状態で合成魔法を使わずに目的を達成するための最小MPを求める
      1. 竹が4本以上あれば2本を選んで1. へ
  - ↑の考え方だと結果的に同じ合成結果になる組み合わせがいくつも存在するが、組み合わせの総数は最大で ${}_8C_2 \times {}_7C_2 \times {}_6C_2 \times {}_5C_2 \times {}_4C_2 \simeq 5.3 \times 10^5$ であり計算量もメモリ消費量も余裕があるため、重複チェックをする必要はないと判断した
- （公式解説）竹のそれぞれについて「$A$ で使う」「$B$ で使う」「$C$ で使う」「使わない」を決める…考え方も実装も簡潔すぎる！
  - こういう主客逆転の考え方がすぐに思いつける体になりたい

## [ABC215 E - Chain Contestant](https://atcoder.jp/contests/abc215/tasks/abc215_e)
- $A_i$ を $i$ 回目のコンテストの種類とする
- キーになるのは以下の2つ
  - まだ参加したことのない種類のコンテストは任意のタイミングで参加できる
  - 既に参加したことのある種類のコンテストは直前に参加したものと同じ種類でないと参加できない
- よって $dp_{i,j,k}$ を「$i$ 回目以前のコンテストで参加した種類の集合が $j$ であり、$i - 1$ 回目に参加したコンテストの種類が $k$ であるようなコンテストの参加の仕方の場合の数」とすると、
  - 初期値：$dp_{1, \{ A_0 \}, A_0} = 1$
  - 遷移
    - $i$ 回目に参加しない：任意の $j, k$ に対し $dp_{i, j, k} = dp_{i - 1, j, k}$
    - $i$ 回目に参加する：
      - $k = A_i$ ならば
        - 任意の $j$ に対し、 $dp_{i, j, k}$ に $dp_{i - 1, j ,k}$ を加算
      - $j \not\ni A_i$ ならば
        - 任意の $j \not\ni A_i$ と任意の $k$ に対し、$dp_{i, j \cup \{ A_i \}, A_i}$ に $dp_{i - 1, j, k}$ を加算
  - 解は $\displaystyle \sum_{j} \sum_{k=1}^{10} dp_{n,j,k}$
- $j$ はビットで集合を表せばOK

## [AGC020 B - Ice Rink Game](https://atcoder.jp/contests/agc020/tasks/agc020_b)
- 後ろから順にあり得る最大値と最小値を計算するも上手くいかず
  - 最大値と最小値を完全に分けて考えてしまったため、$N$ が存在しないケース（最大値と最小値の間に $A_i$ の倍数が無い場合は $N$ が存在しない）を上手くはじくことができなかった
- （公式解説）自分の解答で試したものは線形走査であり計算量も二分探索より優れているのだが、この問題で二分探索を用いるという発想が出なかったので後学のために二分探索で実装してみた
  - そもそも二分探索が使えるのは（広義）単調増加、単調減少性がある場合である。逆に言えば、（広義）単調増加、単調減少性がある場合は（ベストかどうかはともかく）二分探索を検討すべきである。
  - 「最終的に2人**以上**が残る最小の $N$」「最終的に2人**以下**が残る最大の $N$」と読み替えられるかどうか
 
## [ABC289 E - Swap Places](https://atcoder.jp/contests/abc289/tasks/abc289_e)
- Dijkstra法をちょちょいといじればOK
  - 普段は「頂点 $1$ から頂点 $i$ までの最短距離を $d_i$」としているところを、「高橋君が頂点 $i$ に、青木君が頂点 $j$ にいる状態にするための最小の移動回数を $d_{i,j}$」とする
    - はじめは単に「高橋君が頂点 $i$ に行くまでの最小の移動回数 $a_i$」と「青木君が頂点 $j$ に行くまでの最小の移動回数 $b_i$」に分けてそれぞれを更新していくことを考えたが、「2人が同時にそれぞれ頂点 $i,j$ にいる状態」を考えるべきと気づいて↑のようにした
- 通常のDijkstra法と比べて計算量としてネックになるのは2人が行くことのできる隣接頂点を探すときの2重ループだが、$M \leq 2000$ より多くとも $10^6$ 通りの組み合わせしかないため問題ないと見た

## [CODE FESTIVAL 2016 qual C C - 二人のアルピニスト](https://atcoder.jp/contests/code-festival-2016-qualc/tasks/codefestival_2016_qualC_c)
- 山 $i$ の高さ $h_i$ としてありうる場合の数を $m_i$ とおく
- 高橋君か青木君が最大値を更新した場合、その山の高さは確定する（すなわち $m_i = 1$）
  - より具体的には以下
    - $T_0 = 0$ とし、$i \ (1 \leq i \leq N)$ において $T_{i-1} \lt T_i$ ならば $h_i = T_i$
    - $A_{N+1} = 0$ とし、$i \ (1 \leq i \leq N)$ において $A_{i} \gt A_{i+1}$ ならば $h_i = A_i$
  - $h_i$ が確定するということは、$h_i \leq T_i, \ h_i \leq A_i$ の双方が成立する必要がある
    - 少なくとも一方が成立しない場合は記録が間違っているので $m_i = 0$ とする
  - また、高橋君と青木君が同時に最大値を更新したのに $T_i \neq A_i$ になっている場合も記録が間違っているので $m_i = 0$ である
    - なお実はこの部分をきちんと考えておらず嘘解法を通してしまった模様（レビューを書いていて気づいた）
- 最大値を更新しない場合、$1 \leq h_i \leq \min \{ T_i, A_i \}$ が成り立つので $m_i = \min \{ T_i, A_i \}$
- 各山の高さは独立なので $\displaystyle \prod_{i = 1}^N m_i$ が解になる

## [ABC157 E - Simple String Queries](https://atcoder.jp/contests/abc157/tasks/abc157_e)
- 文字種ごとに以下のSegment Treeを用意する
  - データ型は`boolean`
  - 区間の要素の総積は論理OR、単位元は`false`
  - 要素の変更は、$S_i$ 文字目がその文字種なら`true`、そうでないなら`false`とする
- あとはtype 2のクエリが来るたびに各文字種で区間 $[ l_q, r_q ]$ の総積が`true`になるものの数を答えればよい

## [ABC129 D - Base n](https://atcoder.jp/contests/abc192/tasks/abc192_d)
- 以下、文字列 $S$ を $n$ 進数表記の数とみなしたものを $T_n$ とする
- $|S| = 1$ のとき
  - 全ての $n \gt d$ に対し $T_n$ が同じ値になるので、$T_{10} \leq M$ が成り立てば解は1種類、成り立たなければ0種類
- $|S| \geq 2$ のとき
  - まず、$T_{d + 1} \gt M$ ならば解は0種類
  - そうでない場合は $T_n \leq M$ を満たす最大の $n = N$ を探索する
    - $T_n$ は狭義単調増加かつ題意より $n \leq M$ が約束されるので二分探索でOK
    - $N - d$ が解となる
- $T_n \leq M$ を評価する具体的な方法は以下
  - 愚直に $\displaystyle T_n = \sum_{i = 1}^{|S|} s_i n^{|S| - i}$（$s_i$ は $S$ の $i$ 文字目を1桁の整数とみなしたもの）を計算する
    - ただし、`long long`型に収まらないケースに備えて以下の手順を取る
        1. まず`double`型で↑の計算式に沿って $T_n$ を求める
        2. 計算結果が`inf`や`NaN`の場合、および $9 \times 10^{18}$ を超える場合は $T_n \gt M$ とする
            - `NaN`を考慮しているのは式中に $0 \times \infty = \mathrm{NaN}$ の項が発生するため（1敗）
        3. そうでない場合は改めて`long long`型で $T_n$ を求めて $M$ と大小比較する
            - `double`の仮数部は2進数で52桁であり、`long long`型は2進数で最大63桁であるため、`double`型のまま大小比較をするには精度が足りない

## [ABC152 E - Flatten](https://atcoder.jp/contests/abc152/tasks/abc152_e)
- $L$ を $A_1, A_2, \dots, A_N$ の最小公倍数とすると $B_i = \frac{L}{A_i}$ となる
- $\bmod$ 計算だとGCDおよびLCMが求まらないので素直に素因数分解すればよい
- メモ：`map`に対して`for_each`や`accumlate`するときに渡す関数の引数の型は`map<Key, T>::value_type`

## [ARC151 B - A < AP](https://atcoder.jp/contests/arc151/tasks/arc151_b)
- 辞書順で小さいものの個数：対称性があるならば、全体と辞書順で等しいものの個数を数えるだけでもいける

## [ARC146 B - Plus and AND](https://atcoder.jp/contests/arc146/tasks/arc146_b)
- 選んだ $K$ 個のビット単位 $\mathrm{AND}$ を $X$ にできるかどうかは以下で判定できる
    1. 各 $i$ に対して、 $Y \geq A_i$ かつ $Y \ \mathrm{AND} \ X = X$ となる最小の $Y$ を求め、 $B_i = Y - A_i$ とする。具体的には以下
        1. $A_i, X$ を2進数表記にしたときに、 $A_i$ の下から $j$ 桁目が $0$ かつ $X$ の下から $j$ 桁目が $1$ となる最大の $j$ を求める
        1. $A_i, X$ のそれぞれの $j$ 桁目以下のみでできる数を $A_i', X'$ とすると、 $B_i = X' - A_i'$
    1. 整数列 $B$ を昇順に並び替えて、先頭 $K$ 個の和を $S_X$ とする。 $S_X \leq M$ ならばできる、そうでなければできない
- あとは二分探索で最大値を求めるのだが、 $S$ は任意の $X$ に対して完全に単調増加なわけではないので注意
  - $X_1 < X_2$ に対して繰り上がりが生じない、すなわち $X_1 \ \mathrm{AND} \ X_2 = X_1$ なら必ず $S_{X_1} < S_{X_2}$ となり単調性があるが、繰り上がりが生じるときはそうとは限らない
    - なので両端の初期値が2の累乗なら常に繰り上がりが生じないので問題ないが、そうでないときは普通に間違った解が出てくる
      - これに気づかないと延々`WA`になるかしれっと嘘解法を通してしまうかの運ゲーになる
  - 正しくは $X$ の上位ビットから順に $1$ にできるかどうかを判定していく
    - コードがぱっと見だと二分探索には見えないが、勿論やっていることは立派な二分探索である
- 計算量は $O((N\log N + K)\log X)$

## [ABC176 D - Wizard in Maze](https://atcoder.jp/contests/abc176/tasks/abc176_d)
- ワープ魔法を距離 $10^9$ の移動と考えればdijkstraでOK

## [ABC201 D - Game in Momotetsu World](https://atcoder.jp/contests/abc201/tasks/abc201_d)
https://drken1215.hatenablog.com/entry/2023/07/21/235300

- いわゆるネガマックス法
- メモ化再帰で計算量を減らす

## [ABC339 D - Synchronized Players](https://atcoder.jp/contests/abc339/tasks/abc339_d)
- $N \leq 60$ より最大でも $N^4 \sim 10^7$ より2人のプレイヤーの座標を頂点とするグリッドBFSが間に合う

## [ACL Beginner D - Flat Subsequence](https://atcoder.jp/contests/abl/tasks/abl_d)
- `atcoder::segtree`の初期値は`e()`

## [ABC354 D - AtCoder Wallpaper](https://atcoder.jp/contests/abc354/tasks/abc354_d)
- $[4n, 4n+3] \times [2m, 2m+1]$ の繰り返しなので $[4n, x] \times [2m, y]$ における面積は比較的求めやすい
  - よって $P = 4 \lfloor A/4 \rfloor, Q = 4 \lfloor B/4 \rfloor, R = 4 \lfloor C/4 \rfloor, S = 4 \lfloor D/4 \rfloor$ として $[P, R] \times [Q, S]$ の面積を求め、過不足を調整するのが簡明

## [AGC032 B - Balanced Neighbors](https://atcoder.jp/contests/agc032/tasks/agc032_b)
- 与えられた $N$ に対して逐一探索するのではなく、汎用的な条件を考えるタイプの問題
- $N$ が偶数のとき
  - 各頂点 $i$ に対し $j = N + 1 - i$ とおくと $i \neq j$ であり、自身と $j$ 以外のすべての頂点と辺を繋ぐと隣接する頂点の和は $\frac{N(N+1)}{2} - (N+1)$ となり $i$ に依らず一定
- $N$ が奇数のとき
  - 各頂点 $i$ に対し $j = N - i$ とおくと $i \neq j$ であり、自身と $j$ 以外のすべての頂点と辺を繋ぐと隣接する頂点の和は $\frac{N(N+1)}{2} - N$ となり $i$ に依らず一定
    - かつ頂点 $N$ は自身以外のすべての頂点と辺を繋ぐと隣接する頂点の和は $\frac{N(N+1)}{2} - N$ となるので題意を満たす

## [ARC133 B - Dividing Subsequence](https://atcoder.jp/contests/arc133/tasks/arc133_b)
- 倍数列挙： `for (int k = 1; k * x <= n; ++k)`で探せば時間計算量 $O(N \log N)$
- ペアの列 $((x_1, y_1), (x_2, y_2), \dots, (x_K, y_K))$ から $x_{i_1} < x_{i_2} < \dots < x_{i_k}$ かつ $y_{i_1} < y_{i_2} < \dots < y_{i_k}$ を満たすようにペアを取り出す方法で、取り出せるペア数の最大値を求める：
    1. ペアを $x$ の昇順→ $y$ の降順で並び替える
    2. $y$ だけ見てLIS（最長増加部分列）の長さを求める
        - 同じ $x$ に対して $y$ が降順に並ぶため、同じ $x$ を2度選ぶことがない

## [ABC214 D - Sum of Maximum Weights](https://atcoder.jp/contests/abc214/tasks/abc214_d)
- 寄与する回数が少ない順（＝コストが小さい順）に辺を繋ぐと数えやすい

## [ABC232 E - Rook Path](https://atcoder.jp/contests/abc232/tasks/abc232_e)
- ~~俺か俺以外か~~ 目的地にいるかいないかの2状態DP
- $x, y$ に分けて同時に見る。すなわち、 $\mathrm{dp}_{i,p,q}: i$ 回目の移動後にルーク $(x, y)$ が $p: x = x_2, q: y = y_2$ を満たすような移動の場合の数とすればよい（ $p,q$ は`boolean`）

## [ARC185 B - +1 and -1](https://atcoder.jp/contests/arc185/tasks/arc185_b)
- 明確なゴールを1つ決めてそれが達成できるかどうかを判定するタイプ
- $S = \sum_{i=1}^N A_i$ とおくと、操作によって $S$ は変化しない
- $S$ を $N$ で割った商、余りをそれぞれ $Q, R$ とし、先頭 $N-R$ 項が $Q$ 、続く $R$ 項が $Q+1$ の数列 $B$ を考えると
  - $A$ を広義単調増加列にできることと、 $A$ を $B$ にできることは同値
- あとは $i = N, N-1, \dots, 1$ の順に $A$ を $B$ にできるかどうかを判定すればよい
- **オーバーフローにはくれぐれも気をつけること**

## [ABC117 D - XXOR](https://atcoder.jp/contests/abc117/tasks/abc117_d)
- XOR→ビットごとに考える
- 基本的にはDPだが、 $X \leq K$ を満たす必要があるので $1$ を立てられないビットが出現する
  - $X < K$ が確定しているかどうかを表す変数 $Y$ を用意して2要素DPにする
    - $Y=\mathrm{true}$ のときの初期値を $-\infty$ にする必要があるのと、 $-\infty$ からの遷移を禁止する必要がある点に注意

## [ABC213 E - Stronger Takahashi](https://atcoder.jp/contests/abc213/tasks/abc213_e)
- 通常の非壁隣接マスへはコスト0、壁を破壊して到達可能なマスへはコスト1の辺が張られているものとしてDijkstra

## [ABC305 F - Dungeon Explore](https://atcoder.jp/contests/abc305/tasks/abc305_f)
- 連結無向グラフからDFSで用いられない辺をグラフから削除すると木になるので $2N$ 回未満の移動ですべての頂点に到達できる
- 行きがけ時に（まだわかっていなければ）隣接頂点を取得し、帰りがけ時に親へ移動すればOK

## [ABC098 D - Xor Sum 2](https://atcoder.jp/contests/abc098/tasks/arc098_b)
- $A_l \oplus A_{l+1} \oplus \dots \oplus A_{r} = A_l + A_{l+1} + \dots + A_r \Leftrightarrow $ 任意の $l \leq i < j \leq r$ に対して $A_i \ \mathrm{AND} \ A_j = 0$
- 尺取り虫法で↑を満たす区間 $[l, r)$ を求めれば $\sum \frac{1}{2}(r_i - l_i)(r_i - l_i + 1)$ が解

## [ARC126 B - Cross-free Matching](https://atcoder.jp/contests/arc126/tasks/arc126_b)
- $l_1, l_2, \dots, l_K$ の順に線分を選んだとして、 $a_{l_1} < a_{l_2} < \dots < a_{l_K}$ および $b_{l_1} < b_{l_2} < \dots < b_{l_K}$ が必要十分条件
- これは[ARC133 B - Dividing Subsequence](https://atcoder.jp/contests/arc133/tasks/arc133_b)でやったやーつ

## [ABC259 E - LCM on Whiteboard](https://atcoder.jp/contests/abc259/tasks/abc259_e)
- 書き換える前の $a_1, a_2, \dots, a_N$ の最小公倍数を $L$ とおく
- $f(i, p)$ を $a_i$ が含む素因数 $p$ の個数とし、集合 $S_p = \{ i \mid f(i, p) = \max_{1 \leq j \leq N} f(j, p) \}$ とする
- 各 $p$ に対し
  - $|S_p| = 1$ のとき、その唯一の要素 $i$ とすると、 $A_i$ を $1$ に書き換えることで $L$ と異なる最小公倍数を得られる
    - かつ、異なる $p$ に対して異なる最小公倍数を得られる
  - $|S_p| > 1$ のとき、その中に含まれる各要素 $i$ について、 $S_{p'} = \{ i \}$ となる $p'$ が存在しないならば、 $A_i$ を $1$ に書き換えて得られる最小公倍数は $L$ のままである
- よって ${\displaystyle T = \bigcup_{p \in \{ p \, \mid \, \left| S_p \right| = 1 \}} S_p }$ とすると、解は以下の通り
  - $|T| = N$ のとき、 $L$ があり得る値に含まれないので $|T|$
  - $|T| < N$ のとき、 $L$ があり得る値に含まれるので $|T| + 1$

## [ARC059 D - アンバランス](https://atcoder.jp/contests/arc059/tasks/arc059_b)
- 気づけば1発系
- 文字`x`が過半数ならば文字列中に必ず`xx`または`xyx`となる箇所がある
  - 証明
    - 対偶を考える。`xx`または`xyx`となる箇所が存在しないならば次のいずれかが成り立つ
      - `x`は文字列中に1個以下
        - この場合明らかに`x`は過半数でない
      - いずれの`x`どうしも間に2文字以上が存在する
        - この場合、文字列全体の長さを $N (\geq 2)$ とおくと`x`は高々 $\lceil N/3 \rceil$ 個である
        - $\frac{\lceil N/3 \rceil}{N}$ の最大値は $N=4$ のとき $\frac{1}{2}$ なので`x`は過半数にならない
- よって先頭から順に $s_i = s_{i+1}$ または $s_i = s_{i+2}$ になる箇所を探すのみ
- `for (int i = 0; i - 2 < n; ++i)` でループを回していたせいで $N=2$ のときにアンバランスをスルー（1敗目）
  - さらに `s[i] == s[i+1]` のときに `i+1`と`i+3` を出力していたせいでやはり $N=2$ のときに`WA`（2敗目）
    - 簡単なときこそ足元確認！

## [ABC123 D - Cake 123](https://atcoder.jp/contests/abc123/tasks/abc123_d)
- 次に大きい値として可能性があるものを`priority_queue`に突っ込んで更新していく
  - 初期値として $(1, 1, 1)$ を突っ込んでおく
  - $(i, j, k)$ が`priority_queue`から取り出されたとき、それを出力したうえで
    - $(i+1,j,k), (i,j+1,k), (i,j,k+1)$ を次の候補として`priority_queue`に突っ込む
      - ただし一度使われた $(i, j, k)$ は二度以上選ばない
- 個人的にはDijkstraの亜種だと思っている

## [ARC148 C - Lights Out on Tree](https://atcoder.jp/contests/arc148/tasks/arc148_c)
- 説明を簡素にするため、裏向きのコインを載せた頂点を根の親として追加し、以降この頂点を新たな根とする
- 葉から順番に葉とその親の表裏が等しくなるように操作していけばOK
  - 最も深い葉から順に操作することで最小回数になり、その値は「親と子の表裏が異なる組み合わせの数」となる
- ただしこのままでは各頂点ごとに確認が必要になり計算量が $O(QN)$ で`TLE`（1敗）
- $S$ に含まれる頂点のみで↑を数えられないかを考える
  - 以降頂点 $i$ に隣接する頂点で表裏が頂点 $i$ と異なるものの個数を $c_i$ とする
- $S$ に含まれる頂点間で親子関係にあるものがなければ、解は $\sum_{i \in S} c_i$ となる
  - ここで $S$ に含まれる2頂点 $i,j$ が親子関係であるとすると、 $c_i + c_j$ は表裏が同じである $(i, j)$ を2回カウントしてしまっているため、本来の値より $2$ 大きい
  - よって解は $\sum_{i \in S} c_i - 2X$ （ただし $X$ は $S$ に含まれる2頂点で親子関係であるものの組み合わせの個数）となり、計算量 $O(M)$ でいける

## [ABC153 F - Silver Fox vs Monster](https://atcoder.jp/contests/abc153/tasks/abc153_f)
- 左端のモンスターから順番に処理することで爆弾の使用数を最小化できる
  - 勿論爆弾を使うときは左端が範囲に入るギリギリの場所で使う
- よって $l = 1, 2, \dots, N$ の順に以下を行う
  - そのときにおける左端から $l$ 番目のモンスターの体力を $h_l$ とおく。 $h_l > 0$ ならば
    - 巻き込める最も右端のモンスター $r$ を二分探索で求めたうえで $l \leq i \leq r$ に対して $h_i$ を $\frac{h_l}{A} \rceil A$ だけ減らす
- 区間に対して同じ値を加算するので`lazy_segtree`でOK
- （公式解説）うまく部分的に和を取りながらやればimos法でもいけるらしい……
  - `lazy_segtree`のほうが直感的だが脳死である感は否めない

## [ABC167 E - Colorful Blocks](https://atcoder.jp/contests/abc167/tasks/abc167_e)
- あらかじめ $1 \leq i < N$ を満たす $i$ から $0 \leq k \leq K$ 個を選んで $i$ 個目 と $i+1$ 個目のブロックを同じ色で塗ると決めておく
  - この状況下における塗り方は $N - k$ 個を隣り合うブロックに同じ色を塗らないようにする場合の数と等しく、 $M(M-1)^{N-k-1}$ 通り
  - かつ、 $i$ の選び方が異なれば必ず別の塗り方になる
- よって解は ${\displaystyle \sum_{k = 0}^{K} M(M-1)^{N-k-1} \left( \begin{matrix} N-1 \\ k \end{matrix} \right) }$
  - 例によって階乗を前計算しておけば時間計算量は $O(K \log P)$

## [ABC059 C - Sequence](https://atcoder.jp/contests/abc059/tasks/arc072_a)
- $i = 1, 2, \dots, N$ の順に $S_i$ が条件を満たせるように $A_{i-1}$ → $A_i$ の順に貪欲に調整していけばOK
  - 具体的には $S_i > 0$ となるべきなのに $S_i \leq 0$ である場合には
    - （ $i \geq 2$ ならば）まず $S_{i-1}$ を可能な限り $-1$ に近づける。すなわち $A_{i-1}$ に $\mathrm{min} \{ -1 - S_{i-1}, 1 - S_i \} $ を加える
    - それでもまだ $S_i \leq 0$ ならば $S_i = 1$ となるようにする。すなわち $A_i$ に $1 - S_i$ を加える
  - $S_i < 0$ となるべきなのに $S_i \geq 0$ である場合も同様にできる
- あとは $S_1 > 0$ とした場合と $S_1 < 0$ とした場合をそれぞれ計算して小さい方を解とするだけ

## [ABC378 E - Mod Sigma Problem](https://atcoder.jp/contests/abc378/tasks/abc378_e)
- $A$ の累積和を $S$ （ただし $S_0 = 0$ ）とすると、求めるものは ${\displaystyle \sum_{l=1}^N \sum_{r=l}^N (S_r - S_{l-1}) \bmod M}$
- ここで $S$ を単なる累積和ではなく $\bmod M$ にして問題なく、さらに $(S_r - S_{l-1}) \bmod M$ は
  - $S_r \geq S_{l-1}$ のとき、 $S_r - S_{l-1}$
  - $S_r < S_{l-1}$ のとき、 $S_r - S_{l-1} + M$
  - とすることができる
- ここで $B_i$ を $i < j \leq N$ かつ $S_i > S_j$ を満たす $j$ の個数とすると、
$$ \sum_{l=1}^N \sum_{r=l}^N (S_r - S_{l-1}) \bmod M = \sum_{l=1}^N \left( \sum_{r=l}^N (S_r - S_{l-1}) + B_{l-1}M \right)
  = \sum_{l=1}^N \left( \sum_{r=l}^N S_r - (N - l + 1)S_i + B_{l-1}M \right) $$
- ${\displaystyle \sum_{r=l}^N S_r}$ は $S$ の累積和を取ることで前計算 $O(N)$ 、 $B$ も前計算 $O(N \log M)$ で求まるため計算量も問題ない

## [ABC245 F - Endless Walk](https://atcoder.jp/contests/abc245/tasks/abc245_f)
- 頂点数2以上の強連結成分に到達できる頂点数が解になる
- よって辺の向きをすべて逆にしたグラフでトポロジカルソートされた強連結成分でDFSを行い、親に頂点数2以上の強連結成分を持てばOKとしたが
  - DFSの走査順によってはうまくいかない
    - 例として強連結成分A,B,CにおいてA→C, B→Cの辺があり、Bのみが頂点数2以上の場合、A→Cが先に走査されるとCが条件を満たさなくなってしまう
- むしろ辺の向きは元のままで、トポロジカルソートされた強連結成分の（辺があるかどうかに関係なく）後ろから順番に見ることで正しく数えられる
  - トポロジカルソートそのものが意味のある並びなので、探索ではなく順番に見るのは有力

## [ABC285 E - Work or Rest](https://atcoder.jp/contests/abc285/tasks/abc285_e)
- $P_i$ を $i$ 日目の生産量とする
- 休日・平日の相対位置のみが重要であり、最低1日は休日にすべきなので $1$ 日目を休日で固定できる
- $\mathrm{dp}_{i,j}$ を $i$ 日目までを休日・平日のどちらにするかを決めた状態で、直前の休日が $j < i$ 日目であり、 $i+1$ 日目以降をすべて平日としたときの週の生産量の最大値とおくと
  - $i+1$ 日目を平日とするとき、 $\mathrm{dp}_{i+1,j} = \mathrm{dp}_{i,j}$
  - $i+1$ 日目を休日とするとき
    - $j$ 日目以前の生産量に変化はないので区間 $[j+1, N]$ における生産量の合計の変化を考える
      - 変化前: 区間 $[j+1, N]$ に休日がないことから、 $j$ 日目に近い側と $N+1$ 日目に近い側の2つに分けて考えればそれぞれの生産量の合計は $A$ の初項から連続する何項かの和に等しく、すなわち $O(1)$ で計算できる
      - 変化後: 変化前と同様に $j$ 日目に近い側、 $i+1$ 日目に近い側、 $N+1$ 日目に近い側の3つに分けて考えれば $O(1)$ で計算できる
    - これにより $\mathrm{dp}_{i+1, i+1}$ が $O(1)$ で更新できる
- 解は $\max_j \mathrm{dp}_{N, j}$ で、全体計算量は $O(N^2)$

## [ARC150 B - Make Divisible](https://atcoder.jp/contests/arc150/tasks/arc150_b)
- AC（55分＋1TLE＋1WA）
- 結局のところうまいやり方はなく $X=0$ から順に走査するしか無いが、勿論工夫をしないと`TLE`
- $B$ を $A+X$ で割った商を $Q_X$ 、余りを $R_X$ とおくと、 $X+Y$ の最小値は $R_X = 0$ のとき $X$ 、そうでないときは $X + A + X - R_X = A + 2X - R_X$
  - このとき $Q_X \geq R_X$ ならば $Q_X > Q_{X+1}$ となるので工夫のしどころはないが、
  - $Q_X < R_X$ のとき、 $R_X$ を $Q_X$ で割った商を $q$ とおくと、 $0 \leq k < q$ に対し
    - $B = Q_X(A+X) + R_X = Q_X(A+X+k) + R_X - kQ_X$ となり、 $0 < R_X - kQ_X < R_X < A+X \leq A+X+k$ より $Q_X, R_X - kQ_X$ はそれぞれ $B$ を $A+X+k$ で割った商と余りとしてよい
      - このとき、 $k<q$ より $R_X - kQ_X > 0$ なので $X+Y$ の最小値は $X+k + (A+X+k) - (R_X - kQ_X) = A + 2X + 2k - R_X + kQ_X > A + 2X - R_X$ である
        - よって $k = 0, 1, \dots, q$ の中で $X+Y$ が最小になりうるのは $k=0, q$ のときのみとなるので、 $X$ をいくらかスキップして走査できる
          - なお $k = q$ を走査し忘れて1敗
- 全体計算量は $O(\sqrt{B})$

## [ARC135 C - XOR to All](https://atcoder.jp/contests/arc135/tasks/arc135_c)
- AC（35分＋1WA）
- 何回操作しても最後の1回のみを行ったときと変わらないため、操作の回数は高々1回としてよい
  - 略証: 操作前の $A$ を $B$ とする。 $k$ 回操作後に $1 \leq j \leq N$ を用いて $A_i = B_i \oplus B_j$ と表されているものとする
    - $k + 1$ 回目の操作として $x = A_{j'} = B_{j'} \oplus B_j$ を選ぶと、 $A_i = (B_i \oplus B_j) \oplus (B_{j'} \oplus B_j) = B_i \oplus B_j'$ となる
      - よって帰納的に考えて数列 $A$ は最後の操作の影響しか受けない
- $A_{i,j}$ を $A_i$ の下から $j$ ビット目とし、 $c_j = \sum_{i=1}^N A_{i,j}$ とする
- 操作として $A_k$ を選んだときの解への影響は $\sum_{j} \sum_{i=1}^N (N - 2c_j)A_{i,j}$ と表せるので、操作を行わなかったケースと併せて最大値を $O(N)$ で計算できる
- なおビットが高い方から寄与の大きいものを選ぼうとして`WA`
  - $c_j > N/2$ なら $j$ ビット目に操作して得になるので $j$ の大きい順に $c_j > N/2$ ならば $A_{k,j} = 1$ となるような $A_k$ を選ぶという方針だったが
    - 例えば $c_j$ がギリギリ $N/2$ より大きく $c_{j-1}$ が $0$ に近い（が上位ビットの関係で $A_{k,j} = 0$ かつ $A_{k, j-1} = 1$ となるような $A_k$ が選べない）とこの方針だと間違えてしまう

## [ABC078 D - ABS](https://atcoder.jp/contests/abc078/tasks/arc085_b)
- AC（60分＋1TLE）
- $\mathrm{dp}_{i,j}$ をXさんが $A_i$ 、Yさんが $A_j$ を持っているときの最終のスコア（なおXさんに関しては $A_0 = Z$ 、Yさんに関しては $A_0 = W$ とみなす）としてメモ化探索をするも
  - $O(N^3)$ で勿論`TLE`
- DP遷移式に注目する
  - $i = 0$ または $i < j$ のときXさんのターンであり、 $\mathrm{dp}_{i,j} = \max_{k > j} \mathrm{dp}_{k, j}$ と遷移する
  - $i > j$ のときYさんのターンであり、 $\mathrm{dp}_{i,j} = \min_{k > i} \mathrm{dp}_{i, k}$ と遷移する
- よって後ろから最大値・最小値を保持しつつ更新していけば計算量を $O(N^2)$ に落とせる

## [ARC155 A - ST and TS Palindrome](https://atcoder.jp/contests/arc155/tasks/arc155_a)
- やっぱり回文は鬼門……
- $S'$ は右端、左端のそれぞれから $\mathrm{rev}(S), S, \mathrm{rev}(S), S, \dots$ の繰り返しになるのでそれをチェックするコードを書くも`WA`の嵐
- 結局公式解説どおり中央の $K \bmod 2N$ 文字のみを実際に生成し $(=T)$ 、$S + T$ と $T + S$ の双方が回文になるかどうかをチェックした

## [ABC092 D - Grid Components](https://atcoder.jp/contests/abc092/tasks/arc093_b)
- 発想一発系
- 上半分を白、下半分を黒にし、1マスずつ上半分に $B-1$ 個の黒、下半分に $A-1$ 個の白を置く
- $w = 99$ で固定すると1行あたり49個の独立したマスを用意できるので制約から必要になる（独立したマスのための）行はそれぞれ11行、よって $h=46$ で固定してOK

## [ABC105 D - Candy Distribution](https://atcoder.jp/contests/abc105/tasks/abc105_d)
- $S_i = \sum_{j=1}^i A_i \bmod M$ とすれば（ $S_0 = 0$ とする）、求めるのは $S_i = S_j$ を満たす $0 \leq i < j \leq N$ の個数
- よってあとは $C_k$ を $S_i = k$ を満たす $i$ の個数としておけば $\sum_k C_k(C_k - 1)/2$ で解が求まる

## [ABC278 F - Shiritori](https://atcoder.jp/contests/abc278/tasks/abc278_f)
- 「使用済みの単語の集合」「最後に選ばれた単語」の2要素Bit DP
- DFSでメモ化探索
  - 手番と同じプレイヤーが勝つような単語がある場合は問答無用でそれを選ぶ
  - 手番と同じプレイヤーが勝つ単語がない場合は相手プレイヤーの勝ちとする
    - しりとりができなくなって負けもここに含まれる
- メモしているのにその結果を使わないなんてアホなことがないように（1敗）
  - このポカ多いんだよなぁ……

## [ABC328 F - Good Set Query](https://atcoder.jp/contests/abc328/tasks/abc328_f)
- 頂点に値を持つグラフで、頂点間の値の差に相当するラベルを持った有向辺を繋いでいくタイプ
- 今のグラフの状態と新たに追加する辺に矛盾があるかどうかが問題になる
  - 重み付きUnion-Find木を使えば判別可能
    - 参考: [Union-Find木 [いかたこのたこつぼ]](https://ikatakos.com/pot/programming_algorithm/data_structure/union_find_tree#ポテンシャル付きunion-find)
- なお自分の解答だとグループどうしの併合時にサイズの大きい方を新たな親としていないので、`connect`の計算量は $O(\log N)$ に悪化している
  - しかしこれでも全体の計算量は $O(Q \log N)$ なので余裕
  - 参考: [UnionFindTree に関する知見の諸々 - noshi91のメモ](https://noshi91.hatenablog.com/entry/2018/05/30/191943)
    - 今回は辺のラベルが頂点間の値の差だが、両端頂点のXORやモノイドなどにも応用が効くらしい

## [ABC216 F - Max Sum Counting](https://atcoder.jp/contests/abc216/tasks/abc216_f)
- DPがそのまま答えになるわけではないタイプ
- $A_i$ の昇順に並べ替えておくことで $\max_{i \in S} A_i$ の考慮を簡単にしておく
- $\mathrm{dp}_{i,j}$ を $i$ 以下の正整数を要素に持つ集合 $T$ に関して、 $\sum_{i \in T} B_i = j$ となる $T$ の個数とおくと、DP更新は以下
  - $B_i$ を取らない： $\mathrm{dp}_{i,j} \gets \mathrm{dp}_{i-1,j}$
  - $B_i$ を取る： $\mathrm{dp}_{i,j} \gets \mathrm{dp}_{i,j} + \mathrm{dp}_{i-1,j-B_i} (j \geq B_i)$
- DPを更新しながら解 $\mathrm{ans}$ を更新するのがキモであり、 $S$ は空集合ではないことから、DP更新において $B_i$ を取るときに $j \leq A_i$ ならば $\mathrm{dp}_{i-1,j-B_i}$ を $\mathrm{ans}$ に加算していけばよい

## [ABC298 F - Rook Score](https://atcoder.jp/contests/abc298/tasks/abc298_f)
- とりあえず座標圧縮
- 行の合計を $S_i$ 、列の合計を $S_j$ 、マス $(i,j)$ に書かれている数を $A_{i,j}$ としたとき、 $V_{i,j} = S_i + S_j - A_{i,j}$ の最大値が解になる
- あらかじめ $S_j$ を降順に並び替えておくとして、 $i$ を固定したとき
  - $A_{i,j} > 0$ ならば $V_{i,j} < V_{i, j+1}$ があり得るので、引き続き探索する必要がある
  - $A_{i,j} = 0$ ならば $V_{i,j} < V_{i, j+1}$ はあり得ないので、これ以上探索する必要がない
- $i$ を普通に全探索したとしても、 $A_{i,j} > 0$ は全体で $N$ 箇所しかないため、↑の引き続き探索による計算量はならし $O(1)$ にしかならない
  - パッと見 $O(N^2)$ に見えるが全然そんなことはないパターンに敏感になるべし

## [ARC136 B - Triple Shift](https://atcoder.jp/contests/arc136/tasks/arc136_b)
- $A, B$ をそれぞれ多重集合として見て要素が異なれば`No`
- $A$ の要素がすべて異なるとき
  - 操作により転倒数の偶奇が変わらないことから、 $A$ の転倒数の偶奇と $B$ の転倒数の偶奇が一致すれば`Yes`、しなければ`No`
    - 厳密な証明は思いつかなかったが、 $A=(1,2,3,4)$ で操作を繰り返すと12種類の列が得られることから転倒数の偶奇さえ一致すれば大丈夫だろうと判断した
- $A$ の要素に同一のものがあるとき
  - 一旦ラベルを付けて大小関係を定めて転倒数を求める。ラベルを付け替えることで転倒数の偶奇を変えられるので、常に`Yes`となる

## [ABC302 F - Merge Set](https://atcoder.jp/contests/abc302/tasks/abc302_f)
- 辺数が多いグラフでDFSないしBFSすべきときは**超頂点**を疑え！

## [ARC075 D - Widespread](https://atcoder.jp/contests/arc075/tasks/arc075_b)
- 2分探索は忘れた頃にやってくる
- $k$ 回の魔法で全滅させられるかどうかは以下で判断できる
  - $h_i \leq kB$ である魔物は中心として選ばなくとも消せる
  - そうでない場合、 $\left\lceil \frac{h_i - kB}{A-B} \right\rceil$ 回は中心として選ぶ必要がある
  - よって $\sum_{i=1}^N \left\lceil \frac{\max\{ h_i - kB, 0 \}}{A-B} \right\rceil \leq k$ であれば $k$ 回の魔法でOK

## [ARC120 C - Swaps 2](https://atcoder.jp/contests/arc120/tasks/arc120_c)
- 交換操作系問題でたまにある **$A_i + i$ に注目するとうまくいく**パターン
- $C_i = A_i + i, D_i = B_i + i$ とおくと、 $A_i$ に対する操作は $C_i$ と $C_{i+1}$ を交換するだけになる
- $S_x$ を $C_i = x$ となる $i$ の集合、および $T = \{ 1, 2, \dots, N \}$ とすると、このとき
  - $i = N, N-1, \dots, 1$ の順に以下を合計したものが解になる
      1. $j = \max S_{D_i}$ とおく
      1. $S_{D_i}$ から $j$ を削除する
      1. $T$ から $j$ を削除する
      1. $T$ に含まれる $j$ より大きい要素の個数を求める
- ↑の操作において、以下を満たす場合は $A_i$ を $B_i$ に一致させることが不可能とわかる
  - $S_{D_i}$ がそもそも存在しない
  - $S_{D_i}$ が空集合である

## [ARC116 C - Multiple Sequences](https://atcoder.jp/contests/arc116/tasks/arc116_c)
- エラストテネスの区間篩： $N$ 以下のすべてを前処理 $O(N \log \log N)$ 、本処理 $O(N \log N)$ で素因数分解できる
- あとは数IAの場合の数をちゃんとやるだけ
  - $A_N = k$ で固定したとき、 $k = p_1^{e_1}p_2^{e_2} \dots p_j^{e_j}$ と素因数分解できるとして
    - それぞれの素因数について $N$ 通りの選択ができる。ただし、素因数どうしの順番は問わない
      - よって素因数の種類ごとに独立して考えられ、その場合の数は $e_j$ 個のボールを $N$ 人に分けるときと等しい
    - ↑より $A_N = k$ のときの解は ${\displaystyle \prod_j \begin{pmatrix} N-1+e_j \\ e_j \end{pmatrix}}$ 個

## [ABC067 D - Fennec VS. Snuke](https://atcoder.jp/contests/abc067/tasks/arc078_b)
- $1$ 番マスを根とする木として見た場合、以下が最適な行動になる
  - `Fennec`: 自身および子孫に白マスを含む子を選ぶ
  - `Snuke`: 親を選ぶ
- 親か子かの判断は深さを見ればOK
- 白マスを子に含むかどうかは以下で判断した
    1. DFSで各マスのタイムスタンプ（ $s_i, t_i$ ）を記録する
    1. 長さ $2N$ の`bool`型配列 $A$ を用意する
      - 区間ORが必要なのでSegment treeにした
    1. $i$ 番マスを白く塗るときは $A_{s_i}$ を`true`にする
    1. $i$ 番マスが自身および子孫に白マスを含むかどうかを判断するには $A$ の区間 $[s_i, t_i]$ に`true`が存在するかどうかを判断する
- 最終的に白マスでもっとも深さが小さいマスを根とする部分木のサイズが`Snuke`の塗れるマスの数となる
  - $i$ 番マスを根とする部分木のサイズは $\lceil \frac{t_i - s_i}{2} \rceil$
- （ユーザー解説）そんな凝ったことをしなくとも $d(i, 1) \leq d(i, N)$ を満たすマスを黒で、そうでなければ白で塗ればいいだけだった……

## [ABC292 F - Regular Triangle Inside a Rectangle](https://atcoder.jp/contests/abc292/tasks/abc292_f)
- 以下 $A \leq B$ とする
- $0 \leq \theta < \frac{\pi}{2}$ として、 $xy$ 平面上に点 $P(A, A\tan\theta)$ をとり、原点を中心に $P$ を反時計回りに $60\degree$ 回転させた点を $Q(p, q)$ とすると、

$$\begin{align*}
  \begin{pmatrix} p \\ q \end{pmatrix} &= \begin{pmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta \end{pmatrix} \begin{pmatrix} A \\ A\tan\theta \end{pmatrix} \\
  &= \begin{pmatrix} \frac{1}{2}A - \frac{\sqrt{3}}{2}A\tan\theta \\ \frac{\sqrt{3}}{2}A + \frac{1}{2}A\tan\theta \end{pmatrix}
\end{align*}$$

- 点 $Q$ が領域 $[0, A] \times [0, B]$ 内にあるための必要十分条件は以下の2つを同時に満たすこと
  - $\frac{1}{2}A - \frac{\sqrt{3}}{2}A\tan\theta \geq 0 \Leftrightarrow \theta \leq \frac{\pi}{6}$
  - $\frac{\sqrt{3}}{2}A + \frac{1}{2}A\tan\theta \leq B \Leftrightarrow \theta \leq \arctan \frac{2B - \sqrt{3}A}{A}$
- よって $\theta = \min \left\{ \frac{\pi}{6},  \arctan \frac{2B - \sqrt{3}A}{A} \right\}$ のとき正三角形の1辺が最大になり、解は $\frac{A}{\cos\theta}$ となる

## [ABC386 E - Maximize XOR](https://atcoder.jp/contests/abc386/tasks/abc386_e)
- 組み合わせの全列挙：特に組み合わせそのものではなく、組み合わせに対して何らかの操作をして1つの値を得たいときに有効
  - $f$ は適当な二項演算で結合律を満たし、単位元が存在するものとする

```
void search(int current, int i, int num_rest) {
    if (num_rest == 0) {
        // currentを使って何かの操作を行う
    } else if (i < N) {
        search(f(current, a[i]), i + 1, num_rest - 1);
        search(current, i + 1, num_rest);
    }
}
```

- 計算量は $K \leq N-K$ のとき $O \left( K \begin{pmatrix} N \\ K \end{pmatrix} \right)$

## [ABC221 E - LEQ](https://atcoder.jp/contests/abc221/tasks/abc221_e)
- $i$ を固定すると
  - $j < i$ かつ $A_j > A_i$ のとき
    - $A_j$ を初項、 $A_i$ を末項とする $2^{i-j-1}$ 個の部分列は条件を満たさない
  - よって $j < i$ かつ $A_j > A_i$ を満たす $j$ の集合を $S_i$ とすると、条件を満たす部分列の個数は $2^{i-1} - 1 - \sum_{j \in S} 2^{i-j-1}$
- $\sum_{j \in S} 2^{i-j-1}$ を求めるために、長さ $N$ の全項が $0$ の数列 $B$ を用意して、 $A_i$ の大きい順に以下を行う
  - 更新: $B_i \gets 2^{N-i}$
  - 使用: $\sum_{j=1}^{i-1} B_j / 2^{N+1-i}$
  - すなわち $B$ の範囲加算ができればOK（Segment treeを用いた）
- $A_i = A_j$ のとき↑の判定を誤らないためには添字の大きい方から処理を行えばよい

## [ABC156 E - Roaming](https://atcoder.jp/contests/abc156/tasks/abc156_e)
- 発想一発系
- $k$ 回の移動で空き部屋は $\min\{ k, n-1 \}$ 部屋以下しかできないということに気づけるかどうか
- あとは数IAを丁寧にやるだけ
  - 空き部屋が $i$ 部屋になるような分け方：
    - 空き部屋の選び方： ${}_nC_i$ 通り
    - 残りの部屋への割り当て方：
      - $n-i$ 人は1人ずつ部屋に割り当てる必要があるので、残り $i$ 人を割り振って ${}_i H_{n-i}$ 通り

## [ABC223 E - Placing Rectangles](https://atcoder.jp/contests/abc223/tasks/abc223_e)
- 与えられたものを1個ずつ当てはめようとするのではなく、全体を処理して条件に当てはまるかどうかを確認するパターン
  - いわゆるゴールから逆算パターン
- 与えられた領域を $x$ 軸または $y$ 軸に平行に2回切断することで3つの領域に分ける操作を考えると、基本的には以下の4通りしかない
  - 縦→縦
  - 縦→横
  - 横→縦
  - 横→横
- 各領域へ $A,B,C$ を割り当てる方法を考える
  - 2回の切断方向が同じ場合は実質1通りしかない
  - 2回の切断方向が異なる場合は、最初に切り分けた領域に $A,B,C$ のどれが入るかで3通りある
- 以上をすべて網羅して判断すればOK

## [ABC060 D - Simple Knapsack](https://atcoder.jp/contests/abc060/tasks/arc073_b)
- $w$ の値が4種類しかないのと、 $N \leq 100$ であることから、 $w$ の値ごとに全探索（ $O(N^3)$ ）が可能

## [ABC272 E - Add and Mex](https://atcoder.jp/contests/abc272/tasks/abc272_e)
- mexの性質より各操作において加算後に $0 \leq A_i < N$ とならない要素は無視できる
- 無視できない要素を $j = 1, 2, \dots, M$ のそれぞれにおいて評価する回数の和は $\sum_{i=1}^N \frac{N}{i}$ 回程度、すなわち $O(N \log N)$ 程度
- 初期状態で $A_i < 0$ である要素は何回目の操作ではじめて $A_i \geq 0$ となる（or $A_i \geq 0$ となることはない）のかがあらかじめわかる
- よって初期状態で $0 \leq A_i < N$ をみたす $A_i$ による多重集合を $S$ として、 $j = 1, 2, \dots, M$ の順に以下を行えばOK
    1. $S$ 内のそれぞれの要素 $A_i$ について
        - $A_i + i < N$ ならば $S$ 内で $A_i$ を $A_i + i$ に更新する
        - $A_i + i \geq N$ ならば $S$ から削除する
    2. $j$ 回目にはじめて $A_i \geq 0$ となる要素を $S$ に挿入する
    3. mexを求める
- $S$ とは別に $S$ 内の要素 $A_i$ に対して $A_i = k$ となる要素数 $T_k$ を管理することで、 $T_k > 0$ となる最小の非負整数 $k$ をmexとすることができる
  - $T$ を`atcoder/segtree`で管理すれば`max_right`に任せられる
- 全体計算量は $O(N (\log N)^2)$

## [ABC306 F - Merge Sets](https://atcoder.jp/contests/abc306/tasks/abc306_f)
- 概ね公式解説通りの考え方
- ${\displaystyle f(A, B) = \sum_{i \in A} \left\lvert \{ j \ | \  j \in A \cup B, j \leq i \} \right\rvert}$ からごちゃごちゃ変形していけば
  - 最終的に ${\displaystyle \left\{ k \ \middle| \ k \in \bigcup_{i' = i+1}^{N} S_{i'}, k \leq A_{i, j} \right\}}$ の個数が分かればなんとかなることがわかる
    - 後ろからFenwick treeなどで走査すればOK

## [ABC250 E - Prefix Equality](https://atcoder.jp/contests/abc250/tasks/abc250_e)
- Zobrist hashを使うやり方でやってみた
- メモ：C++で乱数を扱う

```cpp
#include <random>

// 初期化
mt19937_64 gen(seed);  // seedは適当な値で
uniform_int_distribution<ll> rnd(a, b); // 区間[a,b]の整数の一様分布
// 使用
ll val = rnd(gen);
```

- $S_i$ を $\{ a_1, a_2, \dots, a_i \}$ のハッシュとするとき
  - $a_{i+1} \in \{ a_1, a_2, \dots, a_i \}$ のとき $S_{i+1} = S_i$
  - $a_{i+1} \notin \{ a_1, a_2, \dots, a_i \}$ のとき $S_{i+1} = S_i \oplus f(a_{i+1})$
    - ただし $f(x)$ は $x$ に対して適当な乱数を割り当てたもの
- $B$ に対しても同様にハッシュを定義すればOK
- 衝突しない確率は余剰ビット数を $m$ として $\exp(2^{-m})$ 程度
  - 部分集合の数が $N \approx 2^{17}$ で61ビットの乱数を用いたので $m = 44$ すなわち衝突しない確率が $5.7 \times 10^{-14}$ 程度
    - 宝くじ1等が当たるより遥かに低い確率なので問題ないでしょう


## [ABC391 F - K-th Largest Triplet](https://atcoder.jp/contests/abc391/tasks/abc391_f)
- $f(i, j, k) = A_iB_j + B_jC_k + C_kA_i$ とおく
- `priority_queue`で $f(i, j, k)$ を降順に保持しながら
  - 先頭を取り出して（未探索かつ範囲内なら） $f(i+1, j, k), f(i, j+1, k), f(i, j, k+1)$ を挿入を繰り返せばOK
    - 実際には`priority_queue`に $(f(i, j, k), i, j, k)$ のタプルを持たせた
    - `visited`の更新タイミングに注意

## [ABC279 E - Cheating Amidakuji](https://atcoder.jp/contests/abc279/tasks/abc279_e)
- $C = (1, 2, \dots, N)$ に対して $k = M, M-1, \dots, i+1$ の順に操作を、 $B$ に対して $k = 1, 2, \dots, i-1$ の順に操作を行う
  - このとき $B_j = 1$ となる $j$ を用いると解は $C_j$ となる
- $C$ は数列のすべてを保持する必要があるため普通にやれば空間計算量 $O(NM)$ になるが、in-placeに更新すれば $O(N)$ にできる
  - よってあらかじめ $k = 1, 2, \dots, M$ に対してそれぞれ $B_j = 1$ となる $j$ を記録しておくと $i = M, M-1, \dots, 1$ の順で解を求められる
- 公式解説でいうところの前後からの累積和を用いた恰好となった

## [AGC057 A - Antichain of Integer Strings](https://atcoder.jp/contests/agc057/tasks/agc057_a)
- （公式解説） $f$ が狭義単調増加であることにに気づかなかったぜ……
  - 解がどうも連続した整数になることには気づいていたので、何かしらの単調性を満たすものが存在して二分探索で求めることを疑うべきだった

## [ARC113 D - Sky Reflector](https://atcoder.jp/contests/arc113/tasks/arc113_d)
- $N=1$ の場合 $A_1$ は $B$ の内容により一意に定まるので、解は $K^M$
  - $M=1$ の場合も同様
- $N>1, M>1$ のとき
  - 任意の $j$ に対し $B_j \geq \max A$ さえ成り立てばあとは自由にできる
    - $\max A = k$ となる $A$ の個数は $K^N - (K-1)^N$ であり、そのそれぞれに対して $B$ が $(K-k+1)^M$ 個あるので
      - 解は $\sum_{k=1}^K (K^N - (K-1)^N)(K-k+1)^M$
- 計算量は $O(K \log P)$

## [AGC033 B - LRUD Game](https://atcoder.jp/contests/agc033/tasks/agc033_b)
- 初期配置として可能な範囲を後ろから探索していくパターン
  - 探索途中で可能な範囲がなくなった場合は即`NO`を返す

## [ABC080 D - Recording](https://atcoder.jp/contests/abc080/tasks/abc080_d)
- 番組 $i,j$ が同じチャンネルで、一方の終了からもう一方の開始までが1秒以下のとき、この2つをまとめて扱うようにする
  - 具体的にはチャンネルごとに番組を分けて $(s_i, t_i)$ を $s_i$ の昇順でソートし、 $s_{i+1} - t_i \leq 1$ となる場合、 $t_i \get t_{i+1}$ として $(s_{i+1}, t_{i+1})$ を削除する
  - 削除の際の計算量を考慮して`set`を用いた（正直`list`で良かった気がする……）
- あとはいもす法で最大の区間の重複数を数えるだけ

## [ABC197 E - Traveler](https://atcoder.jp/contests/abc197/tasks/abc197_e)
- 同色のボールの回収方法については以下のいずれか以外は無駄に動くことになる
  - 座標が最大となるボールまで行って、座標が最小となるボールまで一直線に回収する
  - 座標が最小となるボールまで行って、座標が最大となるボールまで一直線に回収する
- よってDPを2種類用意して更新した
  - $\mathrm{dp}_{i,1}$: 色 $i$ のボールのうち座標が最小になるものを最後に回収する際における、今までの移動距離の和の最小値
  - $\mathrm{dp}_{i,2}$: 色 $i$ のボールのうち座標が最大になるものを最後に回収する際における、今までの移動距離の和の最小値

## [ARC161 D - Everywhere is Sparser than Whole (Construction)](https://atcoder.jp/contests/arc161/tasks/arc161_d)
- 完全グラフの辺数が $\frac{N(N-1)}{2}$ であることから、 $ND$ がこれを超える際は問答無用で`No`
- そうでない場合は必ず`Yes`にできて、以下のように構築する
- $d = 1, 2, \dots, D$ の順に以下を行う
  - $i = 1, 2, \dots, N$ の順に頂点 $i$ と $i+d$ に辺を張る
    - ただし、 $k>0$ に対し頂点 $N+k$ は頂点 $k$ と同一とする
- 誘導部分グラフの疎性に関しては、↑でできるグラフがどの頂点に対しても対称性があること、および $N=5,6,7$ あたりで試したところ反例がなかったことからまぁ大丈夫でしょと踏んだ（おい）

## [ABC224 D - 8 Puzzle on Graph](https://atcoder.jp/contests/abc224/tasks/abc224_d)
- 盤面をそのままキーにしてBFSするやつ
- 盤面は9文字の文字列にでき、想定される盤面数は最大でも $9! \approx 3.6 \times 10^5$ であり、文字列のコピーを考えてもその9倍程度の計算量なので十分間に合う

## [ABC047 D - 高橋君と見えざる手](https://atcoder.jp/contests/abc047/tasks/arc063_b)
- 結局のところ高橋君は $A_j - A_i$ が最大になるような $i < j$ を選び、町 $i$ で $\lfloor \frac{T}{2} \rfloor$ 個のリンゴを買って町 $j$ ですべて売るのがベストとなる
- よって $A_j - A_i$ が最大になるような $i < j$ の組が何組あるのかを数えればそれがそのまま解になる

## [ARC119 C - ARC Wrecker 2](https://atcoder.jp/contests/arc119/tasks/arc119_c)
- $S_{l,r}$ および $T_{l,r}$ を $l \leq i \leq r$ かつ2で割り切れる/割り切れないような $i$ に対して $A_i$ の和を取ったものとすると
  - 操作によって $S_{l,r} - T_{l,r}$ は変化しない
- 計画が達成できる $(l,r)$ に対して最終的に $S_{l,r} = T_{l,r} = 0$ にしなければならないことから、必要十分条件は $S_{l,r} - T_{l,r} = 0$ であることがわかる
- あとは $i = 1, 2, \dots, N$ に対して $S_{0,i}, T_{0,i}$ を計算し、$S_{0,i} - T_{0,i} = k$ を満たす $i$ の集合を $U_k$ とすれば
  - 解は $\sum_{k} |U_k|(|U_k| - 1)/2$
    - （要するに累積和の値の種類ごとに組み合わせ数を考えるいつものパティーン）

## [ABC087 D - People on a Line](https://atcoder.jp/contests/abc087/tasks/arc090_b)
- Weighted Union-Find treeで一発
  - ライブラリ化しておくとこういうとき楽でいい……

## [ABC367 F - Rearrange Query](https://atcoder.jp/contests/abc367/tasks/abc367_f)
- どうみてもハッシュじゃないと間に合わないよなぁと思い「多重集合　ハッシュ」で検索をかけると
  - モロにこの問題がヒットして草ァ！
    - ……それは見ないようにして、[競技プログラミングにおけるハッシュ問題まとめ - はまやんはまやんはまやん](https://blog.hamayanhamayan.com/entry/2017/05/24/154618)を参考にした
      - [chokudai社長のポスト](https://x.com/chokudai/status/875112616523218944)へのリンクがあり、曰くZobrist hashingでXORではなく単に和を取れば多重集合に対応できるとのこと
- 間違えてハッシュ最大値を $2^{58}-1$ に設定したので $N$ 個の和がオーバーフローする可能性があったが、問題なくいけてしまった
  - 理屈から行けば問題無さそうではある（本当か？）

## [全国統一プログラミング王決定戦予選(2019) D - Restore the Tree](https://atcoder.jp/contests/nikkei2019-qual/tasks/nikkei2019_qual_d)
- 追加される辺はある頂点から子孫への方向に限られることから、以下の操作で木を復元できる
    1. 入次数 $0$ の頂点を見つけ、これを根とする。これは必ずちょうど1個のみ存在する。
    1. キューを用意し、根を入れる
    1. キューが空になるまで以下を行う
        1. キューから頂点を1つ取り出し、これを $u$ とする
        1. 頂点 $u$ とそれに隣接する辺を取り除く
        1. 入次数が $0$ になる頂点 $v$ が存在すれば、 $v$ の親として $u$ を記録して $v$ をキューに入れる
- 実際に頂点や辺を取り除かなくとも、各頂点の入次数さえ管理できていれば問題ない

## [ABC122 D - We Like AGC](https://atcoder.jp/contests/abc122/tasks/abc122_d)
- $\mathrm{dp}_{i,s}$ を $i$ 文字で末尾3文字が $s$ になるような条件を満たす文字列の個数として普通にDPするだけ
  - 遷移の際は文字列 $s$ および今から加えようとする文字（`A`, `C`, `G`, `T`）を連結したものを $t$ として、以下をすべて満たせば遷移可能
    - $t$ の末尾3文字が`ACG`, `AGC`, `GAC`のいずれでもない
    - $t$ の $1,2,4$ 文字目を繋いで`AGC`にならない
    - $t$ の $1,3,4$ 文字目を繋いで`AGC`にならない
- 間違って $\bmod \ 998244353$ でやってプチパニック
  - 問題文はよく読もう

## [ABC161 F - Division or Subtraction](https://atcoder.jp/contests/abc161/tasks/abc161_f)
- 非負整数 $m, q$ を用いて $N = K^m(qK+1)$ と表されるような $K$ が条件を満たす
- $K \leq \sqrt{N}$ のとき
  - $K$ で割れるだけ割って最後に余りが $1$ になることを確認するので、$K$ 1つあたり $O(\log N)$ で判定できる
- $\sqrt{N} < K < N$ のとき
  - $m \geq 1$ を仮定すると
    - $q \geq 1$ のとき $K^m(qK+1) \geq qK^2 + K > qN + K > N$ となり矛盾
    - $q = 0$ のとき $K^m(qK+1) = K^m$ となるが、$m = 1$ ならば $K^m < N$ 、$m \geq 2$ ならば $K^m > N$ よりやはり矛盾
  - よって $m = 0$ が得られ $N = qK + 1$ となる
  - すなわち $K$ が $N-1$ の約数となればよいので、まとめて $O(\sqrt N)$ で判定できる
- $K = N$ のとき
  - 必ず条件を満たす
- 以上により計算量は $O(\sqrt{N} \log N)$
- （公式解説）制約を見た瞬間にどうせ平方分割やろと思って↑のようにしたが、 $N$ の約数と $N-1$ の約数に分けて考える方法もあったのか

## [ABC189 E - Rotate and Flip](https://atcoder.jp/contests/abc189/tasks/abc189_e)
- アフィン変換はゲームプログラミングで知っていたので、あとは累積積を計算するのみ

## [ABC095 D - Static Sushi](https://atcoder.jp/contests/abc095/tasks/arc096_b)
- 中橋くんの動きは「時計回りに $0$ m以上進んでから、反時計回りに合計が $C$ m以下になるように $0$ m以上進む」（あるいはその逆）が最適となり、それ以外は余分にエネルギーを消費する
  - さらに、動いた範囲にある寿司はすべて食べないと明らかに損をする
- $x_i, y_i$ を入店時の中橋くんから見て時計回り/反時計回りに $i$ 番目の寿司までの位置、 $S_i, T_i$ を同寿司までをすべて食べたときに得られるエネルギーの和とする
  - 便宜上 $x_0 = y_0 = S_0 = T_0 = 0$ とする
- このとき時計回りに $i$ 番目まですべて食べて、折り返して反時計回りに $j$ 番目までの寿司を食べたときのエネルギー収支は $S_i + T_j - 2x_i - y_j$
  - ただし $2x_i + y_j \geq C$ となる場合は折り返さずに進んだほうが明らかに得となる
  - よって $i$ を固定して考えると、考えるべき $j$ の範囲は $y_j < C - 2x_i$ が成り立つ範囲に絞れ、この範囲内で $T_j - y_j$ が最大になるようにすればよい
    - $y_j$ は単調増加なので二分探索が可能、かつ $j$ の範囲は必ず $[0, j_{\max}]$ の形になるので $T_j - y_j$ の累積最大値をあらかじめ求めておけばOK
- 同様にはじめに反時計回りに進むパターンも探索できる
- $i$ を固定したときの計算量が $O(\log N)$ なので全体で $O(N\log N)$ で解ける

## [CODE FESTIVAL 2016 Final C - Interpretation](https://atcoder.jp/contests/cf16-final/tasks/codefestival_2016_final_c)
- 人を頂点にしたグラフで同じ言語の話者どうしを辺で繋げば、人 $i,j$ がコミュニケーションを取れるかどうかはグラフで頂点 $i, j$ が連結かどうかに読み替えられる
  - よってあとはUnion-Find木に任せて、最終的に連結成分が1つになっているかどうかを確認するのみ
    - この際、Union-Findの性質上、同じ言語の話者が $k$ 人いるとして組み合わせすべて（ ${}_{k}C{2}$ 通り）を網羅する必要はなく、 $k$ 人が連結になるように $k-1$ 個の辺を張ればOK

## [ABC274 E - Booster](https://atcoder.jp/contests/abc274/tasks/abc274_e)
- $N+M \leq 17$ からbit探索ができそう
- この手の問題によくある「訪れた箇所の集合」「最後に訪れた箇所」の2要素bit DPでやった
  - 街と宝箱をまとめてやれば無駄に悩むこともない
- 現在の移動速度は「訪れた箇所の集合」から宝箱に関する部分だけ抜き取り`popcount`すればすぐに分かる
- 計算量は $O(2^{N+M}(N+M)^2)$
  - $2^{N+M}(N+M)^2 \approx 3.8 \times 10^7$ なので結構重いと思いきや、実際の遷移はかなり少ないようで90msで通った

## [ABC210 D - National Railway](https://atcoder.jp/contests/abc210/tasks/abc210_d)
- 現在いるマスを $(x, y)$ として、「他方の駅を $(i, j)$ にしたときにその駅と線路を建設するのに必要な費用」をLazy Segment treeにぶち込み、 $(x, y)$ を変化させるときに適切にセグ木を更新しながら最小値を取る方針にした
  - ABCのD問題でLazy Segment treeは絶対想定解じゃないよなぁと思いつつも計算量 $O(HW\log HW)$ でいけそうだったのでつい……
    - 結果1420msながらも無事に`AC`
- 現在いるマスを変更するときに必要な計算量を減らすために、$(1, 1) \to (2, 1) \to \dots \to (H, 1) \to (1, 2) \to \dots \to (H, W)$ の順に見ていった
  - $(x, y) \to (x+1, y)$ の際は $i \leq x$ を満たすすべてのマスに $+C$ 、$i > x$ を満たすすべてのマスに $-C$ を加算
    - 1次元のLazy Segment treeでそれぞれ区間 $[1, iW], [iW+1, HW]$ に相当する
  - $(H, y) \to (1, y+1)$ の際は $j \leq y$ を満たすすべてのマスに $+C$ 、$j > y$ を満たすすべてのマスに $-C$ を加算
    - 1次元のLazy Segment treeでそれぞれ区間 $[(i-1)W + 1, (i-1)W + j], [(i-1)W + j+1, iW]$ に相当する（ $i = 1, 2, \dots, H$ ）

## [HHKB2020 E - Lamps](https://atcoder.jp/contests/hhkb2020/tasks/hhkb2020_e)
- マス $(i,j)$ に対し、そのマスから上下左右の4方向それぞれに直進したときに散らかっているマスor壁にぶつかるまでに存在する散らかっていないマスの集合（そのマス自身を含む）を $T_{i,j}$ とおくと
  - マス $(i,j)$ が照らされる必要十分条件は $T_{i,j}$ に含まれるマスの1個以上に照明が置かれていること
    - よって $T_{i,j}$ に含まれないマスも併せて考えると、マス $(i,j)$ が照らされるような照明の置き方は $2^{K-|T_{i,j}|} (2^{|T_{i,j}|}-1)$ 通り
      - 以上により、解は $\sum_{i=1}^H \sum_{j=1}^W 2^{K-|T_{i,j}|} (2^{|T_{i,j}|}-1)$
- $T_{i,j}$ の要素数さえわかればいいので、各行あるいは各列で壁or散らかっているマスから次の壁or散らかっているマスの間に存在するマスの個数を数えればOK
  - マス $(i,j)$ 自身を2度カウントしてしまうことに注意

## [ABC392 F - Insert](https://atcoder.jp/contests/abc392/tasks/abc392_f)
- 公式解説と同じ発想に至ったが、 $T_i$ 以降が思いつかずSplay treeを自作して`AC`
  - …のだが、なんとも中途半端なSplay treeを作ってしまったらしく他の問題に使えるかどうかはわからない
- （公式解説）狭義単調増加列への挿入・削除・ランダムアクセス操作: 
  - $A_i = k$ となる要素が存在するかどうかを $0$ または $1$ からなる列 $T_k$ で管理し、その累積和 $S_k$ を用いて二分探索

## [ABC326 D - ABC Puzzle](https://atcoder.jp/contests/abc326/tasks/abc326_d)
- 条件1より、各行は`.` $N-3$ 文字と`A`,`B`,`C`各1文字をこの順でつなげた文字列（以下これを $S_0$ とする）を並び替えてできる文字列であり
  - それが $N$ 行あることから、全事象は $({}_N P_3)^N < 7.8 \times 10^8$ 通り
- このままだと計算量が怪しく見えるが、条件2より各行に使える文字列は実際には ${}_N P_3 /3$ 通りになり
  - $S_0$ を並び替えてから条件2を満たさないものを弾く実装でも、（弾くのに必要な計算量も含めて） $N=5$ において $1.5 \times 10^7$ 程度の計算量になる
- あとは↑を通過した $({}_N P_3/ 3)^N \leq 3.2 \times 10^6$ 通りに対し条件1の列の条件および条件3を満たすかどうかを確認すればOK
  - 確認は1つあたり $O(N^2)$ でこれまた計算量が怪しく見えるが、条件3は各列ごとに均して先頭 $\frac{N+1}{4}$ 文字を見ればわかるため早期returnで思いの外大丈夫である
- とはいえこの雑な絞り込みかつDFSのときに各行を`push`/`pop`するような雑な実装でも132msしかかからないのには驚いた
  - ~~アロケーションって実は $O(N^2)$ の操作なのでは？と思えてしまう~~

## [ABC212 E - Safety Journey](https://atcoder.jp/contests/abc212/tasks/abc212_e)
- どう見ても2要素DPで一見すると計算量が $O(KN^2)$ に思えるが
  - 最も内側のループは全体で $2M$ 回しか回らないというよくあるパティーン
- 結果として計算量は $O(K(N+M))$ なので余裕で間に合う

## [ABC385 E - Snowflake Tree](https://atcoder.jp/contests/abc385/tasks/abc385_e)
- ある頂点をユ木の中心とした場合、その頂点の隣接頂点のうち $x$ 個を選んで、 $y$ を選んだ頂点の次数の最小値未満にすることでユ木を構築できる
- ユ木に使われる頂点数は $1+x(y+1)$ であることから、この値ができる限り大きくなるようにすればよい
  - よって隣接頂点のうち次数の大きい方から $x$ 個選んで、 $y$ を選んだ頂点の次数の最小値-1にすればOK
    - 具体的に $x,y$ をいくらにすべきかは探索に任せる
    - 問題の条件を満たさない $y = 0$ も探索対象になるが、このとき中心となる頂点を選び直すことで $x = 1, y = x-1$ のユ木にできるため問題ない
- $A_i$ を頂点 $i$ に隣接する頂点の次数を降順に並べた**列**とすると、 $x = 1, 2, \dots, |A_i|$ のそれぞれに対し $y = A_{i,x} - 1$ と $O(1)$ で $y$ を求めることができる
  - $\sum_i^N |A_i| = 2(N-1)$ であることからソートを除いて全体 $O(N)$ で解が求まるし、ソートも最悪 $O(N \log N)$ なのでこの方針でOK

## [ABC271 E - Subsequence Path](https://atcoder.jp/contests/abc271/tasks/abc271_e)
- 同じ頂点を2度通るのは明らかに損なので拡張Dijkstraでいけるやろ→ものの見事に`WA`
  - 恐らくは本来満たすべき優先順位は良い経路→短い経路なのだが、Dijkstraだと短い経路→良い経路になってしまっているのが原因
- （公式解説）グラフのパスの問題なのにそれを放り投げて $E_i$ をキーにしてDPとは流石に思わなんだ……
  - もっとも優先して考えるべきなのは $E$ だからということか
    - 数IIBで接線の方程式を求めるのに先に接点を文字で置いとかないと大変なことになるってやつを思い出した……

## [Tenka1 Programmer Contest (2018) D - Crossing](https://atcoder.jp/contests/tenka1-2018/tasks/tenka1_2018_d)
- グラフに置き換えて考える問題
- 集合 $S_i, S_j$ に共通するただ1つの要素を $a_{i,j}$ とする
  - 各集合を頂点としたとき、頂点 $i, j$ 間にラベル $a_{i,j}$ の辺を張り、 $S_i$ は頂点 $i$ に隣接する辺のラベルによる集合とすれば
    - 題意よりラベルは $1, 2, \dots, N$ が1つずつで、すべての頂点間に辺が張られる（すなわち、完全グラフになる）
- よって $N$ が $K$ 頂点の完全グラフの辺数になるときは題意を満たす部分集合の組が作れる
  - そうでなければ`No`である
- あとは間違わないように構築するのみ
  - ラベル $i$ の辺について、 $i$ を $K$ で割った商と余りをそれぞれ $q,r$ として頂点 $r$ と頂点 $r+q+1$ を結ぶものとした
    - （ただし $N+j$ と表される頂点は頂点 $j$ を示すものとする）

## [ARC176 A - 01 Matrix Again](https://atcoder.jp/contests/arc176/tasks/arc176_a)
- $M$ 種類の値 $k$ に対して0-indexedで $i+j \bmod N = k$ となるマスに $1$ 、それ以外に $0$ を書き込めば、条件2・3はクリアできる
- よって入力された $(A_i, B_i)$ に対し $A_i + B_i \bmod N$ を計算して記録し、それが $M$ 種類に足りなければ適当なものを補充してやればOK
- $10^6$ オーダーの`cout << ... << endl;`を何も工夫せずにしたためか結構時間かかってて（1016ms）草

## [ABC184 F - Programming Contest](https://atcoder.jp/contests/abc184/tasks/abc184_f)
- $A_i \leq 10^9$ なのでナップサックDPは厳しい
  - しかしすべての問題を解くか解かないかの場合の数は $2^N \approx 1.1 \time 10^{12}$ 通りであり、これも`TLE`
- だが半分全列挙なら大丈夫
  - 前半 $\lfloor \frac{N}{2} \rfloor$ 問を全列挙し、これらを解く時間の和を記録して昇順にソートしておく
    - この時点で $T$ を超えるものは記録しなくてよい
  - 後半 $\lceil \frac{N}{2} \rceil$ 問を全列挙し、これらを解く時間の和を求める
    - そして前半で求めておいたものと合計して $T$ 以下になる最大のものを二分探索で求める
- 計算量は $O(N2^{\frac{N}{2}})$ であり $10^7$ のオーダーに収まる

## [ABC175 D - Moving Piece](https://atcoder.jp/contests/abc175/tasks/abc175_d)
- 与えられるグラフが単なるfunctional graphよりももっと制約の厳しいものである点に注意
  - 全頂点の入次数・出次数ともに $1$ なのでサイクルしか存在しない
- 逆に $O(N^2)$ が許されるのでサイクルごとにどの区間がもっとも得で……などとやらずにもっと雑でよい
  - 単に開始地点だけ決めてサイクルに満たない分をどれだけ進むか、その上でサイクルするかどうかを決めるだけでOK

## [ABC051 D - Candidates of No Shortest Paths](https://atcoder.jp/contests/abc051/tasks/abc051_d)
- $N \leq 100$ より $O(N^3)$ なのでFloyd–Warshall法が使える
- 最短経路に含まれないということは他にもっと短い経路がある、すなわち $d(u, v) < E_{u,v}$ が成り立つ

## [ARC155 B - Abs Abs Function](https://atcoder.jp/contests/arc155/tasks/arc155_b)
- $||x-a|-b| = \min \{ |x - (a-b)|, |x - (a+b)| \}$ より $S' = \{ a+b, a-b | (a,b) \in S \}$ とおくと $f_S(x) = \min_{y \in S'} |x-y|$ となることがわかる
- よって $S'$ を管理するものとして`set s`を用意し、 $A+B, A-B$ を突っ込んだうえで各クエリを処理する
  - タイプ1のクエリでは $S'$ に $a_i + b_i, a_i - b_i$ を突っ込む
  - タイプ2のクエリでは以下を行う
    - `left = s.lower_bound(a)`, `right = s.lower_bound(b)` とする
    - `left != right`ならある $y \in S'$ が存在して $a \leq y \leq b$ となることがわかるので、解は $0$ になる
    - `left == right`ならある連続する $y_1, y_2 \in S$ （すなわち $y_1 < y < y_2$ を満たす全ての $y$ に対し $x \notin S'$ ）が存在して $y_1 < a \leq b < y_2$ であることがわかるので、解は $\min \{ a - y_1, y_2 - b \}$ となることがわかる
    - ↑をスムーズに行うために、絶対値の十分大きな $M$ を用いて $M, -M$ を番兵として`s`にあらかじめ突っ込んでおくと楽

## [ABC074 D - Restoring Road Network](https://atcoder.jp/contests/abc074/tasks/arc083_b)
- Floyd–Warshall法をやりながら $A_{i,j} > A_{i,k} + A_{k,j}$ なら即`-1`で、 $A_{i,j} = A_{i,k} + A_{k,j}$ なら辺 $A_{i,j}$ を削除すればよい……のだが
  - $A_{i,j} = A_{i,k} + A_{k,j}$ なら辺の長さの合計から $A_{i,j}$ を引くという実装にしてしまったため、 $(i,j)$ に対して $A_{i,j} = A_{i,k} + A_{k,j}$ を満たす $k$ が2つ以上あると余分に引かれるというバグを仕込んでしまった
    - $A_{i,j}$ が必要かどうかを管理するフラグを導入して解決した
