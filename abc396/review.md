# [ABC396](https://atcoder.jp/contests/abc396) Review
- バーチャル参加
- CとFでしょうもないミスをやらかして15分追加したがなんとか1100位台相当

## C - Buy Balls
- AC(2WA)
- **インデックスを間違えそうな実装はしない！**

## D - Minimum XOR Path
- AC
- メモ：単純パスの全列挙
  - DFSで帰りがけ時に`visited[from] = false`とする
```
void dfs(int from) {
    visited[from] = true;
    // ここで到着判断
    for (const int& to : g[from]) {
        if (visited[to]) continue;
        dfs(to);
    }
    visited[from] = false;
}
```

## E - Min of Restricted Sum
- 時間切れ
- グラフにしてビットごとに辺に矛盾しない数値を割り当てる（ただしビットの割り当て方が2通りあるので両方試す）という概ねの方向性は合っていたが
  - その2通りのビットの割り当て方が連結成分ごとに判断しなければならない点に気づかずWAのままタイムオーバー

## F - Rotated Inversions
- AC(1RE)
- $k$ を1ずつ増やしていったときに大半の項の大小関係は変化しないことから、まずは $k=0$ で普通に転倒数を求め、 $k$ を1ずつ増やしながら転倒数の差分をカウントする方向で
- $k$ を1増やしたとき
  - 増やす前に $B_i = M - 1$ となる項が増やした後に $B_i = 0$ となるが、数列 $B$ 内で $M-1$ より大きい項も $0$ より小さい項も存在しないことから以下が言える
    - $j < i$ かつ $B_j \neq B_i$ を満たす $j$ の個数だけ転倒数が増える
    - $j > i$ かつ $B_j \neq B_i$ を満たす $j$ の個数だけ転倒数が減る
  - 他の項は全て $+1$ されるだけなので転倒数の増減には寄与しない
- よってあらかじめ $A_i = n$ となる全ての $i$ を $n$ で逆引きできるようにしておき、 $n + k = M$ となるタイミングで↑を数えて転倒数を更新すればOK
- なお $N$ と $M$ を取り違えて1敗
