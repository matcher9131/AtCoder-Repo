# [Educational DP Contest / DP まとめコンテスト](https://atcoder.jp/contests/dp) Review

## A - Frog 1
- $\mathrm{dp}_i: $ 足場 $1$ から $i$ まで行くのに必要なコストの総和の最小値
- 1要素のベーシックなDP
- 時間 $O(N)$ 、空間 $O(N)$

## B - Frog 2
- $\mathrm{dp}_i: $ 足場 $1$ から $i$ まで行くのに必要なコストの総和の最小値
- A問題との差は遷移先が2つから $K$ 個に増えただけ
- 時間 $O(NK)$ 、空間 $O(N)$

## C - Vacation
- $\mathrm{dp}_{i,j}: $ $i$ 日目にした行動が $j$ のときの、初日から $i$ 日目までに得られる幸福度の最大値
- $\mathrm{dp}_{i,j}$ から $\mathrm{dp}_{i+1,j}$ への遷移を禁じればOK
- 行動の種類数を $M$ として 時間 $O(NM)$ 、空間 $O(NM)$

## D - Knapsack 1
- $\mathrm{dp}_{i,j}: $ $i$ 番目までのナップサックからいくつか選んで重さの総和が $j$ になるときにあり得る価値の総和の最大値
- 典型的なナップサック問題
- 時間 $O(NW)$ 、空間 $O(NW)$

## E - Knapsack 2
- $\mathrm{dp}_{i,j}: $ $i$ 番目までのナップサックからいくつか選んで価値の総和が $j$ になるときにあり得る重さの総和の最小値
- $O(NW)$ が`TLE`する典型的パターン
- $\max_i v_i = V$ として時間 $O(N^2V)$ 、空間 $O(N^2V)$

## F - LCS
- 恐らく題意として意図されたものはDP復元だよなぁと思いつつも、時間計算量が間に合いそうだったので文字列そのものを保持するDPでやってみた
  - 流石に文字列のコピーが何度も発生するので速くはないが1162msで通った
- $\mathrm{dp}_i: $ 題意を満たすような文字列で $t_i$ を末尾とするもののうち最長のもの
- $i = 1, 2, \dots, |s|$ の順に以下のように遷移する
  - $j = |t|, |t|-1, \dots, 1, 0$ の順に以下を行う
    - $t_k = s_i$ を満たす最小の $k > j$ が存在すれば、
      - $X = \mathrm{dp}_j + s_i$ とし、 $|X| > |\mathrm{dp}_{k}|$ ならば $\mathrm{dp}_{k} \gets X$
    - あらかじめ $t_i = c$ となる $i$ の集合 $T_c$ を用意しておくことで $k$ を $O(\log |t|)$ で求められる
    - in-placeなDPなので、 $j$ を逆順で更新することにより一度更新したものをもう一度更新してしまうことを防ぐ必要がある
- 時間 $O(|s||t| \log |t|)$ 、空間 $O(|s||t|)$

## G - Longest Path
- 有向閉路が存在しない、すなわちDAG
  - よってトポロジカルソートを行い頂点番号を振り直しておく
- $\mathrm{dp}_i: $ 頂点 $i$ を終端とするパスの長さの最大値
- $i = 1, 2, \dots, N$ の順に以下のように遷移する
  - $i$ と隣接する頂点 $j$ に対し、 $\mathrm{dp}_j \gets \max \{ \mathrm{dp}_j, \mathrm{dp}_i + 1 \}$
- in-placeなDPだが配るDPで更新することで更新順を固定できる
- 時間 $O(N+M)$ 、空間 $O(N)$
- （公式解説）メモ化DPにすれば明示的なトポロジカルソートは不要

## H - Grid 1
- $\mathrm{dp}_{i,j}: $ $(1,1)$ から $(H,W)$ へ移動する方法の場合の数
- 初期値 $\mathrm{dp}_{1,1} = 1$ として、遷移先（ $(i, j+1), (i+1, j)$ ）が壁でなければ $\mathrm{dp}_{i,j}$ を加える
- 時間 $O(HW)$ 、空間 $O(HW)$

## I - Coins
- $\mathrm{dp}_{i,j}: $ コイン $1$ から $i$ までを投げて出た表の枚数が $j$ になる確率
- 初期値 $\mathrm{dp}_{0,0} = 1$ として以下のように遷移する
  - $\mathrm{dp}_{i, j} \gets (1 - p_i) \mathrm{dp}_{i-1, j}$
  - $\mathrm{dp}_{i, j} \gets p_i \mathrm{dp}_{i-1, j-1}$
- 時間 $O(N^2)$ 、空間 $O(N^2)$

## J - Sushi
- $\mathrm{dp}_{i,j,k}: $ 寿司が3個、2個、1個乗った皿がそれぞれ $i,j,k$ 枚あるとき、これらの寿司を全て食べるまでにサイコロを振る回数の期待値
- $\mathrm{dp}_{i,j,k} = 1 + \frac{i}{N} \mathrm{dp}_{i-1,j+1,k} + \frac{j}{N} \mathrm{dp}_{i,j-1,k+1} + \frac{k}{N} \mathrm{dp}_{i,j,k-1}$
  - ただし $i = 0$ なら $\mathrm{dp}_{i-1,j+1,k}$ を、 $j = 0$ なら $\mathrm{dp}_{i,j-1,k+1}$ を、 $k = 0$ なら $\mathrm{dp}_{i,j,k-1}$ をそれぞれ $\mathrm{dp}_{i,j,k}$ に置き換える（もう寿司が無いので食べられず現状と変わらない）
    - 両辺に $\mathrm{dp}_{i,j,k}$ が存在するので移項が必要となる
- 時間 $O(N^3)$ 、空間 $O(N^3)$
