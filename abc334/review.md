# [ABC334](https://atcoder.jp/contests/abc334) Review
- バーチャル参加
- ~~なんでや！阪神関係無いやろ！~~
- Fまで解けて400位相当
  - これをRatedで出したい
- どう考えてもCとDが逆なんだよなぁ……

## C - Socks 2
- AC（24分）
- 思いの外難しくてビビる
  - 実際のところABCのC問題としては異例の緑色のようで
- 以下 $M = \lfloor \frac{2N - K}{2} \rfloor$ とする
- すべての存在する靴下を色の昇順で並べた列を $B$ とする
  - $2N - K$ が偶数のとき
    - 先頭から順に2枚を1組にすればOK
  - $2N - K$ が奇数のとき
    - 以下の2つの列を用意する
      - $C = B_2 - B_1, B_4 - B_3, \dots, B_{2M} - B_{2M-1}$
      - $D = B_3 - B_2, B_4 - B_3, \dots, B_{2M} - B_{2M-1}$
    - $B_{2i} (1 \leq i \leq M)$ を使わなかったときの奇妙さの合計は $\sum_{k=1}^i C_i + \sum_{k=i}^M D_i$
    - $B_{2i-1} (1 \leq i \leq M+1)$ を使わなかったときの奇妙さの合計は $\sum_{k=1}^{i-1} C_i + \sum_{k=i}^M D_i$
    - よって $B_{2i-1}$ を使わなかったときのみ全探索して最小になるものを答えればよい
- $K$ が奇数のときに $O(N)$ で全探索できる方法を思いつくのにそれなりに時間を要してしまった
  - 結果Fと大して変わらない解答時間になるというオチ
- （公式解説）まぁ同じ色を先に組にしとけは確かにその通りだな……
  - 確証が持てなかったのですべての靴下を対象にした

## D - Reindeer and Sleigh
- AC（5分）
- 逆にこっちは簡単すぎィ！（茶色）
- $R_i$ を昇順に並び替えて累積和 $S_i$ にして、 $S_i \leq X$ となる最小の $i$ を答えるだけ。以上！
  - 強いて言えば`lower_bound`ではなく`upper_bound`になる点に気をつけるくらい

## E - Christmas Color Grid 1
- AC（17分）
- 概ね公式解説どおり
- 入力の際に赤色マスには $-1$ 、緑色マスには左上から順に $0, 1, \dots$ を書き込んでおくことで、グリッドのマスからUnion-Find木の頂点を $O(1)$ で引けるようにした
- 個人的にはこれもCより簡単に思えてしまう……

## F - Christmas Present 2
- AC（26分）
- どうみてもDPっぽいが素直にやると $O(N^2)$
  - とりあえず愚直にやってみて計算量改善を目指す方針で
- 以下 $d(i, j)$ を子ども $i$ の家と子ども $j$ の家との距離（ただし家 $0$ はサンタの家を表す）とする
- $\mathrm{dp}_{i,j}$ を「子ども $i$ の家までプレゼントを配り終わって、今持っているプレゼントの個数が $j$ となるような配り方における最小の移動距離」とすると、更新は以下の通り（以降最小値を取る操作は省略する）
  - $\mathrm{dp}_{i+1,j-1} \gets \mathrm{dp}_{i,j} + d(i, i+1)$ （プレゼントを取りに帰らない）
  - $\mathrm{dp}_{i+1,K-1} \gets \min_j \mathrm{dp}_{i,j} + d(i, 0) + d(0, i+1)$ （プレゼントを取りに帰る）
- ここでDPの定義を変えて「子ども $i$ の家までプレゼントを配り終わって、今持っているプレゼントの個数が $j$ となるような配り方において、プレゼントを取りに帰るために移動した余分な距離の最小値」としてみると、更新は以下のように変わる
  - $\mathrm{dp}_{i+1,j-1} \gets \mathrm{dp}_{i,j}$ （プレゼントを取りに帰らない）
  - $\mathrm{dp}_{i+1,K-1} \gets \min_j \mathrm{dp}_{i,j} + d(i, 0) + d(0, i+1) - d(i, i+1)$ （プレゼントを取りに帰る）
- 1つ目の更新の式はインデックスを1つずらすだけなのでそのまま使い回すことを考える
  - 今持っているプレゼントの個数を $k$ として、 $j = (i + k) \bmod K$ とすれば、さらに更新は以下のように変わる
    - $\mathrm{dp}_{i+1,j} \gets \mathrm{dp}_{i,j}$ （プレゼントを取りに帰らない）
    - $\mathrm{dp}_{i+1,(i+K-1) \bmod K} \gets \min_j \mathrm{dp}_{i,j} + d(i, 0) + d(0, i+1) - d(i, i+1)$ （プレゼントを取りに帰る）
- よって更新をIn-placeにできて、2つ目の更新のみ行えばよいようにできる
  - $\min_j \mathrm{dp}_{i,j}$ が $O(1)$ や $O(\log N)$ で求まるようなデータ構造を使えば十分に間に合う
    - どこに最小値があるかを管理するのがミスりそうだなと思い`segtree`にぶん投げた

## G - Christmas Color Grid 2
- 当然の時間切れ
- こういう問題文をちょっといじっただけなのに難易度がまるで異なるタイプのやつ、センスを感じて大好き
  - 2016年の京都大学入試数学を思い出す（理系と文系で1文字違いの問題が出題された）
- 後学のため一応メモ：
  - ある頂点を削除したときの連結成分の個数はlowlinkと呼ばれるアルゴリズムで解ける
  - undoつきUnion-Findたるなるものも存在する