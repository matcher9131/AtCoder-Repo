# [ABC359](https://atcoder.jp/contests/abc359) Review
- バーチャル参加
- Dが解けず焦るがEとFを解いて事なきを得る
  - Fが簡単で良かった…
- なおBでつまらぬミスを犯す
- 結果として700位相当

## D - Avoid K Palindrome
- 時間切れ
- 終了間際になって直前 $K$ 文字を見るDPならいけることに気づく
  - あと5分欲しかったぜ……
- 以下「末尾 $K$ 文字」は $K$ 文字に満たない場合は文字列全体を指すものとする
- $\mathrm{dp}_{i,s}$ を $i$ 文字の文字列で末尾 $K$ 文字が $s$ であるような良い文字列の数とおいて、 $i = 1, 2, \dots, N$ の順に以下の手順でDPを更新する
  - $S_i$ が `?` ではなく $s$ の末尾と異なるとき、 $\mathrm{dp}_{i,s} = 0$
    - これにより先頭 $i$ 文字が $T$ としてあり得ないパターンを除外する
  - $i \geq K$ かつ $s$ が回文になるとき、 $\mathrm{dp}_{i,s} = 0$
  - それ以外のとき
    - $i \geq K$ のとき、 $\mathrm{dp}_{i+1,s} = \mathrm{dp}_{i,s_A} + \mathrm{dp}_{i,s_B}$
      - ただし、 $s_A$ は `A`と $s$ の先頭 $K-1$ 文字をこの順で繋げてできる文字列、 $s_B$ は `B`と $s$ の先頭 $K-1$ 文字をこの順で繋げてできる文字列
    - $i < K$ のとき、 $\mathrm{dp}_{i+1,s} = \mathrm{dp}_{i,s'}$
      - ただし、 $s'$ は $s$ の末尾の1文字を除いた文字列
- 時間計算量は（回文判定を $O(K)$ として） $O(NK2^K)$

## E - Water Tank
- AC
- 広義連続増加列ごとにその最大値×含まれる区画数の水が必要になる
- $i = 1, 2, \dots , N$ の順に以下を行う
  - $j < i$ かつ $H_j > H_i$ となる最大の $j$ が
    - 存在するとき、板 $j$ より左を全て満たすのに必要な水の量を $W_j$ とすると、解は $W_j + (i - j)H_i + 1$
    - 存在しないとき、解は $(i - j)H_i + 1$
- 実装の際には`stack`に壁の高さ、壁番号、それより左を全て満たすのに必要な水の量を持たせるとし、各壁ごとにそれより高い壁が見つかるまで`pop`してから壁 $i$ を`push`し直すとした
- 時間計算量は $O(N)$ ？

## F - Tree Degree Optimization
- AC
- $A_i$ の小さい順に $f(T)$ が小さくなるように木構造を保ったまま各頂点を追加していく貪欲法をやってみたところ、どうやらいけそうなのでそのまま提出
- 木構造を保ったまま $A_i$ の昇順で1つずつ頂点を追加していくことを考える。また、このときの $f(T)$ の増分をコストと呼ぶことにする
  - すでに辺で繋がれた頂点に割り込む形で頂点を追加してもコストを最小にできない。なぜなら
    - 追加する頂点を $j$ とおくと、次数が $2$ となるためこの操作によるコストは $4A_j$
    - 一方で、追加する前の頂点で次数が $1$ のものが必ず存在し、これを $k$ とすると、$k$ に $j$ を直接繋いだときのコストは $A_j + 3A_k$
    - （ $A_i$ の昇順で頂点を追加していることから） $A_j \geq A_k$ を考慮すると前者のコストが後者より小さくなることはない
  - よってコストを最小にするには、すでに存在する頂点のいずれかに直接新たな頂点を繋ぐべきである
    - このとき追加する頂点 $j$ 側のコストは $A_j$ で固定なので、もう一方の頂点のコストが最小になるものを選べば良い
- 頂点 $i$ の現在の次数が $d_i$ のとき、次にその頂点に辺を追加することによって増加するコスト $c_i$ は $c_i = (2d_i + 1)A_i$ と表せる
  - よって`priority_queue`で $c_i$ を昇順で管理しながら頂点を追加していくことで解が求まる
- 時間計算量は $O(N \log N)$
