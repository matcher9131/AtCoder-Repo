# [ABC426](https://atcoder.jp/users/matcher)
- Rated参加
- 微増を除くと実に2ヶ月ぶりのレート上昇
  - この調子で1400に戻したいねぇ

## C - Upgrade Required
- AC（9分）
- 区間加算＆範囲に同じ値を代入したいのでLazy Segment Treeにアフィン変換を載せるやつでぶん殴る
  - しばらく考えたが他に絶対に`TLE`しない確証のあるものが思い浮かばなかったのでつい……
    - 一応公式解説に載ってて笑う
- 実は`map`や`priority_queue`あたりは考えたが、計算量を正しく見積もれずじまい
  - 実際にはバージョン $X_i$ 以下のものはすべて一律で $Y_i$ になるため、追加・削除される要素数の合計は高々 $N+Q$ 個にしかならない

## D - Pop and Insert
- AC（36分＋1WA）
- 所謂左右から累積和で $O(N)$ パティーン
  - …なのだが、考える累積和が4つあるのと実装が適当すぎて端の処理にもたつき時間がかかる
    - 挙げ句1箇所初期値を間違え`WA`
      - こういうときにサンプルが通ってしまうのがねぇ……
      - 14のテストケースのうち1つだけ通っていなかったので方針は合っていると思えたのは不幸中の幸い
- 左から $i$ 個全てを`1`にするのに必要な操作回数を $L_{1,i}$ とおくと、
  - $S_i = 1$ のとき、 $L_{1,i} = L_{1,i-1}$ （ただし、 $L_{1,0} = 0$ ）
  - $S_i = 0$ のとき、 $L_{1,i} = i + C_{1,i-1}$ （ただし、 $C_{1,i}$ は $1 \leq j \leq i$ における`1`の個数）
    - 操作によって $[1, i)$ における`0`はすべて`1`に変わるのでこれ以上操作しなくてOKだが、`1`は`0`になってしまうので再び操作が必要
      - しかし題意により`0`になったものを先頭に固めて置けばその個数分だけの操作回数で済む
  - 同様に $R_{1,i}, L_{0,i}, L_{1,i}$ を考えればよい

## E - Closest Moment
- AC（32分＋1WA）
- スタートしてからの時間を $t$ とおくと、二人の距離は $t$ の2次式のルートを取ったものなので極値は1つしか存在しない！
  - と思い込んで`WA`から15分が溶ける
- 正しくは早い方の一方がゴールする時刻を $t_1$ 、もう一方がゴールする時刻を $t_2$ として、区間 $[0,t_1], [t_1,t_2]$ のそれぞれで極値が1つしか存在しない
- 極値が1つしか存在しないならば三分探索でOK
  - `double`型での探索なので適当にそれぞれ50回固定で回した。時間はかかってしまうが仕方ない
