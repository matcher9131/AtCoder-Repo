# [あさかつ9/15](https://kenkoooo.com/atcoder/#/contest/show/c2c6781c-3e34-4b68-af8d-b439ad2b9beb) Review

## 第4問 - Destroyer Takahashi
- AC（16分）
- 列 $[x, x+D-1]$ にパンチしたときに $[x, x+D-1] \cap [L_i, R_i] \neq \emptyset$ を満たす壁 $i$ が壊れるが、これを以下のように言い換える
  - 列 $x$ にパンチしたときに $x \in [L_i-D+1, R_i]$ を満たす壁 $i$ が壊れる
- 以降 $L_i \get L_i-D+1$ とする
- 壁を $R_i$ の昇順に並べると、1番目の壁を壊すにはパンチをする列は $x \leq R_1$ である必要がある
  - 一方で上記を満たす列 $x$ にパンチしたとき、 $L_i \leq x$ を満たす壁 $i$ を全て破壊できる
- よってパンチをする列は、そのとき残っている壁のうちの $R_i$ の最小値とすればよい
- $R_i$ をキーとする優先度付きキューにすべての壁を放り込み、別途 $L_i$ の昇順にソートした壁の配列を用意すればOK
  - 優先度付きキューから壁を取り出し、破壊済みならスルー、未破壊ならパンチを実行して配列のどこまでを破壊したかを更新する流れで
    - なお実装の際は $R_i$ をキーとする優先度付きキュー、 $L_i$ をキーとする優先度付きキュー、壁が破壊済みかを記録する配列の3つを用いた
- 計算量は $O(N \log N)$

## 第5問 - League
- AC（31分）※時間切れ
- $\frac{N(N-1)}{2}$ 頂点のグラフを用意し、 $1 \leq i \leq N, 1 \leq j < N-1$ において頂点 $\{ i, A_{i,j} \}$ から頂点 $\{ i, A_{i,j+1} \}$ へ有向辺を張ると
  - 入次数が $0$ の頂点は真っ先に行われるべき試合になる
- よって1日ごとにグラフから入次数が $0$ の頂点およびその頂点に繋がる辺を一斉に削除することを繰り返せばよい
- ただし、サイクルが含まれる場合は条件を満たすことが不可能になる
  - 実装の際はサイクルを直接検出するのではなく、入次数 $0$ の頂点がなくなる際にすべての試合が行われたかどうかで判断した
- 次に入次数が $0$ になる頂点を記録するのに重複を防ぐ目的で`set`を用いたため、計算量は $O(N^2 \log N)$

## 第6問 - Triple Index
- 以下クエリ $(l, r)$ に対する解を $f(l, r)$ と表す
- $f(l, r)$ を連続する2区間の解 $f(l, m), f(m+1, r)$ からマージすることを考えると
  - マージ1回あたり区間 $[l, m]$ または $[m+1, r] に含まれる $A_i$ の種類数の計算量が必要になる
    - よってSegment treeを用いると $O(QN \log N)$ となり`TLE`不可避
- しかし $f(l,r)$ から $f(l \pm 1, r)$ ないし $f(l, r \pm 1)$ を得るのは $A_i$ 1個分の増減になるため差分を計算することで $O(1)$ に抑えられる
  - よってMo's algorithmに任せればOK
- 計算量は $O((N+Q)\sqrt{N})$
  - なお出現する数とその個数を管理するのに`map`を使うと`TLE`するが、`unordered_map`を使うと通る
