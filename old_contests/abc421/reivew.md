# [ABC421](https://atcoder.jp/contests/abc421) Review
- Rated参加
- 寝不足で突っ込んでDすら解けず
  - しかしD,E,Fのいずれも難しかったようでレートは-20で踏みとどまった
    - Eまで解けたのに-15を食らった前回とはエラい違いである
  - 尤も、寝不足でなくともD以降が全滅していた可能性は高い……

## D - RLE Moving
- 時間切れ
- RLEをほぐすところは問題なかったが、出会うかどうかの判断で鬼場合分けをしようとして撃沈
  - 連続して同じ方向に動くときは $(x_0 + kd_x, y_0 + kd_y)$ の形が最強と考えるべし
- （公式解説） $(dr)_a - (dr)_t \neq 0$ のとき $x = \frac{R_t - R_a}{(dr)_a - (dr)_t}$ と表せるが、ここで**割り切れるかどうかの判定を忘れない**ように注意（1敗）

## E - Yacht
- 時間切れ
- 公式解説と同じように $dp_{i,S}$ を計算しようとするもうまく整理できず
  - 多重集合をどうやって全列挙するのかと悩んでいたが、出目そのままを列としても大丈夫とは思わなんだ……

## F - Erase between X and Y
- 時間切れ
- 連結リストならワンチャンありそうとは気づいていたのでD,Eを投げ出せばできていたかもしれない
- 実際には本物の連結リストではなく`next[i]`で管理することでランダムアクセスを $O(1)$ でできるようにする
  - 今回の題意からして片方向連結リストでいけるので`next[i]`のみでOK
  - `std::list`は要素の追加・削除で（削除される要素を指すもの以外の）イテレータが壊れないので、`std::list`とランダムアクセスのための`vector<list::iterator>`の組み合わせでもできなくはないが
    - `next, prev`を直につなぎ直す手段がなく1つずつ削除する必要があるので正直手間がかかる
- $x$ と $y$ のどちらが先かわからないならそれぞれを交互に操作すればいいは正直に目から鱗
