# [ABC370](https://atcoder.jp/contests/abc370) Review
- バーチャル参加
- Eを解く時間が足りない！

## D - Cross Explosion
- AC
- ~~ボンバーマンかな？~~
- 行ごとに残っている壁の列インデックス、列ごとに残っている行のインデックスを`set`で管理し、二分探索でどの壁を壊すべきかを求める
  - 右方向/下方向は`lower_bound`で一発
  - 左方向/上方向は↑で求めたイテレータを1つ戻せばOK
    - あらかじめ番兵として $0$ を加えておくとイテレータの扱いが楽
    - イテレータを使って要素を`erase`するときは大きい方を先に消さないとイテレータの挙動が面倒くさくなるので注意（今回は大きいほうが先に求まるので大丈夫）
  - 二重に管理しているのでもう一方の更新を忘れずに
- 解は各`set`の要素数を舐めるより、別途変数を用意して壁を壊す毎に変化させたほうが計算量が少ない
- 計算量は $O(HW + Q \log (H + W))$ ？
  - メモ：`set`をコピーコンストラクタで初期化したときの計算量は $O(N)$

## E - Avoid K Partition
- 時間切れ
- 累積DPであること、累積和をキーとする`map`を利用することまでは気付いたがそこから先が詰められず
- 負数を含む数列 $\{A_i\}$ に対して $\sum_{i=l}^{r} A_i = K$ となる区間 $[l, r]$ を $O(N)$ で求める方法：
    1. 集合 $T_x$ を（ $x$ によらず）空集合とする
    1. $i = 1, 2, \dots, N$ に対して以下を行う
        1. 累積和 $S_i$ を求める
        1. $T_{S_i} \gets T_{S_i} \cup \{ i \}$ とする
        1. $T_{S_i - K}$ に含まれる各要素 $j$ に対し区間 $[j, i]$ が求めるものである
    - 累積和を計算しながら同時に $T$ を見ていく必要がある
        - 累積和のみ先に計算すると $T$ の要素に $j > i$ が入り込んでしまう
    - $T$ は`unordered_map<int, vector<int>>`などで管理すればOK
    - 実際に区間を列挙するとなると計算量 $O(N)$ では済まない点に注意
        - この問題に関しては $T_x$ をインデックスの集合として保持する必要はなく、代わりに $\sum_{j \in T_x} \mathrm{dp}_j$ を保持すればよい
