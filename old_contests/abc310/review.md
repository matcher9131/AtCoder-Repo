# ABC310 Review
- バーチャル参加
- ケアレスミスを除きCまで順調
  - しかしやはりDの壁
  - AtCoder ProblemsによるとCまで灰色、Dから水色とかなり極端な模様
- ビット列への意識が足りない

## A
- AC
- 後から見ると`std::sort`ではなく`std::min_element`でよかった件について

## B
- AC (1 WA)
- 悪い点
  - **問題文はきちんと読むこと**（1週間ぶり $n$ 回目）
  - 上位互換かどうかに関しては、
    - まず`std::include`を知らなかった点は反省
    - ↑を使わないなら明らかにビット列で管理するほうが楽
      - 製品 $j$ が製品 $i$ の機能をすべて持つかどうかは`f[i] & f[j] == f[i]`で判定できる
      - さらに製品 $j$ が製品 $i$にない機能を持つかどうかは（↑を前提にすると）`f[i] ^ f[j] > 0`で判定できる

## C
- AC
- 自分の解法： $O(N)$（のはず）
    - ポイント
      - 文字列 $S$ とその逆順にしたもの（以下 $r(S)$ と表す）が同じとみなされる仕組みさえ考えれば、あとはセットに突っ込むだけ。
    - 手順
      1. 順に与えられる文字列 $S_i$ に対し、$S_i$ と $r(S_i)$ のうち辞書順で早いほうのみを`unordered_set`に入れる。
      2. セットのサイズを答える
- 良い点
  - 初めはそのままのものと逆順にしたものの両方をセットに突っ込んでサイズを2で割れば良いと考えたが、回文だと1回しか挿入されないことにすぐに気づけた

## D
- 時間切れ
  - コードは終了後に解説を見て書いたもの
- 組み合わせを鬼場合分けで個別に計算しようとして撃沈
- 公式解説の（個人的）ポイント整理
  - $N$ が小さいため、チームの構成をビット列で表現すれば全チームを表すのに`vector<vector<int>>`ではなく`vector<unsigned>`で済む
    - さらに相性もビット列で表現すれば、ある選手に対してそのチーム内に相性の悪い選手がいるかどうかがビット演算で $\Theta (1)$ でわかる
  - 全体をどうにかしようとするのではなく、一人ずつ順番に追加していく
    - 全体を見て数学的考察が必要な問題がある一方で、それが無理なら1から順番に探索すべし
- 実際に書いてみてハマったポイント
  - `vector`を再帰関数で取り回す（かつその中で要素の追加がある）ときは **あらかじめ`reserve()`を呼んでおく** こと！
    - 要素追加時に`size() >= capacity()`だと領域の再確保が行われ、イテレータが死ぬ
      - よくわからないところで例外落ちするのでデバッグがやりづらい
      - イテレータを使わなければいいという話でもあるが、範囲for文が便利すぎるので…