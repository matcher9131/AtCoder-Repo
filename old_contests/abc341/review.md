# [ABC341](https://atcoder.jp/contests/abc341) Review
- バーチャル参加
- Fまで解けて700位台中盤相当
- D,E,Fが全てほぼ23分ってどういうことなの……

## C - Takahashi Gets Lost
- AC（10分）
- すべての陸のマスから実際に移動を試して途中orゴールが海でないことを確認すればOK…なのだが
  - 計算量 $O(HWN)$ で $HWN \approx 1.3 \times 10^8$ って大丈夫か？と尻込みする
    - 実際のところは`if`と配列アクセスしかないため定数倍が軽く何も問題なかった（137ms）

## D - Only one of two
- AC（23分＋1MLE）
- $N, M$ の最小公倍数を $L$ とおくと、
  - 対象となる数の列は周期 $L$ を成す
  - 区間 $(0, L)$ において $N$ で割り切れる数は $M-1$ 個、 $M$ で割り切れる数は $N-1$ 個で、これらに重複する数はない
- よって区間 $(0, L)$ で対象になる数を昇順に並べた数列を $A$ 、 $q = \left\lfloor \frac{K}{N+M-2} \right\rfloor, r = K \bmod (N+M-2)$ とすると
  - 解は $qL + A_{r}$
    - ただし、 $r = 0$ のときは $q$ を1減らし、 $r = N + M - 2$ とする（実際には0-indexedで考えればこの操作は不要）
- 何を思ったか $A$ を配列に保存してしまい`MLE`を喰らう
  - `long long`で要素数 $2 \times 10^8$ だと1600MiBﾃﾞｽﾖﾈｰ

## E - Alternating String
- AC（23分）
- `{ 先頭の要素, 末尾の要素, 条件を満たしているかどうか }`を`lazy_segtree`に持たせて反転操作を`apply`でやるゴリ押し実装
- （公式解説） $S_i = S_{i+1}$ かどうかを持てば範囲更新いらんやん……

## F - Breakdown
- AC（23分）
- 数列 $B_i$ を頂点 $i$ にコマが1個置かれたときに行える操作回数の最大値とする
  - 頂点 $i$ に隣接する頂点集合を $S_i$ とおくと、 ${\displaystyle B_i = 1 + \max_{T \subset S_i, \sum_{j \in T} W_j < W_i} \sum_{j \in T} B_j}$
    - すなわち、頂点 $i$ に隣接する頂点から $W_j$ の和が $W_i$ 以上にならないように選んだときの $B_j$ の和の最大値を求めればよく、これはまさに典型的なナップサック問題
      - 頂点 $i$ に隣接してかつ $W_j < W_i$ となる $j$ について $B_j$ が求まっていれば$B_i$ を求めることができるので、 $W_i$ の昇順で考えればよい
- 解は $\sum_{i=1}^N A_i B_i$
- DPを $N$ 回やるという発想がちゃんと出てきてよかった……