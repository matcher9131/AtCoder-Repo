# [ABC417](https://atcoder.jp/contests/abc417) Review
- Rated参加
- 時間ギリギリでFまで解いて790位台
  - 久しぶりの青色パフォーマンス……レート増加（+34）……ｳﾚｼｲ……

## D - Takahashi's Expectation
- AC（30分）
- 何をしてよいか分からず結構な時間固まる
  - またDが長時間解けずにレートが減る未来が見えて冷や汗をかく
- おそらくDPであることと、後ろから見れば結果が確定できそうであることをなんとか落ち着いて見出し、 $\mathrm{dp}_{i,j}$ を $i$ 個目のプレゼントをもらう直前のテンションが $j$ のときの最終のテンションとして $0 \leq j \leq 500$ でDPを作ろうとするが（解は $\mathrm{dp}_{1, X}$ ）
  - $j + A_i > 500$ のときの遷移が面倒くさい……どころか、そこもちゃんと考慮しないと最終テンションがわからなくなることに気づく
    - 幸いにも題意よりテンションが $1000$ 以下のときはどんなプレゼントを貰っても新たなテンションは $1000$ 以下にしかならないので、 $0 \leq j \leq 1000$ でDPを作って事なきを得た
- あとは初期テンションが $1000$ を超えているときの対処だが
  - 上述よりテンションが $1000$ 以下になるまでは減りっぱなしなのが確定しているので、プレゼントを $k$ 個貰ったときに初めてテンションが $p \leq 1000$ になるような $k,p$ が求まれば $\mathrm{dp}_{k+1,p}$ が解になる
    - 勿論 $k$ を求めるのに $O(N)$ でやると意味がないので、 $B$ の累積和を作って $X_i - 1000$ を二分探索で求めた
- 計算量は $M=1000$ として $O(NM \log N)$
- 後ろからDPは何度やっても慣れない……
  - $i$ を $N$ 要素にするか $N+1$ 要素にするか、 $\mathrm{dp}$ の添字と $P$ の添字がずれるのかずれないのか、判断に時間がかかる……
    - 今回はさらに上述の $k$ がズレてるのもあって余計に時間を消費した
- <span style="color: silver;">ところで、最近のD問題難しすぎない……？</span>
  - って思ったら案の定水色かつEより難しいのかよ！

## E - A Path in A Dictionary
- AC（10分＋α）
- Dijkstraで距離の最小値を管理するところにパスを`vector`で無理やりぶち込むという超脳筋仕様
  - C++の`vector`がデフォルトで辞書順比較をしてくれるのマジでありがたい……
- なお、辞書順最小を満たすために辺を列挙する際は向かう頂点番号が昇順になるようにあらかじめソートしておく
- あとはこれで単純パスであることを担保できるのかという問題があるが
  - もしある頂点への辞書順最小パスに同じ頂点が2度現れるとすると（例：`[3, 1, 4, 1, 5]`）
    - この場合頂点 $5$ に至る前に頂点 $1$ への辞書順最小パスが`[3, 1, 4, 1]`になっている必要があるが、明らかに`[3, 1]`のほうが辞書順で小さいため矛盾する
      - ので、必ず単純パスになる……<span style="color: silver;">はず……</span>
- 元々のDijkstraの計算量は $O((N+M)\log N)$ であり、パスの比較に $O(N)$ かかるので全体で $O(N(N+M)\log N)$
  - $N(N+M) \leq 5.1 \times 10^7$ なので一応なんとかなったらしい（740ms）
  - 空間計算量も $O(N^2)$ なのでメモリ使用量も317MBとなかなかにやばい
- Fを解いた後で時間がなかったのでヤケクソで↑を書いて終了1分前に滑り込み提出
  - 終了後もしばらくジャッジがされなかったので特大フラグ「風呂入ってくる」を発動させるもまさかの`AC`で逆に動揺した
- （公式解説）普通にDFSでいいんすね……

## F - Random Gathering
- AC（46分－α）
- 1回の操作ごとに $S_i = \sum_{i = L_i}^{R_i}$ として、 $L_i \leq i \leq R_i$ を全て $\frac{S_i}{R-L+1}$ に書き換えればOK
- 区間加算ならLazy segment treeでできるが、区間代入ってどうやってやるんだ……と思ったが
  - 前に区間に $b$ 倍して $c$ を足すのがあったような気がして、「 $0$ 倍して $\frac{S_i}{R-L+1}$ を足す」とすれば実現可能なのではないかと気づく
- 検索してみると[ACL Practice Contest K - Range Affine Range Sum](https://atcoder.jp/contests/practice2/tasks/practice2_k)とほぼドンピシャなものが見つかったので、その解説記事を見て実装した……のだが
  - 微妙に異なる結果が返ってくる
    - 正確には毎度の操作ごとに全要素を`get`で出力させるとちゃんと解になるのだが、そうしないと最後の`get`で異なる値を出してしまうという微妙なバグに見舞われる
      - 要するにどうもモノイド作用がちゃんと伝わってないっぽい
- 散々頭を悩ませた挙げ句、`composition`の`f`と`g`がもしかして逆なのでは……？と思い入れ替えてみるとあっさり直った
  - **教訓：解説記事であっても内容を鵜呑みにしてはいけない**
- （公式解説）`optional<T>`を使う手もあるのか……！
