# [ABC322](https://atcoder.jp/contests/abc322) Reivew
- バーチャル参加
- Cまでが簡単すぎてビビる
- Dにかなり時間を食われたので本番だとEが間に合っているかどうか
- そして安定のFから解けない

## A - First ABC 2
- AC
- 何故か`string::substr()`を使わない実装（絶対そっちのほうが早い）

## B - Prefix and Suffix
- AC
- 結局`string::substr()`使うんかい！

## C - Festival
- AC
- $i$ ごとに $A$ を二分探索で計算量 $O(N \log N)$
  - もっと計算量が少ない方法はすぐには思いつかなかったので↑でパパっと提出

## D - Polyomino
- AC
- やるべきことはわかるが実装が煩雑
  - 実際のところ水色問題になっている模様
- うまい方法が思いつかず、あれこれ考えるより愚直に多重ループを書いたほうが早い！となって
  - まさかの**9重ループ**が完成
    - こんなもん書いたことない…
  - そして1個目のミノは回転させなくても良いことに後で気づく
    - それでも8重ループであるわけだが
- 公式解説でも全探索が想定解なので方針としては何ら間違ってなかった
  - ~~書いたコードは確実に間違っているが~~
- なお自分の解答は元のミノと回転させたミノを全て保持しているが、その必要はなく90度ずつ回転させたものを上書きしていっても問題はない

## E - Product Development
- AC
- $dp_{i,X}$ を「$i$ 番目の開発案まで実行するかどうかを決めてパラメータが数列 $X$ になるような最小のコストの和」とおくと
  - 初期値
    - $dp_{1,A_1} = C_1$
    - 他は $dp_{i,X} = \infty$
  - 遷移
    - $dp_{i + 1, X} = \min \{ dp_{i + 1, X}, dp_{i, X} \}$
    - $dp_{i + 1, X + A_i} = \min \{ dp_{i + 1, X + A_i}, dp_{i, X} + C_i \}$
      - ただし $X + A_i$ は数列 $X, A_i$ の各要素を足して得られる数列とする
  - 解は $dp_{N, X}$ の中で $X$ の各要素が $P$ 以上であり $dp_{N, X}$ が最小となるものである
- あとは実装のために $X$ や $A_i$ をどうやって1つの整数で表すかを考える必要がある
  - $1 \leq P \leq 5$ であることから各パラメータは8進数で1桁に収まり、$1 \leq K \leq 5$ より高々 $8^5 = 32768$ 通りで表せる
    - 無論6進数のほうが計算回数が少なくて良いのだが実装が面倒なので8進数にした
  - 単純に $X + A_i$ とすると各パラメータの和が8以上になる場合繰り上がって他のパラメータに影響を及ぼしてしまうので、和が $P$ を超えるときは $P$ とみなすようにすればOK
- 計算量は $O(NP^K + P^K)$
