# ABC311 Review
- Rated参加
- `WA`も`TLE`もなくEまで駆け抜けられた
  - 間違いなく勉強の成果が出ている！
- 一方で実装速度に難がある
  - Fまで解くことを目指すとなるとまだまだ遅い

## A
- AC
- 小文字と大文字を間違えるというボケをかます
  - 相変わらずのスロースターターである

## B
- AC
- $ND = 10^4$ なので単純に全探索でOK

## C
- AC
- はじめUnion-findでやろうとして親から閉路を復元しようとしてやらかす
  - 当然、親が必ず閉路に含まれるとは限らない
  - Union-findでも閉路復元できるのだろうが、よくわからなかったので改めてDFSでやりなおし
    - このグダグダ具合である
    - というか出次数が1だからDFSですらないという話もある
- 自分の解法： $O(N)$
    - ポイント
        - 入次数も出次数も1なので、探索途中にすでに訪れた頂点が出てきた瞬間に閉路の存在がわかる
            - かつその頂点が必ず閉路に含まれる
    - 手順
        1. DFSで行きがけ順に頂点を記録する
        1. 既に記録している頂点に訪れたらDFSを終了する
        1. ↑の頂点を起点としてグラフを辿って閉路を復元する

## D
- AC
- 床が氷で滑って岩にぶつかるまで止まれない…
  - ~~ポケモン金銀のこおりのぬけみちを思い出した人は決して少なくないはず~~
- 自分の解法： $O(\max \{ M^2N, MN^2 \})$？だと思う…
    - ポイント
        - 基本はグリッドグラフにおけるDFSを行う
            - ただし、「訪れたことのあるマス（止まったことのあるマスを含む）」と「止まったことのあるマス」の2つを分けて保持する
            - 止まったことのあるマスは、`true`/`false`ではなくそこから次の探索でどの向きに動いたかを記録
                - 単に止まったことのあるマスを記録するだけだと、データの持ち方ゆえに「そのマスから行ける他の止まったことのあるマス」がすぐにわからない
                    - よって同じ動きを2回以上してしまい無限ループ不可避
                    - きちんとループを回して探せば無限ループは避けられるが、最悪 $\max \{ N, M \}$ 回の探索で計算量がマズい
    - 手順
        1. 立ち止まったかどうかに関係なく訪れたことがあるマスを記録する配列`visited`を用意する
        1. 立ち止まったマス、およびそこから動いた方向（上/下/左/右）を記録する配列`stopped`を用意する
        1. 以下のようにDFSを行う
            1. `stopped`の現在のマスを見て、上下左右のうちまだ記録されていない方向を調べる
            1. ↑で得られた方向のそれぞれに対し、
                1. `stopped`の現在のマスに今から動く方向を記録する
                1. 岩に当たるまで訪れたマスを記録しながら移動する
        1. 訪れたことがあるマスの数を数えて出力する
- 余談
  - 考察にこおりのぬけみちの経験が生きて草
  - 人によってはどうでもいい話かもしれないが、グリッドの縦横のサイズは $N, M$ でなく $H, W$ で書いてほしい…

## E
- AC
- 愚直にループを回しまくるのは $O(\min \{ H^3W^2, H^2W^3 \})$ となり余裕で`TLE`なので却下
- 何をしてよいかわからなかったが、ちょっと前にグリッド内の最大長方形を求める問題で参考にしたサイトがあったためそれを頼りに何とかならないかと探していたところ
  - [ALGORITHM NOTE 最大正方形の面積　正方形探索](http://algorithms.blog55.fc2.com/blog-entry-131.html)にたどり着く
    - 「本問の求めるものとは異なるが何かの参考になるだろう」と思い記事を読んでいると、記事中の`W[i][j]`の総和がそのまま解答になることに気づく
      - 筆者に深く感謝してあとは実装あるのみ
- 自分の解法： $O(HW)$
    - 手順
        1. $dp_{i, j}$ を「マス $(i, j)$ を右下角とする最大の正方形の1辺の長さ」と定める
        1. 1行目のDP初期値を以下のように定める
            - マス $(0, j)$ が穴ならば、$dp_{0, j} = 0$
            - そうでないならば、 $dp_{0, j} = 1$
        1. 1列目のDP初期値を↑と同様に定める
        1. $i \geq 2, j \geq 2$ に対し以下の手順でDPを更新する
            - マス $(i, j)$ が穴ならば $dp_{i, j} = 0$
            - そうでないならば、$dp_{i, j} = \min \{ dp_{i-1, j-1}, dp_{i-1, j}, dp_{i, j-1} \} + 1$
        1. $\sum_{i} \sum_{j} dp_{i, j}$ を求めて出力する
    - ポイント
        - DP遷移に関しては↑の記事の通り
        - ↑の記事では最大正方形を求めるのに使っていたが、$dp_{i, j} = k$ は「マス $(i, j)$ を右下とする異なるサイズの $k$ 個の正方形が存在する」と読み替えられ、$(i, j)$ の組が異なれば得られる正方形は異なるものになるため、単純にDPを合計するだけで解が得られる

## F
- 時間切れ
