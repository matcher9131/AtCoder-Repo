# AtCoder Problems Recommendation (Difficult) Reivew
AtCoder Problems RecommendationのDifficultでおすすめされる問題をひたすら解いてひたすらレビューする

## ABC243 E - Edge Deletion
- 各頂点からDijkstra法を行い、最短経路を復元して使用された辺以外を削除したらいいのではないかと考えたが
  - 同じ距離で2ルート以上ある場合に使わなくてよい辺をうまく検出できず`WA`
- 公式解説を見る
  - 各辺について必要かどうかを1つずつ判断する必要がある
    - ↑の解き方のときに2頂点 $i, j$ の距離 $d_{i,j}$ を記録する必要がなかったため、この発想に至らなかった

## AGC018 B - Sports Festival
- 恐らくは二分探索法だろうなぁと思いつつ
  - 最も多くの人が参加するスポーツの参加人数を $x$ 人以下にできるかどうかを判定する部分をどうしようかと悩む
- 結局 $N \leq 300, M \leq 300$ であるのをいいことに、以下のようにゴリ押しで判定することにする
    1. 全てのスポーツを実施するものとする
    1. 現状で実施するスポーツの数を $m$ とするとき、$\lceil N/m \rceil \gt x$ ならば`false`を返す
    1. 実施される各スポーツについて参加する人数をカウントし、その最大値が $x$ 以下なら`true`を返す
    1. 最も多い人数が参加するスポーツを実施しないものとして、2.に戻る
- 計算量は $O(NM^2 \log N)$？
- そして提出後に二分探索の必要が全くないことに気づく
  - 実施しないスポーツの選択はいつも同じ順番で行われるので、1つずつ実施しないスポーツを選びながら最多参加者の最小値を記録していけばよい

## [ABC202 E - Count Descendants](https://atcoder.jp/contests/abc202/tasks/abc202_e)
- 木において頂点 $v$ が頂点 $u$ の子孫かどうかの判定
  - LCA + ダブリング
    - 参考：[ダブリングによる木の最近共通祖先（LCA：Lowest Common Ancestor）を求めるアルゴリズム | アルゴリズムロジック](https://algo-logic.info/lca/)
    - 前処理 $O(N \log N)$ 、クエリ $O(\log N)$
    - パッと思いついたのはこっち
      - しかし複数の頂点を一括して処理できないため本問だと間に合わない
  - オイラーツアー + タイムスタンプ
    - 頂点 $i$ の行きがけ・帰りがけの時刻をそれぞれ $s_i, t_i$ とおくと、頂点 $v$ が頂点 $u$ の子孫である条件は $s_u < s_v < t_u$
    - 二分探索により複数の頂点を一括して処理できる
- クエリ先読みかと思ったら別にそんなことはなかった

## [ABC223 F - Parenthesis Checking](https://atcoder.jp/contests/abc223/tasks/abc223_f)
- 正しい括弧列：括弧レベル
  - `(`を $+1$ 、`)`を $-1$ に対応させ、その累積和が途中で $0$ 未満になったら不正、ならなかったら正規
- 以下 $A_i$ を $i$ 文字目終了時の括弧レベルとする（ $A_0 = 0$ ）
- クエリ $1$ のとき
  - $S_l$ が`(`で $S_r$ が`)`のとき、入れ替えによって区間 $[l, r)$ の括弧レベルが $-2$ される
  - $S_l$ が`)`で $S_r$ が`(`のとき、入れ替えによって区間 $[l, r)$ の括弧レベルが $+2$ される
- クエリ $2$ のとき
  - $l$ 文字目開始前の括弧レベルは $A_{l-1}$ で、これを基準として括弧レベルを見ればよい
    - よって $S$ の $l$ 文字目から $r$ 文字目が正しい括弧列になる条件は $A_r = A_{l-1}$ かつ $l \leq i \leq r$ において $A_i \geq A_{l-1}$
- クエリ $1$ は区間加算、クエリ $2$ は区間最小値取得でいけるので`lazy_segtree`の出番
- ここまですぐに分かったのに実際の $S$ をswapし忘れて1敗
  - しかもそれになかなか気づかないという

## [ARC064 E - Cosmic Rays](https://atcoder.jp/contests/arc064/tasks/arc064_c)
- AC（17分）
- バリア $i,j$ が共通部分を持つとき、宇宙線を浴びずに移動できる
- バリア $i,j$ が共通部分を持たないとき、それぞれのバリアの中心を結ぶ直線上を移動すれば宇宙線を浴びる時間を最小にできる
  - 具体的な時間はバリア $i,j$ の中心間距離を $d(i,j)$ として $d(i,j) - r_i - r_j$
- また簡単のためスタート地点を半径 $0$ のバリア $0$ 、ゴール地点を半径 $0$ のバリア $N+1$ としておく
- 各バリアを頂点、↑の方法で計算した時間を辺とする完全グラフを考えれば、求めるべきは頂点 $0$ から $N+1$ への最短パスのコストとなる
  - よってあとはDijkstraに丸投げ
    - 計算量は $O(N^2 \log N)$

## [ABC225 E - フ](https://atcoder.jp/contests/abc225/tasks/abc225_e)
- $i$ 個目の「フ」に対し、 $(x_i, y_i-1)$ の偏角を $\theta_i$ 、$(x_i-1, y_i)$ の偏角を $\phi_i$ とおくと
  - 原点から $i$ 個目の「フ」が見える必要十分条件は区間 $(\theta_i, \phi_i)$ が他の区間と交わらないこと
- 制約より「フ」が $x$ 軸を跨ぐことはないので、あとは単なる区間スケジューリング問題だからいける！と思いきや
  - おそらく`long double`型では表せない微小な差のせいで`WA`
- そして第一象限にしかないんだから偏角ではなく原点を通る直線の傾きで十分であることに気づく

## [ABC246 F - typewriter](https://atcoder.jp/contests/abc246/tasks/abc246_f)
- $N \leq 18$ および $|S_i| \leq 26$ より $N$ 段から任意の段数を取り出す方法 $2^N$ 通りを全探索しても問題なさそう
- $T_0 = {1, 2, \dots, N}$ に対し $T \subset T_0$ とする
  - このとき、全ての $j \in T$ 段目に共通して現れる文字列は、すべての段に存在する文字種の数を $c$ として $c^L$ 個存在する
- あとは全ての $T$ に対してこれを数え、包除原理を用いて解を求める
- 計算量はアルファベットの文字種を $C$ として $O(NC2^N)$

## [ABC382 E - Expansion Packs](https://atcoder.jp/contests/abc382/tasks/abc382_e)
- 典型的な期待値DP
- ただし遷移確率そのものをDPで求める必要がある

## [ABC045 D - すぬけ君の塗り絵](https://atcoder.jp/contests/abc045/tasks/arc061_b)
- 以下3行3列の連続するマス目をセクションと呼ぶ
- 黒いマスの個数が $1$ 以上になるセクションは高々 $9N$ 個しかないため、それらに対して全探索を行えばOK
  - あるマスが黒いかどうかは`set`で黒いマスを保持しておくことで1回あたり $O(\log N)$ で判定できる
- 黒いマスの個数が $0$ のセクションの個数は余事象で求められる
  - セクションの全体数は $(H-2)(W-2)$
- 計算量はセクションあたりのマスの数を $M$ として $O(M^2N \log N)$

## [ABC271 F - XOR on Grid Path](https://atcoder.jp/contests/abc271/tasks/abc271_f)
- 全ての移動方法は $\frac{(2N-2)!}{(N-1)!^2} \approx 3.5 \times 10^{10}$ 通りなので試せないが
  - 正方形のグリッドなので $i+j=N+1$ となるマス $(i,j)$ のいずれかを通ることが確定する
    - 以降この条件を満たすマスを折り返しマスと呼ぶことにする
- マス $(1,1)$ から折り返しマスまでの移動方法、折り返しマスからマス $(N,N)$ までの移動方法はそれぞれ $2^{N-1}$ 通りなのでともに全列挙可能
- あとは折り返しマスごとに前半で得られる値と後半で得られる値を組み合わせて題意を満たすものを数えればよい
- 計算量は $O(2^N \log N)$

## [ABC377 E - Permute K times 2](https://atcoder.jp/contests/abc377/tasks/abc377_e)
- 頂点 $i$ から $P_i$ に有向辺を張るとサイクルor自己ループしか含まないグラフになる
- 入力例1で $K$ の値を変えながら手元で試すと、どうやら最終的な $P_i$ の値は頂点 $i$ から $2^K$ 回辺を辿った頂点になるらしいことに気づいた
- よってあとは各サイクルor自己ループがどんなものかが分かればOK
- 計算量は $O(N log K)$
