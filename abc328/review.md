# [ABC328](https://atcoder.jp/contests/abc328) Review
- バーチャル参加
- 1時間ちょっとでFまで到達して600位相当
  - Fは事前に解いたことがあったので不正気味だが、Weighted Union-Findを使うことが分かれば躓きようがないのでまぁ……


## D - Take ABC
- AC（11分）
- 双方向リストで管理すれば走査・削除含めて $O(N)$ にできるやろ！という軽いノリで`std::list`を使う
  - どうでもいいがはじめて使ったかもしれん…
- イテレータが今指している箇所が`A`ならば、イテレータを複製して1文字先、2文字先を読む方針で
  - 勿論途中で`s.end()`に到達しないことを確認すべし
  - `ABC`が揃ったらこの3つを削除し、イテレータを2つ戻す
    - 削除した箇所の直前が`AB`で直後が`C`のパターンに対応するため
    - 勿論戻る途中で`s.begin()`より左に行かないように注意しべし
- （公式解説）常に末尾3文字をチェックしながら1文字ずつコピー……エレガントですねぇ

## E - Modulo MST
- AC（36分）
- $N \leq 8$ より $M \leq 28$ で、 $M$ 本の辺から $N-1$ 本を選ぶので組み合わせの最大値は $1.2 \times 10^6$ 程度
  - なのでまぁ全探索が基本方針だろうと踏み込む
- [全域木を列挙してみた #全域木 - Qiita](https://qiita.com/tomomasu1113/items/5ee94e65b2cbd19d6475)を参考に全ての全域木を列挙しコストを求めた
- ってこれ緑色なんかい！
  - 最近の緑色コーダーが出来すぎて怖い……
- （公式解説） $0,1$ のみの配列に対して`next_permutation`することで全組み合わせを列挙している……のだけれども
  - `basic_string<bool>`ってなんじゃい！と思ったら、`vector<bool>`はテンプレート特殊化されてるせいで`range::fill()`や`range::reverse()`のオーバーロードが解決できないわけね……
    - にしても今回は素直に`vector<int>`でいいと思うんだが……まぁ頭の片隅にはいれておこう

## F - Good Set Query
- AC（7分）
- 前述の通り一度解いたことがあったが、問題そもそもを覚えておらず
  - 解き方を考えてWeighted Union-Findで行けそうだなと思った瞬間に、そういえばこの問題でWeighted Union-Findをライブラリ化したんだったと思い出す始末
