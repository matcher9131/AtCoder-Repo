# [ABC344](https://atcoder.jp/contests/abc344) Review
- バーチャル参加
- Eは解けたものの時間を食い1300位台相当

## D - String Bags
- AC（16分）
- どうみてもDPですありがとうございました
- 計算量は $A_i$ の最大値を $A$ 、 $|S_{i,j}|$ の最大値を $|S|$ として $O(|T|NA|S|) = 10^6$ なので余裕で間に合う

## E - Insert or Erase
- AC（38分）
- linked listを使えたら楽だなと思いつつ、どうやって値 $x$ のノードを探すのかと考えていたが、
  - しばらく時間を使った後にノードを`map`や`unordered_map`で管理すればいけるのではないかと思いつく
    - すぐに気付けていたらかなり順位を上げられたのだが……
- `map[x] = { y, z }`で値 $x$ の前後の値がそれぞれ $y, z$ とした
  - 先頭の前の要素および末尾の次の要素には $0$ を用いて実装を簡略化した（番兵）
  - linked listに`std::list`を使い、`map<int, iterator>`で直接イテレータを管理する方法もある
    - `std::list`だとそのデータ構造上`insert`や`erase`してもイテレータが壊れない点を利用したもの

## F - Earn to Advance
- 時間切れ
- （公式解説） $P_{i,j}$ ではなく今まで通ったマスの $P_{i,j}$ の最大値 $P$ さえ分かればよいというのは、言われたらそれしかあり得ないと思えるが思いつかんな……
  - かつ、 $P$ はせいぜい $N^2$ 通りしかないので`unordered_map`などに任せれば十分DPに使える
  - さらには、`dp[行][列][P最大値][行動回数] = 所持金最大値`や`dp[行][列][P最大値][所持金] = 行動回数最小値`ではなく`dp[行][列][P最大値] = (行動回数, 所持金)の最適値`（行動回数昇順→所持金降順で比較）とするのもポイントとなるか