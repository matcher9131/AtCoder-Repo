# ABC320 Review
- 大☆爆☆死
  - パフォーマンスが1000を切る失態
- 時間を溶かした上に解けないといういつもの発動
  - 見切りが大事
- まぁ翌日（レビューを書いているのがそもそも翌日なので今日）もコンテストがあるので切り替えて頑張りましょう

## [A - Leyland Number](https://atcoder.jp/contests/abc320/tasks/abc320_a)
- AC
- `std::pow()`に丸投げ
  - 一応、入力例の $A=B=9$ のケースを見て`float`でも情報落ちをしないことの確認は入れた

## [B - Longest Palindrome](https://atcoder.jp/contests/abc320/tasks/abc320_b)
- AC
- $S \leq 100$ なのをいいことに、長さ $N$ の $S$ の（連続する）部分文字列全てに対して回文かどうかの判定を、$N$ が大きいほうから順次行うという力技で実装

## [C - Slot Strategy 2 (Easy)](https://atcoder.jp/contests/abc320/tasks/abc320_c)
- WAからの時間切れ
- 言語化は難しいが、何か複雑に考えすぎて処理できなかった
- しかも終了後に解説を見ずにコードを書いて提出した(AC)が、嘘コードであることが後から発覚するというグダグダっぷり
  - ソシャゲの特効キャラかといわんばかりの刺さりっぷりである
- そして解説を見て愕然とする
  - リールの止める順番を先に決めて探索…なぜこんな単純なことが思い浮かばなかったのか

## [D - Relative Position](https://atcoder.jp/contests/abc320/tasks/abc320_d)
- AC (1WA)
- グラフの辺に2つの情報を持たせれば単にDFSするだけの問題
- 自分の解法：計算量 $O(N + M)$
    1. 各 $i$ に対し
        - 頂点 $A_i$ から頂点 $B_i$ へ有向辺 $E_{A_i,B_i} = (X_i, Y_i)$ を張る
        - 頂点 $B_i$ から頂点 $A_i$ へ有向辺 $E_{B_i,A_i} = (-X_i, -Y_i)$ を張る
    2. $V_1 = (0, 0)$ とする
    3. 頂点 $1$ を始点として以下のようにDFSを行う
        - 既に座標がわかっている頂点 $a$ からわかっていない頂点 $b$ への辺 $E_{a,b}$ が存在すれば、$V_b = V_a + E_{a,b}$ とする
    4. DFSで訪れなかった頂点は一意に定まらないものとする
 
## [E - Somen Nagashi](https://atcoder.jp/contests/abc320/tasks/abc320_e)
- WAからの時間切れ
- `priority_queue`を用いるところまではよかったのだが、単に人 $j$ が最後に列に戻る時刻をキーにしてしまってうまく捌けず
  - 正しくは、時刻 $T_i$ の時点で人 $j$ が最後に列に戻った時刻を $x_j$ として、$x_j \leq T_i$ を満たす最小の $j$ を見つけなければならない
- こんな処理を $O(\log N)$ でできるデータ構造なんてあったっけ？セグメント木でもないよな？などと思っているうちに時間切れ
- （公式解説）2つの異なる事柄（「そうめんが流される」「人が列に戻ってくる」）を同じ`priority_queue`で処理する発想は無かったよ…
- これ緑色問題ってマジ！？
  - 過去問を解いている感覚だとどう考えても最低水色なんだが…