# [ABC409](https://atcoder.jp/contests/abc409) Review
- Rated参加
- 65分＋1WAでFまで解けて史上最高順位を叩き出す
  - 一発でレート1400台に復帰＆最高レーティング更新
- 一方でCでオーバーフローを起こして`WA`
  - い　つ　も　の
    - これがなかったらまさかのパフォーマンス黄色だったという

## D - String Rotation
- AC（11分）
- 制約より $l$ は $S_i > S_{i+1}$ となる最小の $i$ となる
  - 存在しない場合は $l = r$ とすることにより $S$ そのままを解にできる
- さらに $r$ は $S_l < S_{j+1}$ となる最小の $j > l$ となる
  - 存在しない場合は $r = N$ になる
- やるべき操作が一意に定まるのは楽でいいっすね……

## E - Pair Annihilation
- AC（16分）
- 1対の陽電子と電子に注目した場合、その最短パス上で対消滅させないと明らかに損
  - 逆に最短パス上ならどの頂点で対消滅させても必要なエネルギーは変わらない
- よってグラフが木であることから、葉にある陽電子・電子を隣接する頂点に移動させてから葉とそれに繋がる辺を消して問題ない
  - 葉は他の任意の2頂点の最短パス上に来ないことから、陽電子・電子を移動させたあとに再び陽電子・電子が来る可能性がないため
    - もちろん陽電子・電子のない葉も消してOK
- ↑の操作を頂点が1つになるまで繰り返す
  - グラフを`vector<unordered_map<int, ll>>`で保持して次数が1の頂点を`queue`で管理すれば楽
- 計算量は $O(N)$
- 制約の値がやたらと小さいのでひょっとして $O(N)$ 解法ではないのか……？と思ったが問題なかったようだ

## F - Connecting Points
- AC（24分）
- 最大頂点数は $N + Q \leq 3000$ なので全頂点間の距離を計算しても間に合う
- よって $G$ の補グラフ $G'$ （辺のコストは $d(u, v)$ に等しい）を常に辺のコストの昇順で管理するようにしておけばすべてのクエリに対応できる
  - $G$ で各頂点が連結かどうかを判断するUnion Findと、 $G'$ の辺を距離の昇順で管理する`priority_queue`を用意した
    - クエリ2はキューが空なら $G$ が連結と判断でき、そうでなければキューの先頭の距離と等しい要素をすべてキューから出してUnion FindでつなげるようにすればOK
- Union Findは途中で拡張できないが、連結かどうかを判断するためだけにしか使っていないため、あらかじめ多めに確保しておけば問題ない
- 計算量は $O((N + Q)^2 \log (N+Q))$
