# [ABC361](https://atcoder.jp/contests/abc361) Review
- バーチャル参加
- Dを落とすもFが解けたので1000位以内相当

## D - Go Stone Puzzle
- 時間切れ
- 全状態数を見誤り単にBFSでOKなことに気づかず……
  - ダメ元でBFSしておくべきだった

## E - Tree and Hamilton Path 2
- AC
- ハミルトン路って言ってるけどどちらかというとオイラーツアーなのでは？
  - そして最長パスだけ引けばいいのでは？
    - 以上。

## F - x = a^b
- AC(1WA)
- 単純に $b$ を固定して $a \geq 2$ に対して $a^b \leq N$ となる $a$ の個数を求める方針で
  - $2^{60} > 10^{18}$ より $b \geq 60$ は考慮しなくてよい
  - $8^2 = 4^3$ のように複数の表し方がある数が重複してしまうので、包除原理に基づいて以下を行う
    - $b$ が素数の場合をカウントして足す
    - $b$ が異なる2個の素数の積で表される場合をカウントして引く
    - $b$ が相異なる3個の素数の積で表される場合をカウントして足す
    - 相異なる4個の素数の積は最低でも $2 \times 3 \times 5 \times 7 = 210$ 以上なのでこれ以上包除原理を考慮する必要はない
  - それ以外の $b$ は必ずそれより小さい $b$ を用いて書き直せるためカウントしない
- $b < 60$ なのをいいことに↑をベタ書きするという暴挙に出る
  - 30行以上似たような処理が続く狂気のソースコードが完成した
- $a^b \leq N$ の判定については`powl(a, b)`を用いた
  - オーバーフローを考慮しなくて良いのは楽だが
    - はじめ`pow(a, b)`を使っていて仮数部の精度にやられてしまい、1つのテストケースで`WA`を食らう
  - long double型の精度は実行環境次第らしく、場合によってはdouble型と同じであるためちょっと嘘解法感が漂う……
    - ただ`pow(a, b)`を`powl(a, b)`に変えたら`AC`になったということは、少なくともAtCoderで提出する分にはlong double型の仮数部は64ビット以上と考えて良さそうだ