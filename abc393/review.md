# [ABC393](https://atcoder.jp/contests/abc393) Review
- Rated参加
- 早々にEを見限ってFに行けたのでレート微増

## D - Swap to Gather
- AC
- こういうのはだいたい`1`のインデックスの中央値を中心として固めればいけるはず…ということで、`1`のインデックスからなる整数列を $A$ 、その長さを $K$ 、中央値を $m$ として
- `1`が奇数個の場合
    - $\frac{K+1}{2}$ 番目の`1`を $S_m$ のままにして、 $i$ 番目の`1`を $S_{m + i - \frac{K+1}{2}}$ へ動かす
- `1`が偶数個の場合
    - `1`のインデックスの中央値が非整数の場合
        - 中央値が $m' + \frac{1}{2}$ と表されるとすると、 $\frac{K}{2}$ 番目の`1`を $S_{m'}$ へ動かし、 $i$ 番目の`1`を $S_{m' + i - \frac{K}{2}}$ へ動かす
    - `1`のインデックスの中央値が整数の場合
        - $\frac{K}{2}$ 番目か $\frac{K}{2} + 1$ 番目の`1`を$S_m$ へ動かせばOKでいずれも同じ解になるはずだが、念の為2つとも計算して比べる
- これで最小になる証明はマンハッタン距離の和の最小化と同じような雰囲気でできる…はず

## E - GCD of Subset
- 時間切れ（終了後に公式解説を見て提出）
- $\max_{1 \leq i \leq N} A_i = X$ として、そもそも約数列挙の時点で計算量 $O(N\sqrt{X})$ で`TLE`なのでは…？と思いつつ
  - $C_i$ を $A$ の項のうち $i$ で割り切れるものの個数として、各 $A_i$ を約数列挙することで $C$ を前計算して $\max_{d|A_i} C_d$ を求めてみるもやっぱり`TLE`
- 約数列挙ではなく倍数列挙にするのがポイント
  - すなわち、外側のループを`for (int d = 1; d <= x; ++d)`、内側のループを`for (int m = i; m <= x; m += d)`とすれば、 各 $d$ に対して $X$ 以下の $d$ の倍数を列挙できて、合計の計算量は $O(X\log X)$ で済む
    - 今回は $S_d$ を $A$ の項で $d$ に一致するものの個数として、 各 $d,m$ に対して $C_d \gets C_d + S_m$ とすればOK
    - さらに同様に $C_d \geq K$ を満たす $d$ に対して、 $d$ の倍数となるように $m$ を増やしていきながら $m$ の最大値を $G_m$ に記録するようにすれば、 $G_{A_i}$ が解になる
  - 感覚的には貰うDPから配るDPに書き換えるのと似ている気がする

## F - Prefix LIS Query
- AC
- 区間が $[1, R_i]$ となっているのがポイント
- LISを求めるアルゴリズムは $i = 1, 2, \dots$ と順番に見ていくうえに途中経過も区間 $[1, i]$ におけるLISとなってそのまま使えるため、あらかじめクエリを $R_i$ の昇順で並び替えておけば順に答えられる
- すなわち、以下の通り
    1. $R$ の昇順でクエリを並び替える
    1. $L$ を空の整数列、 $i = 1$ とする
    1. $j = 1, 2, \dots$ の順に $j$ 番目のクエリに対して以下を行う
        1. $i$ が $R_j$ に等しくなるまで $1$ ずつ増やしながら以下を行う
            1. $k$ を $A_i \geq L_k$ を満たす最小の $k$ を二分探索で求める
            1. $L_k \gets A_i$ とする
        1. $L$ の要素で $X_j$ 以下のものの個数を二分探索で求め、クエリの解とする
- これ下手したら緑色なのでは……？
